Project,Key,Summary,Issue Type,Status,Priority,Resolution,Assignee,Reporter,Creator,Created,Last Viewed,Updated,Resolved,Affects Version/s,Fix Version/s,Component/s,Due Date,Votes,Watchers,Images,Original Estimate,Remaining Estimate,Time Spent,Work Ratio,Sub-Tasks,Linked Issues,Environment,Description,Security Level,Progress,Σ Progress,Σ Time Spent,Σ Remaining Estimate,Σ Original Estimate,Labels,Rank,Status Whiteboard,Epic Link,Tags,Flagged,Rank (Obsolete),Epic/Theme,Sprint,Issuezilla Id
javacc,JAVACC-296,Release version 6.1.3 on Maven Central repository,Bug,Open,Blocker,Unresolved,super_glassfish,ptitjes,ptitjes,23/Jul/16 12:59 PM,03/Aug/16 6:06 PM,23/Jul/16 12:59 PM,,6.0,,"general, parser generator",,0,1,,,,,,,,Any,"The version 6.1.2 (rev 628) released on Maven Central repository has a blocker bug in the code generator when using both STATIC = false and TOKEN_MANAGER_USES_PARSER = true options. It prevents to compile the generated parser code. 
 
 The svn repository already contains a fix and a ""6.1.3"" tag (rev 667) already exists after this fix. See this diff (628-667) to see the fix: 
 https://java.net/projects/javacc/sources/svn/diff/trunk/src/main/java/org/javacc/parser/ParseGen.java?rev1=628&rev2=667 
 
 Please release the 6.1.3 version and push it to the Maven Central repository.",,,,,,,,0|i0jp6n:,,,,,9223372036854775807,,,
javacc,JAVACC-295,C++: Enoying shift in call/return traces when,Improvement,Resolved,Major,Fixed,francisandre,francisandre,francisandre,14/Jun/16 4:26 PM,,08/Jul/16 1:28 PM,08/Jul/16 1:28 PM,current,,general,,0,0,,,,,,,,"JDK 1.7_51, Win7 Pro","Hi 
 
 When generating a debug parser that contains production with non void return type, the call/return traces are shifted. Here a sample 
 
 Token* identifier(): {Token* t;} { t = <IDENTIFIANT> { return t; } } 
 
 produces 
 Token * Parser::identifier() { 
 trace_call(""identifier""); 
 try { 
 		Token* t; 
 		if (!hasError) { 
 			t = jj_consume_token(IDENTIFIANT); 
 		} 
 		return t; 
 } catch(...) { } 
 trace_return(""identifier""); 
 	assert(false); 
 } 
 
 The trace_return(""identifier"") is never called and thus, on each identifier found, the indentation is shifted by 2... 
 
 While not a bug per se, it is quite ennoying for debugging grammar with a lot of lookahead since by the end, the call trace is shifted to the rigth of the line.",,,,,,,logging,0|i0jog7:,,,,,9223372036854775807,,,
javacc,JAVACC-294,svn checkout trunk + mvn install fails,Bug,Open,Major,Unresolved,super_glassfish,francisandre,francisandre,04/Jun/16 5:53 PM,,04/Jun/16 5:53 PM,,current,,general,,0,1,,,,,,,,"Windows 7 Pro, amd64, java 1.7.0_51","Hi 
 
 Just done a checkout of the trunk svn repository and run mvn install which fails on tests 
 
 svn checkout https://svn.java.net/svn/javacc~svn/trunk javacc 
 build.cmd 
 mvn install 
 
 Results : 
 
 Failed tests: testMainProgramHTML(org.javacc.jjdoc.test.JJDocMainTest): expected:<0> but was:<1> 
 testMainProgramText(org.javacc.jjdoc.test.JJDocMainTest): expected:<0> but was:<1> 
 testDefaults(org.javacc.parser.OptionsTest): expected:<37> but was:<49> 
 testDumpNonAsciiMoveMethods(org.javacc.parser.test.NfaStateTest): expected:<> but was:<(..) 
 testDumpMoveNfa(org.javacc.parser.test.NfaStateTest): expected:<> but was:<(..) 
 
 Tests in error: 
 testDumpCharAndRangeMovesInitialised(org.javacc.parser.test.NfaStateTest): src\org\javacc\parser\JavaCC.jj (Le chemin dÆaccÞs spÚcifi 
 Ú est introuvable) 
 testDumpNonAsciiMoveMethodsInitialised(org.javacc.parser.test.NfaStateTest): src\org\javacc\parser\JavaCC.jj (Le chemin dÆaccÞs spÚci 
 fiÚ est introuvable) 
 testDumpStatesForStateInitialised(org.javacc.parser.test.NfaStateTest): src\org\javacc\parser\JavaCC.jj (Le chemin dÆaccÞs spÚcifiÚ e 
 st introuvable) 
 testDumpStatesForKindInitialised(org.javacc.parser.test.NfaStateTest): src\org\javacc\parser\JavaCC.jj (Le chemin dÆaccÞs spÚcifiÚ es 
 t introuvable) 
 testDumpStateSetsInitialised(org.javacc.parser.test.NfaStateTest): src\org\javacc\parser\JavaCC.jj (Le chemin dÆaccÞs spÚcifiÚ est in 
 trouvable) 
 testDumpMoveNfaInitialised(org.javacc.parser.test.NfaStateTest): src\org\javacc\parser\JavaCC.jj (Le chemin dÆaccÞs spÚcifiÚ est intr 
 ouvable) 
 testDumpStatesForState(org.javacc.parser.test.NfaStateTest): This should never be null. 
 testDumpStatesForKind(org.javacc.parser.test.NfaStateTest): This should never be null.",,,,,,,,0|i0joan:,,,,,9223372036854775807,,,
javacc,JAVACC-293,Generated Parser code has a memory leak,Bug,Open,Major,Unresolved,super_glassfish,markt_asf,markt_asf,20/May/16 10:12 AM,,20/May/16 10:12 AM,,6.0,,parser generator,,0,1,,,,,,,,,"The generated code: 
 {code} 
 static private final class LookaheadSuccess extends java.lang.Error { } 
 {code} 
 needs to be replaced with 
 {code} 
 static private final class LookaheadSuccess extends java.lang.Error { 
 /* 
 * Over-ridden to avoid memory leak via Throwable.backtrace 
 */ 
 @Override 
 public synchronized Throwable fillInStackTrace() { 
 return this; 
 } 
 } 
 {code} 
 to prevent the context class loader of the current thread being pinned in memory via the Throwable.backtrace field. This causes memory leaks in modular environments such as Servlet containers that use a class loader per module and need the class loader to be GC'd when the module is unloaded.",,,,,,,,0|i0jnuv:,,,,,9223372036854775807,,,
javacc,JAVACC-292,Null pointer exception from BUILD_PARSER=false,Bug,Open,Minor,Unresolved,super_glassfish,theo,theo,01/Jan/16 5:25 PM,,01/Jan/16 5:25 PM,,current,,general,,0,1,,,,,,,,,"A null pointer exception is thrown by JavaCC 6.0 and JavaCC 6.1.0 when option BUILD_PARSER = false used. See example below. 
 
 
 $ cat MFE.jj 
 options 
 { 
 BUILD_PARSER = false ; 
 } 
 
 PARSER_BEGIN(EOFInComment) 
 public class EOFInComment 
 { 
 } 
 PARSER_END(EOFInComment) 
 
 TOKEN: { ""a"" } 
 
 $ javacc MFE.jj 
 Java Compiler Compiler Version 6.1_0 (Parser Generator) 
 (type ""javacc"" with no arguments for help) 
 Reading from file MFE.jj . . . 
 File ""TokenMgrError.java"" is being rebuilt. 
 File ""ParseException.java"" is being rebuilt. 
 File ""Token.java"" is being rebuilt. 
 File ""SimpleCharStream.java"" is being rebuilt. 
 Exception in thread ""main"" java.lang.NullPointerException 
 	at org.javacc.parser.OtherFilesGen.start(OtherFilesGen.java:143) 
 	at org.javacc.parser.Main.mainProgram(Main.java:262) 
 	at org.javacc.parser.Main.main(Main.java:154) 
 	at javacc.main(javacc.java:36)",,,,,,,,0|i0jjpj:,,,,,9223372036854775807,,,
javacc,JAVACC-291,Maven build gets terminated when javacc is used to generate source,Bug,Open,Major,Unresolved,super_glassfish,thomasabraham,thomasabraham,17/Nov/15 1:32 PM,,17/Nov/15 1:32 PM,,,,,,0,1,,,,,,,,,"I'm using javacc to generate source code in my maven project. 
 I'm using exec-maven-plugin to run javacc as part of the build process. 
 But org.javacc.parser.Main is calling System.exit which is terminating my build process.",,,,,,,,0|i0jinz:,,,,,9223372036854775807,,,
javacc,JAVACC-290,Unicode parsing problems,Bug,Open,Major,Unresolved,ainsleyc,ainsleyc,ainsleyc,26/Jul/15 12:33 AM,,26/Jul/15 12:41 AM,,6.0,,parser generator,,0,1,,,,,,,,,"JavaCC has an issue that it cannot generate (Java) code that handles a Unicode char stream UNLESS option ""JAVA_UNICODE_ESCAPE = true;"" is specified. 
 
 Setting this option to true (default is false) will generate the ""JavaCharStream"" class instead of the ""SimpleCharStream"" class, and will wire up the lexer and parser to use this char stream by default. This is troublesome because this option performs byte substitution at the character stream level for ""\uxxxx"" pattern, which is not required in many parsers, and in fact, would be a show-stopping bug for writing compliant parsers for most languages as this sequence of characters would always be transparently replaced by the JavaCC generated code. 
 
 There is also an option to specify a user written charstream class using ""USER_CHAR_STREAM=true;"", which then references a class called ""CharStream"" from the same package as the generated code (but this class is user supplied, not generated if the option is specified with a value of true). 
 
 To get to the point, well, the ONLY way that JavaCC currently works with Unicode is via the ""JAVA_UNICODE_ESCAPE = true;"" method. Even if a custom char stream is specified. The problem isn't ""SimpleCharStream"", this appears to be Unicode compatible. The problem is that different code is generated if the ""JAVA_UNICODE_ESCAPE = true;"" option is specified so that the high and low bytes are taken into consideration by the generated code. 
 
 The option ""UNICODE_INPUT=true|false(default);"" exists, and I think it should exist for the purpose of generating unicode compatible code - but it does nothing but disable some warnings (verified via source review). 
 
 The fix is to wire up the code generation so that UNICODE_INPUT will be used correctly, when generating code, and to decouple the unicode code generation exclusively from ""JAVA_UNICODE_ESCAPE = true;"" Unicode compatible code generation should happen if UNICODE_INPUT or JAVA_UNICODE_ESCAPE are supplied with a value of true, but the JavaCharStream class should only be generated if ""JAVA_UNICODE_ESCAPE = true;"".",,,,,,,unicode,0|i0h8s7:,,,,,100568,,,
javacc,JAVACC-289,NPE in ParseException.initialise,Bug,Open,Major,Unresolved,ainsleyc,donvip,donvip,27/Jun/15 1:00 PM,,13/Jul/15 3:07 AM,,current,,parser generator,,0,3,,,,,,,,,"This is an upstream bug report for 
 https://josm.openstreetmap.de/ticket/11593 
 
 In case of invalid data, a ParseException is generated by JavaCC. 
 However, in this particular case, we're in a situation where currentToken.next is null in this part of ParseException.initialise(): 
 
 retval += ""\"" at line "" + currentToken.next.beginLine + "", column "" + currentToken.next.beginColumn; 
 
 thus leading to the NullointerException. 
 
 Is it possible to produce more robust code?",,,,,,,,0|i0h6of:,,,,,100227,,,
javacc,JAVACC-288,"getNextToken catches all Exception-s, not just IOException-s",Bug,Open,Major,Unresolved,super_glassfish,ddekany,ddekany,09/Apr/15 5:42 PM,,09/Apr/15 5:42 PM,,6.0,,scanner generator,,0,1,,,,,,,,,"When the `Reader` throws an {{IOException}}, {{SimpleCharStream.FillBuff():125}}, catches it: 
 {code:java} 
 catch(java.io.IOException e) { 
 --bufpos; 
 backup(0); 
 if (tokenBegin == -1) 
 tokenBegin = bufpos; 
 throw e; 
 } 
 {code} 
 
 Note that this will only catch `IOException`-s. Then the above re-throws the exception, which will be re-catched here, in {{WhateverTokenManager.getNextToken()}}: 
 
 {code:java} 
 try 
 { 
 curChar = input_stream.BeginToken(); 
 } 
 catch(Exception e) 
 { 
 jjmatchedKind = 0; 
 jjmatchedPos = -1; 
 matchedToken = jjFillToken(); 
 return matchedToken; 
 } 
 {code} 
 
 This above catches all kind of {{Exception}}-s, not just {{IOException}}! In JavaCC 3.2 (where I migrate from) it has only catched {{IOException}}-s. This has some consequences. First of all, JavaCC has this rather strange and dangerous behavior that it silently treats these catched exceptions as end-of-file. (I had to work this around, otherwise if there's a network outage or such during the reading of the stream, I get an incomplete parsing result without any error indication.) So now that also applies to `RuntimeExceptions`-s. In 3.2 at lest those were bubbled up to the parser caller. Furthermore, in the case of `RuntimeException`-s this catch block will be executed without {{FillBuff}}'s catch block executed first, which leads to this: 
 
 {code} 
 java.lang.ArrayIndexOutOfBoundsException: -1 
 	at freemarker.core.SimpleCharStream.getBeginLine(SimpleCharStream.java:243) 
 	at freemarker.core.FMParserTokenManager.jjFillToken(FMParserTokenManager.java:6667) 
 	at freemarker.core.FMParserTokenManager.getNextToken(FMParserTokenManager.java:6705) 
 	at freemarker.core.FMParser.jj_scan_token(FMParser.java:4967) 
 	at freemarker.core.FMParser.jj_3_16(FMParser.java:4149) 
 	at freemarker.core.FMParser.jj_2_16(FMParser.java:3242) 
 	at freemarker.core.FMParser.Root(FMParser.java:3107) 
 {code}",,,,,,,,0|i0gpan:,,,,,97411,,,
javacc,JAVACC-287,JavaCC-generated parser can cause stack overrun,Bug,Open,Major,Unresolved,datacompboy,datacompboy,datacompboy,06/Feb/15 10:46 AM,,17/Feb/15 12:15 PM,,current,,general,,1,4,,,,,,,,,"Generated parser can easily overrun stack in generated CPP and Java. 
 And if in Java it just would raise stack exception (rarely catched, because noone expect that), then in C++ it would crash whole application. 
 
 There three kinds of stack overruns: 
 1) generated big jjtree, that caused stack overrun on destruction due to recursive destruction 
 2) while proceeding different possible options, deep stack in phase1 
 3) while processing lookahead, deep stack in jj_2 / jj_3 pieces. 
 
 I have added DEPTH_LIMIT option to javacc compiler, that limits maximum recursion count of generated parser. 
 Its safe to have it enabled for both java and cpp, but if you want to disable it, just define that limit to 0, it would remove it and generate same parser as before.",,,,,,,,0|i0ghan:,,,,,96115,,,
javacc,JAVACC-286,C++: Parser is generated with a reference instead of a pointer,Bug,Open,Major,Unresolved,super_glassfish,brigl,brigl,08/Jan/15 8:19 AM,,09/Jan/15 6:30 AM,,current,,parser generator,,0,2,,,,,,,,C++,"Defining a rule like: 
 {code} 
 void Value() : 
 {} 
 { 
 < FLOATING > #Number 
 | < STRING > #String 
 } 
 {code} 
 
 generates in the the switch - statement of the parser a reference instead of a pointer: 
 {code} 
 voidParser::Value() { 
 switch (jj_nt.kind) { 
 ... 
 } 
 {code} 
 
 The code in the ParserEngine.java should be changed to: 
 {code} 
 ... 
 case NOOPENSTM: 
 	retval += ""\n"" + ""switch (""; 
 	if (Options.getCacheTokens()) { 
 		if(Options.getOutputLanguage().equals(Options.OUTPUT_LANGUAGE__CPP)) { 
 		retval += ""jj_nt->kind) {\u0001""; 
 	} else { 
 		retval += ""jj_nt.kind) {\u0001""; 
 	} 
 ... 
 {code}",,,,,,,,0|i0gbsv:,,,,,95225,,,
javacc,JAVACC-285,Avoiding exceptions for controlling flow,Bug,Open,Major,Unresolved,super_glassfish,synhershko,synhershko,09/Dec/14 5:37 PM,,09/Dec/14 5:37 PM,,,,"parser generator, scanner generator",,0,1,,,,,,,,,"We are using JavaCC generated code in Lucene.NET, a .NET port of Java Lucene. A user has recently identified an optimization opportunity related to JavaCC generated code. It appears if we avoid using exceptions from controlling flow when possible we can get significant performance gain. 
 
 Here's the original ticket + commits to our codebase (Lucene.NET). 
 
 https://issues.apache.org/jira/browse/LUCENENET-541 
 https://github.com/apache/lucene.net/commit/ac8c9fa809110ddb180bf7b2ce93e86270b39ff6 
 https://git-wip-us.apache.org/repos/asf?p=lucenenet.git;a=blobdiff;f=src/core/QueryParser/QueryParserTokenManager.cs;h=ec09c8e451f7a7d1572fbdce4c7598e362526a7c;hp=17583d20f660fdb6e4aa86105c7574383f965ebe;hb=41ebbc2d;hpb=ac8c9fa809110ddb180bf7b2ce93e86270b39ff6 
 
 Originally reported as https://issues.apache.org/jira/browse/LUCENE-5723",,,,,,,,0|i0g6m7:,,,,,94385,,,
javacc,JAVACC-284,TokenMgrError should remember and expose lexical error information,New Feature,Open,Minor,Unresolved,super_glassfish,Matthew_Cline,Matthew_Cline,19/Oct/14 6:58 AM,,19/Oct/14 6:58 AM,,,,,,0,1,,,,,,,,,"The TokenMgrError class should have class members for EOFSee, lexState, errorLin, errorColumn, errorAfter, curChar, and reason, and a means to get at them after the error has been created, like by making the members public. 
 
 The class constants should be made public as well. 
 
 Of course, it's easy enough to manually modify the class to do this, but you shouldn't need to make such modifications.",,,,,,,,0|i0fo5r:,,,,,91395,,,
javacc,JAVACC-283,javadoc part of binary-distribution target is showing error on jdk 8,Bug,Open,Major,Unresolved,Unassigned,skygolanur,skygolanur,10/Jun/14 12:25 PM,,10/Jun/14 12:25 PM,,6.0,,general,,0,0,,,,,,,,jdk 8 - windows,"On jdk8 it's not possible to do binary-distribution because javadoc is having error
 
 h2. Subissue 1:
 On the non generated source some html code are not valid:
 
 Example: src/main/java/org/javacc/parser/RZeroOrMore.java around line 29
 (<foo*>) should be written (&lt;foo*&gt;)
 
 I cannot attach patch :( I copy it at the very end of description.
 
 h2. Subissue 2:
 On the generated source 3 errors are shown like the following
 * ParseException: <result of getMessage>
 The bootstrap javacc.jar seems too old and generate this wrong javadoc code. Modern javacc seems not using the same pattern.
 
 Best Regards
 
 
 h2. patch
 
 
 {panel:title=Patch| borderStyle=dashed| borderColor=#ccc| titleBGColor=#F7D6C1| bgColor=#FFFFCE} 
 {code} 
 Index: src/main/java/org/javacc/parser/ROneOrMore.java
 ===================================================================
 --- src/main/java/org/javacc/parser/ROneOrMore.java	(revision 664)
 +++ src/main/java/org/javacc/parser/ROneOrMore.java	(working copy)
 @@ -29,7 +29,7 @@
 package org.javacc.parser;
 
 /**
 - * Describes one-or-more regular expressions (<foo+>).
 + * Describes one-or-more regular expressions (&lt;foo+&gt;).
 */
 
 public class ROneOrMore extends RegularExpression {
 Index: src/main/java/org/javacc/parser/RRepetitionRange.java
 ===================================================================
 --- src/main/java/org/javacc/parser/RRepetitionRange.java	(revision 664)
 +++ src/main/java/org/javacc/parser/RRepetitionRange.java	(working copy)
 @@ -31,7 +31,7 @@
 import java.util.List;
 
 /**
 - * Describes one-or-more regular expressions (<foo+>).
 + * Describes one-or-more regular expressions (&lt;foo+&gt;).
 */
 
 public class RRepetitionRange extends RegularExpression {
 Index: src/main/java/org/javacc/parser/RZeroOrMore.java
 ===================================================================
 --- src/main/java/org/javacc/parser/RZeroOrMore.java	(revision 664)
 +++ src/main/java/org/javacc/parser/RZeroOrMore.java	(working copy)
 @@ -29,7 +29,7 @@
 package org.javacc.parser;
 
 /**
 - * Describes zero-or-more regular expressions (<foo*>).
 + * Describes zero-or-more regular expressions (&lt;foo*&gt;).
 */
 
 public class RZeroOrMore extends RegularExpression {
 Index: src/main/java/org/javacc/parser/RZeroOrOne.java
 ===================================================================
 --- src/main/java/org/javacc/parser/RZeroOrOne.java	(revision 664)
 +++ src/main/java/org/javacc/parser/RZeroOrOne.java	(working copy)
 @@ -28,7 +28,7 @@
 package org.javacc.parser;
 
 /**
 - * Describes zero-or-one regular expressions (<foo?>).
 + * Describes zero-or-one regular expressions (&lt;foo?&gt;).
 */
 
 public class RZeroOrOne extends RegularExpression {
 Index: src/main/java/org/javacc/parser/TokenProduction.java
 ===================================================================
 --- src/main/java/org/javacc/parser/TokenProduction.java	(revision 664)
 +++ src/main/java/org/javacc/parser/TokenProduction.java	(working copy)
 @@ -61,7 +61,7 @@
 
 /**
 * The states in which this regular expression production exists. If
 - * this array is null, then ""<*>"" has been specified and this regular
 + * this array is null, then ""&lt;*&gt;"" has been specified and this regular
 * expression exists in all states. However, this null value is
 * replaced by a String array that includes all lexical state names
 * during the semanticization phase.
 {code} 
 {panel}",,,,,,,,0|i04e67:,,,,,25625,,,
javacc,JAVACC-282,org.javacc.parser.Main.reInitAll is missing call to org.javacc.parser.ParseGen.reInit ();,Bug,Open,Major,Unresolved,Unassigned,phax,phax,15/May/14 8:39 PM,,15/May/14 8:40 PM,,6.0,,,,0,0,,,,,,,,,"Version: 6.1.2
 Class: org.javacc.parser.Main
 Method: public static void reInitAll
 
 A call to
 org.javacc.parser.ParseGen.reInit ();
 
 is missing.
 This is relevant when using JavaCC in a Maven plugin with multiple exexcutions, as well as for the unit tests!
 
 I just added it to the end of reInitAll and everything works fine!",,,,,,,,0|i090vr:,,,"java, maven",,52632,,,
javacc,JAVACC-281,ParserGen generate wrong constructor call according to option,Bug,Open,Major,Unresolved,ainsleyc,skygolanur,skygolanur,09/May/14 2:04 PM,,09/May/14 9:09 PM,,6.0,,parser generator,,0,0,,,,,,,,javacc 6.1.2,"I was trying to upgrade javacc-maven-plugin localy but the integration test fails because wrong constructor call is generated
 
 line 448:
 genCodeLine("" token_source = new "" + cu_name + ""TokenManager(jj_input_stream);"");
 should be replaced by:
 if (Options.getTokenManagerUsesParser() && !Options.getStatic()) {
 genCodeLine("" token_source = new "" + cu_name + ""TokenManager(this, jj_input_stream);"");
 } else {
 genCodeLine("" token_source = new "" + cu_name + ""TokenManager(jj_input_stream);"");
 }",,,,,,,,0|i0c4vz:,,,,,70777,,,
javacc,JAVACC-280,Calls to ReInit() sometimes causes null pointer exceptions,Bug,Open,Major,Unresolved,ainsleyc,ainsleyc,ainsleyc,05/May/14 10:20 PM,,05/May/14 10:20 PM,,6.0,,,,0,0,,,,,,,,,"The ReInit() method assumes that jj_input_stream and token_source member variables have non-null values, which may not necessarily be a true assumption if a user-generated constructor did not initialize these values (auto generated constructors do initialize these values).",,,,,,,,0|i07v9r:,,,,,45891,,,
javacc,JAVACC-279,"SimpleCharStream is not compatible with JAVA_TEMPLATE_TYPE=""modern""",Bug,Open,Major,Unresolved,ainsleyc,ainsleyc,ainsleyc,05/May/14 9:00 PM,,05/May/14 9:00 PM,,,,parser generator,,0,0,,,,,,,,,"SimpleCharStream's constructor's and ReInit() methods are not compatible with the parsers generated by the modern java template type. The modern template type replaces specific IO classes with the Provider interface (which is new to 6.1).
 
 JavaCharStream's template was updated to use Providers rather than explicit IO interfaces, but SimpleCharStream was left behind, and a TODO was left in the appropriate location.
 
 Trigger condition::
 
 If the following is specified:::
 
 JAVA_TEMPLATE_TYPE = ""modern"";
 
 Without the following being specified:::
 
 JAVA_UNICODE_ESCAPE = true;",,,,,,,,0|i07mmv:,,,,,44492,,,
javacc,JAVACC-278,pom.xml is using modelVersion 5.0.0 which is really too young...Plesae rollback to the commonly modelVersion 4.0.0,Bug,Closed,Major,Incomplete,Unassigned,francisandre,francisandre,13/Apr/14 5:52 PM,,04/Jun/16 5:46 PM,04/Jun/16 5:46 PM,current,,general,,0,0,,,,,,,,,"Hi
 
 I am trying to use Maven to build javacc but maven rejects the modelVersion of 5.0.0; please rollback to the common used modelVersion 4.0.0 which is also used by Eclipse maven.",,,,,,,,0|i07jiv:,,,,,43988,,,
javacc,JAVACC-277,"For CPP target, NODE_INCLUDES better be included by Node.h",Improvement,Open,Major,Unresolved,Unassigned,massmassmass,massmassmass,13/Apr/14 1:12 AM,,13/Apr/14 1:13 AM,,,,,,0,0,,,,,,,,,"With option:
 NODE_INCLUDES = ""Node_Inc.h"";
 
 This include file will only be included by header file of SimpleNode, not Node. In this case, if ""VISITOR_DATA_TYPE"" were defined with a class, Node.h could not pass compiler. Unless manually add header file to Node.h",,,,,,,,0|i093uv:,,,,,53114,,,
javacc,JAVACC-276,Unnecessary OUTPUT_DIRECTORY in include path for *Parser.cc and *ParserTokenManager.cc for CPP target,Bug,Open,Major,Unresolved,Unassigned,massmassmass,massmassmass,12/Apr/14 5:32 PM,,12/Apr/14 10:17 PM,,6.0,,parser generator,,0,0,,,,,,,,,"Bug Desc:
 For cpp target, in *Parser.cc and *ParserTokenManager.cc, there are OUTPUT_DIRECTORY in include path which is unnecessary, and cause compile error after move OUTPUT_DIRECTORY to other path.
 
 Example:
 javacc-6.0/examples/JavaGrammars/cpp
 For JavaParser.cc
 #include ""gen/JavaParser.h""
 For JavaParserTokenManager.cc
 #include ""gen/JavaParserTokenManager.h""",,,,,,,,0|i08ydr:,,,,,52227,,,
javacc,JAVACC-275,Addition to take into concideration,Bug,Open,Major,Unresolved,Unassigned,chiana,chiana,09/Apr/14 5:43 AM,,09/Apr/14 5:43 AM,,6.0,,,,0,0,,,,,,,,,"Concider adding the option ""EXCEPTION_EXTENDS"" that makes ParseException extend given class instead of ""Exception"".",,,,,,,,0|i0egdr:,,,,,84303,,,
javacc,JAVACC-274,JJTree should allow setting NODE_CLASS locally,New Feature,Open,Minor,Unresolved,Unassigned,garfieldnate,garfieldnate,09/Apr/14 4:13 AM,,09/Apr/14 4:13 AM,,,,jjtree,,0,0,,,,,,,,,"I have a specific node class I want used for a certain production. This is roughly what I'm doing right now to make it work:
 void myProduction() :
 {
 jjtThis = new MyNode();
 Token t;
 }
 {
 //aggregate XYZ tokens into a MyNode object 
 (
 t = <XYZ>
 {
 //cast the current node to a MyNode object, since JJTree always declares it as SimpleNode or NODE_CLASS
 ((MyNode)jjtThis).add(t.image);
 }
 )*
 }
 
 I have to recast jjtThis everytime I want to call something in MyNode. I set jjtThis to the correct node type, but in the generated code this happens only after jjtThis is declared as a SimpleNode (or whatever NODE_CLASS is). The jjtThis variable is therefore initialized twice.
 
 It would be much simpler if I could declare NODE_CLASS: ""MyNode"" within this production and have jjtThis correctly declared and initialized.",,,,,,,,0|i0aki7:,,,,,61643,,,
javacc,JAVACC-273,Default Visitor Behavior is Different between Java and CPP target,Improvement,Open,Minor,Unresolved,Unassigned,massmassmass,massmassmass,08/Apr/14 10:01 PM,,08/Apr/14 10:01 PM,,6.0,,jjtree,,0,0,,,,,,,,CentOs,"In CPP, defaultVisit is pure virtual function:
 
 virtual void defaultVisit(const SimpleNode *node, void * data) = 0;
 
 In Java, defaultVisit will visit all child nodes:
 
 public Object defaultVisit(SimpleNode node, Object data){
 node.childrenAccept(this, data);
 return data;
 }
 
 I checked history of code, in revision 455, implementation has been commented on purpose in file CPPNodeFiles.java. Is there any purpose for it?",,,,,,,,0|i0cl5r:,,,,,73413,,,
javacc,JAVACC-272,Memory Leak in JJT*State nodes when reuse parser with STATIC option for CPP Target,Bug,Open,Minor,Unresolved,Unassigned,massmassmass,massmassmass,08/Apr/14 3:46 AM,,08/Apr/14 4:17 AM,,6.0,,parser generator,,0,0,,,,,,,,CentOS,"Tried to run google profile with parser and caught memory leak for JJT*State class.
 
 Leak only happen with STATIC = true option and reuse parser to parse multiple content.
 
 My generated code:
 class:
 class JJTExprParserState {
 private: std::vector<Node*> *nodes;
 private: std::vector<int> *marks;
 private: std::set<Node*> *open_nodes;
 }
 
 reset function, which will be called by ReInit:
 
 void JJTExprParserState::reset() {
 nodes->resize(0);
 marks->resize(0);
 sp = 0;
 mk = 0;
 }
 
 But content of nodes and open_nodes may need to be deleted as deconstructor do.
 
 Deconstructor
 
 JJTExprParserState::~JJTExprParserState() {
 for (size_t i = 0; i < nodes->size(); i++) {
 Node* node = nodes->at(i);
 open_nodes->erase(node);
 delete node;
 }
 for (std::set<Node*>::iterator it = open_nodes->begin();
 it != open_nodes->end(); it++) 
 delete (*it);
 
 delete open_nodes;
 delete nodes;
 delete marks;
 }",,,,,,,,0|i06oqv:,,,,,39002,,,
javacc,JAVACC-271,TRACK_TOKENS options is broken for CPP parser generation,Bug,Open,Major,Unresolved,Unassigned,massmassmass,massmassmass,07/Apr/14 9:40 PM,,07/Apr/14 10:43 PM,,,,parser generator,,0,0,,,,,,,,,"1. How to reproduce:
 a. Add ""TRACK_TOKENS = true"" option to javacc-6.0/examples/JavaGrammars/cpp/Java1.1.jjt
 b. Run make get compiler error like:
 i. gen/JavaParser.cc:2051: error: request for member \u2018jjtSetFirstToken\u2019 in \u2018jjtn000\u2019, which is of non-class type \u2018java::parser::SimpleNode*\u2019
 ii. gen/JavaParser.cc:2078: error: request for member \u2018jjtSetLastToken\u2019 in \u2018jjtn000\u2019, which is of non-class type \u2018java::parser::SimpleNode*\u2019
 
 2. Reason:
 In JavaParser.cc, generated code for parsing function will contain segment like:
 jj_consume_token(OR);
 ASTOr *jjtn001 = new ASTOr(JJTOR);
 bool jjtc001 = true;
 jjtree.openNodeScope(jjtn001);
 jjtn001.jjtSetFirstToken(getToken(1));
 
 Since jjtn001 is pointer, ""jjtn001.jjtSetFirstToken(getToken(1));"" is invalid",,,,,,,,0|i093wv:,,,,,53123,,,
javacc,JAVACC-270,Minor Memory Leak for CPP Target,Bug,Open,Minor,Unresolved,Unassigned,massmassmass,massmassmass,07/Apr/14 6:43 PM,,08/Apr/14 3:37 AM,,6.0,,parser generator,,0,0,,,,,,,,CentOS,"Options:
 OUTPUT_LANGUAGE = ""c++"";
 MULTI = true;
 NODE_DEFAULT_VOID=true;
 NAMESPACE = ""ExprParser"";
 VISITOR = true;
 /* Any variable used during parsing need to be defined in BaseNode*/
 NODE_CLASS = ""ASTBaseNode"";
 NODE_INCLUDES = ""ASTBaseNode.h"";
 OUTPUT_DIRECTORY = ""DerivedFiles"";
 
 Leak1: ReInit function in Parser.
 Code:
 void ExprParser::ReInit(TokenManager *tm){
 if (head) delete head;
 errorHandler = new ErrorHandler();
 errorHandlerCreated = true;
 hasError = false;
 token_source = tm;
 head = token = new Token();
 token->kind = 0;
 token->next = NULL;
 jj_lookingAhead = false;
 jj_rescan = false;
 jj_done = false;
 jj_scanpos = jj_lastpos = NULL;
 jj_gc = 0;
 jj_kind = -1;
 trace_indent = 0;
 trace_enabled = false;
 jj_ntk = -1;
 jjtree.reset();
 jj_gen = 0;
 for (int i = 0; i < 21; i++) jj_la1[i] = -1;
 }
 Leaking Member: errorHandler
 
 ////////////////////////////////////////////////////////////////
 Leak2: ReInit function in TokenManager
 Code:
 void ExprParserTokenManager::ReInit(JAVACC_CHARSTREAM *stream, int lexState, ExprParser *parserArg) {
 if (input_stream) delete input_stream;
 jjmatchedPos = jjnewStateCnt = 0;
 curLexState = lexState;
 input_stream = stream;
 ReInitRounds();
 debugStream = stdout; // init
 SwitchTo(lexState);
 parser = parserArg;
 errorHandler = new TokenManagerErrorHandler();
 errorHandlerCreated = true;
 }
 
 Leaking Member: errorHandler
 
 ///////////////////////////////////////////////////////////
 
 Suggestion:
 Generate a clear() function, and call it in both deconstructor and begin of reinit
 
 And
 Excellent tool, really appreciate!",,,,,,,,0|i05z8n:,,,,,34870,,,
javacc,JAVACC-269,JavaCC needs to accept return type of productionas valid c++ syntax,Improvement,Closed,Major,Invalid,Unassigned,francisandre,francisandre,05/Apr/14 2:33 PM,,06/Apr/14 6:27 AM,06/Apr/14 6:27 AM,6.0,not determined,general,,0,0,,,,,,,,,"Hi Screeni
 
 There is a need that JavaCC for C++ to accept a return type of a production be compatible with the c++ syntax -- at least for simple return type -- like
 
 Expression* 
 Expression&
 const Expression*
 const Expression&
 
 The idea would be to change the following JavaCC production as
 
 void ResultType(List tokens) :
 	{
 	 Token first = getToken(1);
 	 if (tokens == null)
 	 tokens = new ArrayList();
 	}
 {
 (
 ""void"" [ ""*"" ]
 |
 [ ""const"" ] Type() [ ""*"" | ""&"" ]
 )
 	{
 	 Token last = getToken(0);
 	 Token t = first;
 	 while (true) {
 	 tokens.add(t);
 	 if (t == last) break;
 	 t = t.next;
 	 }
 	}
 }
 
 
 For sure, the control for rejecting this syntax for Java is missing and should be added.
 
 What would be your thought on this improvment?",,,,,,,,0|i04o8f:,,,"c++, return, type",,27255,,,
javacc,JAVACC-268,jjtre for c++: improvment of the generated code,Improvement,Open,Major,Unresolved,Unassigned,francisandre,francisandre,30/Mar/14 3:42 PM,,31/Mar/14 4:19 PM,,6.0,,jjtree,,0,0,,,,,,,,,"Hi Screeni
 
 I am continuing to explore the c++ generation from a jjtree grammar and would suggest you the following enhancements with thoses options
 
 options {
 	BUILD_NODE_FILES=true;
 	MULTI=true;
 	NODE_CLASS=""BaseNode"";
 	TRACK_TOKENS=false;
 	VISITOR=true;
 	VISITOR_DATA_TYPE=""void*"";
 	VISITOR_RETURN_TYPE=""void*"";
 	STATIC = true;
 	OUTPUT_LANGUAGE=""c++"";
 OUTPUT_DIRECTORY=""../gen"";
 JJTREE_OUTPUT_DIRECTORY=""../ast"";
 	NAMESPACE=""SPL"";
 }
 
 
 
 1/ SimpleNode: SimpleNode should be generated in its own header and code file, namely SimpleNode.h and SimpleNode.cc
 
 2/ ParserTree: The ParserTree.h header should include the <NODE_CLASS>.h include since all ASTNode will inherit from the <NODE_CLASS> type.
 
 3/ParserDefaultVisitor: The ParserDefaultVisitor should also be generated in its own header anc code class so that it could be removed if not used.
 
 4/ unsigned int versus int: Mostly all mthods that manage children are using an int as position or length while the std::vector is using size_type. With a strictly compliant compilation, one gets fatal error because the generated code compares int to unsigned int. Using unsigned int or better size_type or size_t would be a better choice.
 
 Rgds",,,,,,,,0|i06vlb:,,,,,40111,,,
javacc,JAVACC-267,jjtree for c++: genrated AST nodes should define the virtual ~ASTXXX destructor,Bug,Open,Major,Unresolved,Unassigned,francisandre,francisandre,28/Mar/14 9:49 AM,,28/Mar/14 2:49 PM,,6.0,,jjtree,,0,0,,,,,,,,"$ $JAVA_HOME/bin/java.exe -version
 java version ""1.7.0_51""
 Java(TM) SE Runtime Environment (build 1.7.0_51-b13)
 Java HotSpot(TM) 64-Bit Server VM (build 24.51-b03, mixed mode)
 
 $ uname -a
 CYGWIN_NT-6.1 idefix 1.7.28(0.271/5/3) 2014-02-09 21:06 x86_64 Cygwin","Hi
 
 jjtree for c++ generates all non user's defined AST nodes with a declaration of a virtual destructor while its definition is not generated which leads to a linker error as
 
 class ASTMult : public SimpleNode {
 public: ASTMult(int id);
 public: ASTMult(Parser *p, int id);
 
 public: virtual ~ASTMult();
 };
 
 ./cpp/ParserTree.o:ParserTree.cc:(.rdata$.refptr._ZTVN3EG27ASTMultE[.refptr._ZTVN3EG27ASTMultE]+0x0): undefined reference to `vtable for EG2::ASTMult'",,,,,,,,0|i06xsv:,,,,,40469,,,
javacc,JAVACC-266,jjtree for c++: ParserTree.h is missing the definition of NULL by #define NULL 0,Bug,Open,Major,Unresolved,Unassigned,francisandre,francisandre,28/Mar/14 9:24 AM,,28/Mar/14 9:24 AM,,6.0,,,,0,0,,,,,,,,"$ uname -a
 CYGWIN_NT-6.1 idefix 1.7.28(0.271/5/3) 2014-02-09 21:06 x86_64 Cygwin
 
 $ $JAVA_HOME/bin/java.exe -version
 java version ""1.7.0_51""
 Java(TM) SE Runtime Environment (build 1.7.0_51-b13)
 Java HotSpot(TM) 64-Bit Server VM (build 24.51-b03, mixed mode)","Hi
 
 In the EG2 jjtree sample, the jjtree c++ generator produces this code
 
 /* Generated By:JJTree: Do not edit this line. ParserTree.cc Version 6.0 */
 /* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
 #include ""ParserTree.h""
 namespace EG2 {
 
 SimpleNode::SimpleNode(int i)
 {
 id = i;
 parser = NULL;
 value = NULL;
 }
 while NULL is never defined in ParserTree.h",,,,,,,,0|i01hqf:,,,,,8706,,,
javacc,JAVACC-265,language=c++: jjt generator generates user's defined AST in ParserTree.h while it should not.,Bug,Open,Major,Unresolved,Unassigned,francisandre,francisandre,28/Mar/14 9:20 AM,,28/Mar/14 9:20 AM,,6.0,,jjtree,,0,0,,,,,,,,"$ uname -a
 CYGWIN_NT-6.1 idefix 1.7.28(0.271/5/3) 2014-02-09 21:06 x86_64 Cygwin
 
 $ $JAVA_HOME/bin/java.exe -version
 java version ""1.7.0_51""
 Java(TM) SE Runtime Environment (build 1.7.0_51-b13)
 Java HotSpot(TM) 64-Bit Server VM (build 24.51-b03, mixed mode)","Hi
 
 In the EG2 sample targeted for a c++ generation, the jjtree generator generates a ASTMyID class in the ParserTree.h while this user's define ASTMyID class was exixting benfore the generation.
 
 
 options {
 MULTI=true;
 KEEP_LINE_COLUMN = false;
 OUTPUT_LANGUAGE=""C++"";
 NAMESPACE=""EG2""; 
 }
 
 PARSER_BEGIN(Parser)
 PARSER_END(Parser)
 
 /** An Identifier. */
 void MyID() :
 {
 Token t;
 }
 {
 t=<IDENTIFIER>
 {
 jjtThis.setName(t.image);
 }
 }
 
 
 Here a snippet of the ParserTree.h
 
 
 class ASTStart : public SimpleNode {
 public: ASTStart(int id);
 public: ASTStart(Parser *p, int id);
 
 public: virtual ~ASTStart();
 };
 class ASTMyID : public SimpleNode {
 public: ASTMyID(int id);
 public: ASTMyID(Parser *p, int id);
 
 public: virtual ~ASTMyID();
 };
 class ASTInteger : public SimpleNode {
 public: ASTInteger(int id);
 public: ASTInteger(Parser *p, int id);
 
 public: virtual ~ASTInteger();
 };",,,,,,,,0|i0aaav:,,,,,59990,,,
javacc,JAVACC-264,language=c++: incoherent generated return type from a production,Bug,Open,Major,Unresolved,Unassigned,francisandre,francisandre,28/Mar/14 9:12 AM,,28/Mar/14 9:12 AM,,6.0,,jjtree,,0,0,,,,,,,,"$ uname -a
 CYGWIN_NT-6.1 idefix 1.7.28(0.271/5/3) 2014-02-09 21:06 x86_64 Cygwin
 
 $ $JAVA_HOME/bin/java.exe -version
 java version ""1.7.0_51""
 Java(TM) SE Runtime Environment (build 1.7.0_51-b13)
 Java HotSpot(TM) 64-Bit Server VM (build 24.51-b03, mixed mode)","Hi
 
 Running JavaCC 6.0 on the Eg2 sample for a c++ generation produces an incoherent c++ code. IMHO, the return type from the Start() production should be ASTStart* instead of ASTStart.
 
 Here the snippets
 
 options {
 MULTI=true;
 KEEP_LINE_COLUMN = false;
 OUTPUT_LANGUAGE=""C++"";
 NAMESPACE=""EG2""; 
 }
 
 /** Main production. */
 ASTStart Start() : {}
 {
 Expression() "";""
 { return jjtThis; }
 }
 
 ASTStart Parser::Start() {/*@bgen(jjtree) Start */
 ASTStart *jjtn000 = new ASTStart(JJTSTART);
 bool jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 try {
 Expression();
 jj_consume_token(14);
 jjtree.closeNodeScope(jjtn000, true);
 jjtc000 = false;
 return jjtn000;
 } catch ( ...) {
 if (jjtc000) {
 jjtree.clearNodeScope(jjtn000);
 jjtc000 = false;
 } else {
 jjtree.popNode();
 }
 }
 if (jjtc000) {
 jjtree.closeNodeScope(jjtn000, true);
 }
 assert(false);
 }",,,,,,,,0|i0ccyv:,,,,,72086,,,
javacc,JAVACC-263,org.javacc.parser.Main.reInitAll is missing call to org.javacc.parser.LexGen.reInit (),Bug,Resolved,Major,Fixed,ainsleyc,phax,phax,14/Mar/14 11:24 AM,,15/May/14 6:34 PM,05/May/14 4:53 AM,6.0,6.0,,,0,0,,,,,,,,,"Version: 6.0.1
 Class: org.javacc.parser.Main
 Method: public static void reInitAll
 
 A call to 
 org.javacc.parser.LexGen.reInit ();
 
 is missing.
 This is relevant when using JavaCC in a Maven plugin with multiple exexcutions, as well as for the unit tests!
 
 I just added it to the end of reInitAll and everything works fine!",,,,,,,,0|i0bw2v:,,,"java, maven",,69350,,,
javacc,JAVACC-262,Var not defined in generated parser,Bug,Open,Major,Unresolved,Unassigned,brice.andre,brice.andre,20/Feb/14 7:39 AM,,21/Feb/14 7:50 AM,,6.0,,,,0,1,,,,,,,,Windows,"Dear all,
 
 When I generate the parser for the attached syntax, the generated parser (MathFormulaParserTokenManager.java) contains references to non-defined variables (i1 and l1) in the function ""jjMoveNfa_0"" at the following line : 
 
 switch(jjstateSet[--i])
 {
 case 1:
 if ((jjbitVec0[i2] & l2) != 0L)
 { jjAddStates(4, 5); }
 break;
 default : if (i1 == 0 || l1 == 0 || i2 == 0 || l2 == 0) break; else break;
 }
 
 Regards,
 Brice",,,,,,,,0|i04qwf:,,,,,27687,,,
javacc,JAVACC-261,"Helper #tokens lead to TokenManager.java with ""code too large""",Bug,Open,Major,Unresolved,Unassigned,beesley,beesley,21/Nov/13 9:36 PM,,21/Nov/13 9:36 PM,,5.0,,,,0,0,,,,,,,,N/A,"In a project (www.kleene-lang.org) for a language that uses sigils, e.g. the dollar sign in $foo, the extensive use of helper/auxiliary tokens (such as #sigil or #dollar) to designate the sigils in token definitions in the .jjt file led to an oversized TokenManager.java file and the ""code too large"" error message. These tokens defined with an initial # ""exist solely for the purpose of defining other tokens""--see the #EXPONENT example in https://javacc.java.net/doc/javaccgrm.html. The Kleene.jjt file was reviewed by Sreeni Viswanadha, and he concluded: ""You are right. The #tokens are the issue. Just expand them in place [where #token was previously used] and make them simple string literals and it should work.""",,,,,,,,0|i05hrb:,,,"""code, ""helper, TokenManager, large"", lexer, tokenizer, tokens"", too",,32038,,,
javacc,JAVACC-260,can't link multiple javacc parsers into one c++ binary,Bug,Open,Major,Unresolved,Unassigned,jshute,jshute,18/Sep/13 6:03 PM,,18/Sep/13 6:03 PM,,6.0,,parser generator,,0,0,,,,,,,,,"If you try to link multiple c++ parsers into the same binary, it fails with a linker error 
 
 <dir1>/TokenMgrError.pic.o: multiple definition of 'addUnicodeEscapes(std::string)'
 <dir2>/TokenMgrError.pic.o: previous definition here
 collect2: error: ld returned 1 exit status
 
 addUnicodeEscapes is in the generated file JavaCC.h, without a namespace, so it causes conflicts.",,,,,,,,0|i06g6n:,,,,,37615,,,
javacc,JAVACC-259,C++ version of JJTree doesn't close node properly,Bug,Open,Major,Unresolved,Unassigned,sreeni,sreeni,06/Sep/13 5:22 AM,,01/Dec/13 6:45 AM,,,,,,0,0,,,,,,,,,"Since we don't use exceptions in the C++ version, we get wrong trees sometimes so if someone tries to build trees using javacc, it can cause problems.",,,,,,,,0|i08hiv:,,,,,49496,,,
javacc,JAVACC-258,The jjtree examples don't work in JavaCC 6,Bug,Open,Major,Unresolved,Unassigned,briangordon-serendipity,briangordon-serendipity,29/Jul/13 8:13 PM,,15/Aug/13 5:51 AM,,6.0,,,,0,1,,,,,,,,,"Some of my code that works in JavaCC 5 no longer works in JavaCC 6. I find that the generated TokenManager contains a syntax error; namely, a reference to the variables ""i1"" and ""l1"" which are not defined.
 
 You can reproduce this problem with the built-in jjtree examples. Try building the eg4.jjt example and you'll see the syntax error.",,,,,,,,0|i00vz3:,,,,,5181,,,
javacc,JAVACC-257,readability of generated code,Improvement,Open,Major,Unresolved,Unassigned,er,er,30/Nov/12 12:28 PM,,30/Nov/12 12:28 PM,,,,,,0,0,,10800,10800,,0%,,,all,"I think, the code generated by javacc can be clearer and smaller. 
 Clarity seems important for bugfixing because it is a valuable technique 
 to look into the generated java-files (and to understand them). 
 
 I have a bunch of simplifications. Here is one of it: 
 
 Considered the field jj_nt which is set in method jj_ntk() only. 
 
 This method can be reimplemented as follows showing the intention behind. 
 
 private int jj_ntk() {
 if ((jj_nt=token.next) == null)
 return (jj_ntk = (token.next=token_source.getNextToken()).kind);
 else
 return (jj_ntk = jj_nt.kind);
 }
 
 private int jj_ntkB() {
 jj_nt=token.next;
 if (token.next == null) 
 	 token.next = token_source.getNextToken();
 jj_ntk = token.next.kind;
 return jj_ntk;
 }
 
 So, after having invoked jj_ntk(), jj_nt equals token.next 
 and is in this sense the next token. 
 This remains true until invoking 
 - jj_consume_token(int kind) successfully, because this reads token further 
 whereas this remains true if the invocation results in an exception. 
 In the first case, jj_nt equals token after return. 
 - a method ReInit(...) because this reinitializes token 
 Even if invoking jj_ntk() once more does not change the situation. 
 So leaving reinitialization aside, 
 after having invoked jj_consume_token(int kind) successfully once only, 
 jj_nt equals token as long as invoking jj_ntk() 
 as often as you like. 
 Then jj_nt equals token.next. 
 
 
 Note that the way we rewrote jj_ntk(), it is clear, 
 that jj_nt is not needed in the method. 
 In fact, it is read nowhere in the parser and can thus be eliminated. 
 
 So the implementation can further be simplified. 
 
 private int jj_ntkC() {
 if (token.next == null) 
 	 token.next = token_source.getNextToken();
 jj_ntk = token.next.kind;
 return jj_ntk;
 }
 
 Note that jj_ntk is the name of a method but also of a field. 
 The field int jj_ntk contains a code for the kind of the next token 
 explaining the name. 
 The field is set to -1 signifying that the number is not set 
 - in constructors and reinitialization methods ReInit(...). 
 - in methods jj_consume_token(int kind) and getNextToken() 
 signifying that the next token has been read 
 and so jj_nt and jj_ntk are outdated. 
 Finally, jj_ntk is set to token.next.kind in method jj_ntk(). 
 These are all ways, the parser sets jj_ntk. 
 
 Note that, after invoking jjNtk(), 
 jj_ntk is the kind of jj_nt if this is not null. 
 
 
 The method jj_ntk() is invoked only in a very special context: 
 (jj_ntk==-1)?jj_ntk():jj_ntk 
 which occurs in code for methods related to non-terminals. 
 
 So, instead of invoking this sequence, one can equivalently invoke 
 
 private int jj_ntkD() {
 if (jj_ntk==-1) {
 //	 jj_nt=token.next;
 	 if (token.next == null) 
 	 token.next = token_source.getNextToken();
 	 jj_ntk = token.next.kind;
 }
 return jj_ntk;
 }
 
 SINCE THIS INVOCATION IS VERY FREQUENT, IT MAKES THE CODE SMALLER AND CLEARER.",,0%,0%,,10800,10800,,0|i02vpb:,,,,,16801,,,
javacc,JAVACC-256,nested lookahead,Bug,Closed,Blocker,Works as designed,sreeni,er,er,30/Nov/12 12:15 PM,,30/Nov/12 7:27 PM,30/Nov/12 4:35 PM,,,parser generator,,0,0,,172800,172800,,0%,,,all,"problem occurs when within a lookahead occurs a nonterminal with another lookahead. 
 For the first lookahead the second one is not taken into account, 
 and as a result, the first lookahead always rejects the alternative which is false. 
 
 I provide an example grammar Parser.jj illustrating the problem. 
 In addition I added the file generated from the grammar, 
 but endowed with some comments giving a hint of what happens. 
 Also I changed the ordering of the methods to get it more readable. 
 Finally, i added a file test.txt to be parsed with a single line: 
 a:c=x
 Try also 
 a:b:c=x 
 
 Both should parse without an error. 
 Whereas the second one does, the first one does not. 
 
 Let me say that this is a showstopper for me because i have a quite complicated grammer 
 not feasable without excessive lookahead.",,0%,0%,,172800,172800,,0|i02c0n:,,,,,13612,,,
javacc,JAVACC-255,Add to ability to have the token's offset,Improvement,Open,Minor,Unresolved,Unassigned,marc_mazas,marc_mazas,19/Oct/12 3:37 PM,,19/Oct/12 8:29 PM,,5.0,,parser generator,,0,0,,,,,,,,All,"Using JavaCC in environments like Eclipse which are more based for tokens on offsets than lines / columns is difficult ; it is possible to get it with the current JavaCC version but very uggly :
 one must :
 - create a NewToken.java with an int member (offset)
 - set the 'TOKEN_EXTENDS=""NewToken"";' option
 - generate the ParserTokenManager and the Parser with 'USER_TOKEN_MANAGER=false;'
 - create a NewTokenManager.java extending the ParserTokenManager implementing the TokenManager, and overriding the jjFillToken() and ReInit(...) methods
 - alter the grammar to set the 'USER_TOKEN_MANAGER = true;' option, insert code copied from the Parser (member, constructors, ReInit methods), and adapt it to the new classes (changes and casts)
 
 However it looks like it would be quite straightforward to incoporate it in the generated classes (something like adding a new member in Token and a line 't.offset = input_stream.bufpos;' in jjFillToken())",,,,,,,,0|i05dlj:,,,,,31364,,,
javacc,JAVACC-254,Error in trunk pom.xml,Bug,Open,Major,Unresolved,Unassigned,phax,phax,04/Aug/12 12:54 PM,,04/Aug/12 12:54 PM,,5.0,,general,,0,0,,,,,,,,,"Due to a copy paste bug, the pom.xml contains
 <modelVersion>5.0.0</modelVersion>
 whereas a correct Maven pom.xml should contain
 <modelVersion>4.0.0</modelVersion>",,,,,,,,0|i04ssf:,,,,,27993,,,
javacc,JAVACC-253,PLSQL AST,Improvement,Open,Minor,Unresolved,Unassigned,sturton,sturton,23/Jul/12 9:30 PM,,23/Jul/12 10:00 PM,,,,parser generator,,0,0,,,,,,,,,"PLSQL AST extracted from PLDoc 1.3.2 - supports 11gR2 PL/SQL and some SQL*Plus.
 
 This .jjt files was used to generate the PLSQL Language for PMD/CPD.
 
 
 Generating java from this .jjt/.jj takes a significant amount of time - over an hour!!!",,,,,,,,0|i04ten:,,,"jjtree, plsql",,28093,,,
javacc,JAVACC-252,"Block() should be declared instead of ""{""(BlockStatement())*""}"" in bnf_production in the JavaCC grammar",Bug,Open,Minor,Unresolved,Unassigned,marc_mazas,marc_mazas,10/Jul/12 10:14 AM,,10/Jul/12 10:14 AM,,current,,,,0,0,,,,,,,,All,"For the bnf_production syntax, the html doc says there is a java_block, but the grammar expands this java block (thus saying that the {} are javacc punctuation and not java punctuation) : this is slightly incoherent, and has small side effects on the way comments before and after the braces (as special-tokens) are handled and outputted ; in order to be consistent with the html doc and other javacc specific productions (regexpr_spec & expansion_unit), a Block() should be used (and BlockStatement() should be used only in the java part of the grammar).
 
 void bnf_production() #bnf_production :
 {}
 {
 access_modifier() ResultType() < IDENTIFIER > #ident_bnf_decl FormalParameters()
 [
 ""throws"" Name()
 (
 "","" Name()
 )*
 ]
 [ node_descriptor() #node_desc_bnf_decl ] 
 "":""
 Block()
 ""{""
 (
 expansion_choices()
 )
 ""}""
 }
 
 instead of 
 
 void bnf_production() #bnf_production :
 {}
 {
 access_modifier() ResultType() < IDENTIFIER > #ident_bnf_decl FormalParameters()
 [
 ""throws"" Name()
 (
 "","" Name()
 )*
 ]
 [ node_descriptor() #node_desc_bnf_decl ] 
 "":""
 // here we could a) remove the extra () b) use a Block()
 ""{""
 (
 (
 BlockStatement()
 )*
 )
 ""}"" 
 ""{""
 (
 expansion_choices()
 )
 ""}""
 }",,,,,,,,0|i0bn8n:,,,,,67918,,,
javacc,JAVACC-251,The JavaCC grammar does not handle the Java full ExplicitConstructorInvocation syntax,Bug,Open,Minor,Unresolved,Unassigned,marc_mazas,marc_mazas,05/Jul/12 4:44 PM,,13/Nov/14 1:23 PM,,5.0,,,,0,1,,,,,,,,All,"The JavaCC grammar does not allow all the forms of a ExplicitConstructorInvocation when the optional NonWildTypeArguments are present.
 
 From the JLS3, §8.8.7.1 
 ExplicitConstructorInvocation:
 	NonWildTypeArgumentsopt this ( ArgumentListopt ) ;
 	NonWildTypeArgumentsopt super ( ArgumentListopt ) ;
 	Primary. NonWildTypeArgumentsopt super ( ArgumentListopt ) ; 
 
 NonWildTypeArguments:
 	< ReferenceTypeList >
 
 ReferenceTypeList: 
 	ReferenceType
 	ReferenceTypeList , ReferenceType
 
 But the JavaCC grammar does not allow the NonWildTypeArgument clause :
 void ExplicitConstructorInvocation() :
 {}
 {
 LOOKAHEAD(""this"" Arguments() "";"")
 ""this"" Arguments() "";""
 |
 [
 LOOKAHEAD(2)
 PrimaryExpression() "".""
 ]
 ""super"" Arguments() "";""
 }
 
 
 
 Following is an example grammar showing the parsing error
 /*
 * Simple grammar showing ExplicitConstructorInvocation problem.
 * An ExplicitConstructorInvocation with a NonWildTypeArgument is not parsed.
 */
 options
 {}
 
 PARSER_BEGIN(ExplicitConstructorInvocationProblem1)
 package p1.pb2;
 @ SuppressWarnings(""all"") class ExplicitConstructorInvocationProblem1 < D >
 {
 ExplicitConstructorInvocationProblem1()
 {
 this ((D) null);
 }
 < C > ExplicitConstructorInvocationProblem1(D u)
 {
 super ();
 }
 
 class MyExtendedClass < X > extends ExplicitConstructorInvocationProblem1 < D >
 {
 MyExtendedClass()
 {
 this (null);
 }
 < Y extends X > MyExtendedClass(ExplicitConstructorInvocationProblem1 < ? > c)
 {
 super ();
 }
 < T extends X, U > MyExtendedClass(T t, D d)
 {
 /*! explicit constructor invocation with non wild type argument */
 // This does not parse yet : says :
 // Error parsing input: org.javacc.jjtree.ParseException: Encountered "" ""<"" ""< """" at line 36, column 7.
 <U> super(d);
 t = (T) new MyExtendedClass < Class < T >> (null);
 }
 }
 }
 
 PARSER_END(ExplicitConstructorInvocationProblem1)
 
 void Start() :
 {}
 {
 "";""
 {
 return;
 }
 }",,,,,,,,0|i06353:,,,,,35502,,,
javacc,JAVACC-250,Annotation type declarations lead to a parsing error,Bug,Open,Minor,Unresolved,Unassigned,marc_mazas,marc_mazas,27/Jun/12 12:57 PM,,13/Nov/14 12:51 PM,,5.0,,,,1,2,,,,,,,,,"It looks that despite the JavaCC 5.0 grammar handles it, it does not parse an annotation type declaration.
 
 The following grammar ...
 
 /*
 * Simple grammar showing AnnotationTypeDeclaration problem.
 * An AnnotationTypeDeclaration in TypeDeclaration in CompilationUnit is not parsed.
 */
 options
 {}
 
 PARSER_BEGIN(AnnotationProblem1)
 package p1.pb1;
 
 public class AnnotationProblem1
 {
 @interface MyAnnotation
 {}
 }
 
 PARSER_END(AnnotationProblem1)
 
 void Start() :
 {}
 {
 "";""
 {
 return;
 }
 }
 
 ... leads to the following error :
 
 >java -classpath D:/Devs/Parsers-workspace/sf.eclipse.javacc/javacc.jar jjtree AnnotationProblem1.jjt 
 Java Compiler Compiler Version 5.0 (Tree Builder)
 (type ""jjtree"" with no arguments for help)
 Reading from file AnnotationProblem1.jjt . . .
 Error parsing input: org.javacc.jjtree.ParseException: Encountered "" ""@"" ""@ "" ""interface"" ""interface """" at line 13, column 3.
 Was expecting one of:
 ""LOOKAHEAD"" ...
 ""IGNORE_CASE"" ...
 ""PARSER_BEGIN"" ...
 ""PARSER_END"" ...
 ""JAVACODE"" ...
 ""TOKEN"" ...
 ""SPECIAL_TOKEN"" ...
 ""MORE"" ...
 ""SKIP"" ...
 ""TOKEN_MGR_DECLS"" ...
 ""EOF"" ...
 ""boolean"" ...
 ""byte"" ...
 ""char"" ...
 ""class"" ...
 ""double"" ...
 ""float"" ...
 ""int"" ...
 ""interface"" ...
 ""long"" ...
 ""short"" ...
 ""void"" ...
 ""<"" ...
 ""enum"" ...
 <IDENTIFIER> ...
 ""public"" ...
 ""static"" ...
 ""protected"" ...
 ""private"" ...
 ""final"" ...
 ""abstract"" ...
 ""synchronized"" ...
 ""native"" ...
 ""transient"" ...
 ""volatile"" ...
 ""strictfp"" ...
 ""@"" <IDENTIFIER> ...
 ""@"" ""LOOKAHEAD"" ...
 ""@"" ""IGNORE_CASE"" ...
 ""@"" ""PARSER_BEGIN"" ...
 ""@"" ""PARSER_END"" ...
 ""@"" ""JAVACODE"" ...
 ""@"" ""TOKEN"" ...
 ""@"" ""SPECIAL_TOKEN"" ...
 ""@"" ""MORE"" ...
 ""@"" ""SKIP"" ...
 ""@"" ""TOKEN_MGR_DECLS"" ...
 ""@"" ""EOF"" ...
 ""{"" ...",,,,,,,,0|i0610v:,,,,,35159,,,
javacc,JAVACC-249,Javacode productions cannot be generated as final,Bug,Open,Minor,Unresolved,Unassigned,marc_mazas,marc_mazas,27/Jun/12 8:05 AM,,27/Jun/12 8:05 AM,,5.0,,,,0,0,,,,,,,,All,"bnf_productions are generated as final methods.
 As per the grammar, ""The JAVACODE production is a way to write Java code for some productions instead of the usual EBNF expansion"", but javacode_productions are not generated as final methods.
 If it is a design choice (to allow the user to override the generated method, ...), JavaCC should allow the user to tell he wants the generated method to be final (by allowing ""final"" as the java_access_modifier for a javacode_production).
 If it is not a design choice, the generator should add the final modifier as for bnf_produtions.",,,,,,,,0|i05qrb:,,,,,33496,,,
javacc,JAVACC-248,Incomplete handling of ResultType() in bnf_production,Bug,Open,Minor,Unresolved,Unassigned,marc_mazas,marc_mazas,20/Jun/12 9:24 AM,,20/Jun/12 9:24 AM,,5,,,,0,0,,,,,,,,Windows (but presumably all),"In a bnf_production, the ResultType(), when narrowing down to ClassOrInterfaceType(), is usually a JavaIdentifier() (like ASTExpression), but is allowed by the grammar to also be qualified (foo.ASTExpression) or genericized (ASTExpression<String, Integer>, foo.bar.ASTExpression<String, Integer>).
 JavaCC / JJTree does not generate the corresponding class in the proper package nor with the type parameter, and does not generate the parser class as public and with the appropriate import and method declaration.
 
 Example with the eg6 example : in eg6.jjt, change
 ASTExpression Expression():
 in
 bar.ASTExpression< String > Expression():
 
 File ASTExpression.java should be generated under foo.eg6.bar, not foo.eg6, and should start with
 package foo.eg6.bar;
 
 import foo.eg6.xxxNode;
 import foo.eg6.eg6;
 
 public
 class ASTExpression< String > extends xxxNode {
 
 
 In eg6.java:
 the following import should be generated:
 import foo.eg6.bar.ASTExpression;
 
 the class should be declared public
 
 and the following method declaration should be changed from
 static final public ASTExpression Expression() throws ParseException {
 to
 static final public ASTExpression< String > Expression() throws ParseException {",,,,,,,,0|i0ahif:,,,,,61158,,,
javacc,JAVACC-247,Peeknode returns last created node in the last action in C++ compared to java which gives the enclosing node.,Bug,Open,Major,Unresolved,sreeni,sreeni,sreeni,08/May/12 7:09 PM,,08/May/12 7:09 PM,,6.0,,jjtree,,0,0,,,,,,,,C++,"peeknode returns different nodes for the same grammar in java and c++
 
 foo() #Foo {
 ...
 
 ([ <TOKEN> ])#MyNode()
 { Node *tmp = jjtree.peekNode(); } 
 
 The above, peeknode is giving Foo in the java version (correctly) whereas in C++, it's giving MyNode.",,,,,,,,0|i09tun:,,,,,57325,,,
javacc,JAVACC-246,C++ redefining JAVACC_CHAR_TYPE prevents token manager from compiling,Bug,Resolved,Major,Fixed,sreeni,jeremy_smith,jeremy_smith,13/Apr/12 8:17 PM,,17/Apr/12 8:15 PM,16/Apr/12 6:48 PM,not determined,,scanner generator,,0,0,,,,,,,,"Windows XP, with MS Visual C++","Using JavaCC 1.6, revision 470 to generate C++ code.
 
 In the JavaCC.h header file the character type can be
 controlled via JAVACC_CHAR_TYPE:
 
 #ifndef JAVACC_CHAR_TYPE
 #define JAVACC_CHAR_TYPE char
 #endif
 
 #ifndef JAVACC_STRING_TYPE
 #define JAVACC_STRING_TYPE std::basic_string<JAVACC_CHAR_TYPE>
 #endif
 
 
 I want my token manager to interoperate with some code that is already
 using wchar_t characters, so I defined JAVACC_CHAR_TYPE as wchar_t and
 recompiled the generated token manager, but the initializers will only
 work with char.",,,,,,,,0|i04tev:,,,tokenmanager,,28094,,,
javacc,JAVACC-245,"Lookahead Example 3 - incorrect generated code, compilation error",Bug,Open,Major,Unresolved,Unassigned,szczyp,szczyp,12/Apr/11 1:27 PM,,12/Apr/11 1:27 PM,,5.0,,,,0,0,,,,,,,,"Ubuntu Linux 10.04, 64bit
 Oracle JDK 1.6u24 64bit","Hi. I have been doing the examples, and it seems that Example3 in
 Lookeahead doesn't work correctly. The code that I get generated is (excerpt):
 
 static final public void basic_expr() throws ParseException {
 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
 case ID:
 jj_consume_token(ID);
 jj_consume_token(5);
 expr();
 jj_consume_token(6);
 break;
 case 5:
 jj_consume_token(5);
 expr();
 jj_consume_token(6);
 break;
 case 7:
 jj_consume_token(7);
 jj_consume_token(ID);
 break;
 jj_consume_token(ID); // line 26
 jj_consume_token(8);
 jj_consume_token(ID);
 break;
 default:
 jj_la1[0] = jj_gen;
 jj_consume_token(-1);
 throw new ParseException();
 }
 }
 
 case 7 has two breaks, with the last 3 jj_consume_token calls not being
 reachable, and the compiler moans with the following:
 
 Example.java:26: unreachable statement
 jj_consume_token(ID);
 ^
 1 error
 
 I am not sure, but this seems to be a problem in JavaCC, not the
 example, as it's the code that gets generated is incorrect, not the
 grammar.
 
 I am compiling on the command line with javac.",,,,,,,,0|i05j0n:,,,,,32242,,,
javacc,JAVACC-244,Regression - encountered/expected token list is empty,Bug,Open,Major,Unresolved,sreeni,sreeni,sreeni,07/Feb/11 9:02 AM,,05/Nov/13 9:01 AM,,5.0,,parser generator,,1,3,,,,,,,,,"When I use javacc 5.0 for one of my grammars, when there is a syntax error in my input test string, my parser is not giving correct error message. It says encountered """" and expected list is empty too. This works fine with 4.0 though.",,,,,,,,0|i057gv:,,,,,30371,,,
javacc,JAVACC-243,ClassOrInterfaceType has no children,Bug,Open,Critical,Unresolved,sreeni,lme,lme,05/Aug/10 12:26 PM,,05/Aug/10 12:26 PM,,5.0,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Hello,
 
 For the following code: 
 
 public class A {
 	public void m(){
 		C o=new C(){
 			void n(){}
 			
 		};
 	}
 }
 I use javacc on grammar java1.5.jjt to generate the parser as well as the auto
 generated AST (in the options I have: MULTI=true). There is no node in the tree
 associated with method n().
 
 Actually the instance o is VariableDeclarator but as you traverse all its
 children, (and children of its children) you will get to the
 ClassOrInterfaceType node which has no child!!! that is why we cannot get the
 deceleration of this inner class and consequently we cannot get method n(). Is
 there any reason for this? This means that the tree is not complete?!!
 
 Thanks for you help,
 LME",,,,,,,,0|i0f153:,,,,,87666,,,243
javacc,JAVACC-242,setName has not generated by jjtree in version 5,Bug,Open,Major,Unresolved,sreeni,okyl,okyl,18/Jul/10 11:52 AM,,18/Jul/10 11:52 AM,,5.0,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: Windows XP
 Platform: PC","setName has not generated by jjtree in version 5
 
 C:\Java\javacc-5.0\examples\JJTreeExamples>javac eg2.java
 eg2.java:200: cannot find symbol
 symbol : method setName(java.lang.String)
 location: class ASTMyID
 jjtn000.setName(t.image);
 ^
 1 error",,,,,,,,0|i063cf:,,,,,35535,,,242
javacc,JAVACC-241,public getter / setter,Bug,Open,Major,Unresolved,sreeni,marc_mazas,marc_mazas,24/Jun/10 3:31 AM,,24/Jun/10 3:31 AM,,5.0,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","In the generated SimpleCharStream the tabSize is protected, and the getter /
 setter are also protected, so they are useless ; they should be public
 
 protected int tabSize = 8;
 
 protected void setTabSize(int i) { tabSize = i; }
 protected int getTabSize(int i) { return tabSize; }",,,,,,,,0|i09fkv:,,,,,55013,,,241
javacc,JAVACC-240,Odd MethodDeclarator production,Bug,Open,Blocker,Unresolved,sreeni,bchadwick,bchadwick,27/May/10 8:57 AM,,27/May/10 8:57 AM,,5.0,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","The production for MethodDeclarator in JavaCC.jj has weird square brackets:
 ( ""["" ""]"" )*
 
 after the formal parameters.
 
 This means that within PARSER_BEGIN/END, a method like:
 public void foo()[][][]{}
 
 Parses/generates fine, but obviously results in a compiler error. I noticed
 this in an older version of the source (4.0), and confirmed it is still in the
 5.0 source (line 1749).
 
 It doesn't affect correct files... but unless I'm missing something, these can
 simply be removed. If they already have, I apologize.",,,,,,,,0|i0399z:,,,,,19000,,,240
javacc,JAVACC-239,Allow use of word boundary match,Improvement,Open,Major,Unresolved,sreeni,tcopeland,tcopeland,06/Apr/10 6:20 AM,,06/Apr/10 6:20 AM,,5.0,milestone 1,scanner generator,,1,0,,,,,,,,"Operating System: All
 Platform: Macintosh","e.g.,
 
 http://java.sun.com/docs/books/tutorial/essential/regex/bounds.html",,,,,,,,0|i084cn:,,,,,47362,,,239
javacc,JAVACC-238,NPE on choiceconflict,Bug,Open,Major,Unresolved,sreeni,erwindon,erwindon,28/Mar/10 2:09 AM,,28/Mar/10 2:09 AM,,5.0,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: Windows XP
 Platform: PC","The following parser generates a NullPointerException (NPE) in javacc:
 ===
 options
 {
 USER_TOKEN_MANAGER = true;
 }
 
 PARSER_BEGIN(JavaCCParser)
 public class JavaCCParser {}
 PARSER_END(JavaCCParser)
 
 void rule() :
 {
 }
 {
 < TOKEN1 > < TOKEN2 >
 |
 < TOKEN1 > < TOKEN3 >
 }
 ===
 
 
 The following output is produced:
 ===
 Java Compiler Compiler Version 5.0 (Parser Generator)
 (type ""javacc"" with no arguments for help)
 Reading from file JavaCCParser.jj . . .
 Warning: Choice conflict involving two expansions at
 line 15, column 5 and line 17, column 5 respectively.
 Exception in thread ""main"" java.lang.NullPointerException
 at org.javacc.parser.LookaheadCalc.image(LookaheadCalc.java:80)
 at org.javacc.parser.LookaheadCalc.choiceCalc(LookaheadCalc.java:179)
 at org.javacc.parser.Semanticize$LookaheadChecker.action(Semanticize.java:811)
 at org.javacc.parser.ExpansionTreeWalker.preOrderWalk(ExpansionTreeWalker.java:45)
 at org.javacc.parser.Semanticize.start(Semanticize.java:458)
 at org.javacc.parser.Main.mainProgram(Main.java:168)
 at org.javacc.parser.Main.main(Main.java:97)
 at javacc.main(javacc.java:36)
 ===
 
 The NPE goes away when using LOOKAHEAD=2 to resolve the choice conflict.
 But the generator should not produce an NPE for this.
 
 Technically the NPE is resolved when changing
 if (re.label != null && !re.label.equals(""""))
 to
 if (re != null && re.label != null && !re.label.equals(""""))
 But other solutions where this code is not reached might be better...",,,,,,,,0|i078av:,,,,,42170,,,238
javacc,JAVACC-237,"Wrong ""file is obsolete"" warnings",Bug,Resolved,Major,Fixed,paulcager,marc_mazas,marc_mazas,26/Mar/10 9:56 AM,,06/Apr/10 2:13 PM,06/Apr/10 2:13 PM,5.0,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","It seems to me that JavaCC does not checks properly the generated files version
 and thus produces ""file is obsolete"" warnings that should not be (on
 TokenMgrError, ParseException, Token, SimpleCharStream).
 But this happens only when compiling a .jj file generated from a .jjt grammar.
 This is strange. The only hint I have is the following :
 
 In OutputFile.java, the test (between Strings) is
 if (version != versionId)
 and should be written as
 if (version != null && !version.equals(versionId))
 no ?
 
 private void checkVersion(File file, String versionId) {
 String firstLine = ""/* "" + JavaCCGlobals.getIdString(toolName,
 file.getName()) + "" Version "";
 
 try {
 BufferedReader reader = new BufferedReader(new FileReader(file));
 
 String line;
 while ((line = reader.readLine()) != null) {
 if (line.startsWith(firstLine)) {
 String version = firstLine.replaceFirst("".* Version "",
 """").replaceAll("" \\*/"", """");
 if (version != versionId) {
 JavaCCErrors.warning(file.getName()
 + "": File is obsolete. Please rename or delete this file so""
 + "" that a new one can be generated for you."");
 }
 return;
 }
 }
 
 Or may be the problem comes from side effects in managing the /*egen*/ /*bgen*/
 comments ?",,,,,,,,0|i08yhr:,,,,,52245,,,237
javacc,JAVACC-236,Generated code causes Java warnings,Bug,Open,Major,Unresolved,sreeni,beryozad,beryozad,28/Feb/10 11:32 PM,,30/Nov/12 12:43 PM,,5.0,milestone 1,general,,1,0,,,,,,,,"Operating System: All
 Platform: All","When compiling generated code in Java 5 JDK and Eclipse 3.4 the following are 
 reported as Java warnings:
 
 -The serializable class LookaheadSuccess does not declare a static final 
 serialVersionUID field of type long 
 -The field XYZTokenManager.jjimageLen is never read locally
 -The field XYZTokenManager.lengthOfMatch is never read locally
 -The local variable l is never read
 -The method jjStartNfa_0(int, long) from the type XYZTokenManager is never used 
 locally (this is also reported for jjStartNfa_2, jjStartNfa_3)
 -The method jjStopAtPos(int, int) from the type XYZTokenManager is never used 
 locally
 
 Also the import statements defined in the .jjt file are copied to both 
 XYZPrser.java and XYZParserTokenManager.java, and while they are all being used 
 in the XYZParser.java, some of them occasionally are reported as unused in 
 XYZParserTokenManager.java
 
 It would be great to have the code generated that is warning-free. As a 
 workaround I have to manually insert @SuppressWarnings(""serial"") in the .jjt 
 file and @SuppressWarnings(""unused"") at the beginning of 
 XYZParserTokenManager.java",,,,,,,,0|i08zrb:,,,,,52450,,,236
javacc,JAVACC-235,Add ability to generate generic Visitor interface with type parameters,Improvement,Open,Major,Unresolved,paulcager,rvermillion,rvermillion,09/Feb/10 8:52 AM,,12/Apr/11 1:34 PM,,5.0,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: Macintosh","It is often useful to generate a generic Visitor interface that supports
 different visitor data and return types. Currently JavaCC 5.0 only supports
 fixed data and return types via the VISITOR_DATA_TYPE and VISITOR_RETURN_TYPE
 options. A more robust solution would allow for generic type parameters like so:
 
 public interface FooVisitor<D,R> {
 
 R visit(SimpleNode node, D data);
 
 }
 
 The node interface needs to be modified to have the following method:
 
 <D,R> R jjtAccept(FooVisitor<D,R> visitor, D data);
 
 I have attached a patch that adds a new boolean option called VISITOR_GENERIC
 that generates the appropriate code. I will attach below if I can.",,,,,,,,0|i03vpr:,,,,,22635,,,235
javacc,JAVACC-234,Bad input (does not conform to grammar) is parsed with no exception thrown.,Bug,Resolved,Major,Incomplete,sreeni,mbmast,mbmast,04/Feb/10 12:51 AM,,04/Feb/10 3:34 AM,04/Feb/10 3:34 AM,5.0,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Iâ€™m pretty sure Iâ€™ve uncovered a bug in JavaCC 5.0, which the simple example
 below will show. The grammar allows the input string â€œa b câ€� but what I pass to
 the parser is instead â€œa, b, câ€�, which should not be allowed. If the token
 COMMA is not defined, then the parser correctly throws an exception when it
 encounters the first comma after the letter â€œaâ€�. But if COMMA is defined (as it
 is below), then what happens is the parser stops after the â€œaâ€� without throwing
 any exception and the statement:
 
 n.dump(â€œâ€�);
 
 is executed producing the output:
 
 Start
 Letter
 
 Of course, if the input string is â€œa b câ€� (without the commas) then you get the
 expected result:
 
 Start
 Letter
 Letter
 Letter
 
 Whatâ€™s interesting is that simply defining the token COMMA changes the parser's
 behavior, even though COMMA is not used in any production.
 Is this a bug? I think it is.
 
 PARSER_BEGIN(ParserBug)
 package parser;
 import java.io.StringReader;
 
 public class ParserBug {
 	public static void main(String[] args) {
 		ParserBug parser = new ParserBug(new StringReader(""a, b, c""));
 	 try {
 	 SimpleNode n = parser.Start();
 	 n.dump("""");
 	 } catch (Exception e) {
 	 System.out.println(e.getMessage());
 	 e.printStackTrace();
 	 }
 	}
 }
 PARSER_END(ParserBug)
 
 SKIP :
 {
 "" ""
 }
 
 TOKEN :
 {
 < LETTER: [""a""-""z"",""A""-""Z""] >
 }
 
 TOKEN :
 {
 < COMMA: "","" >
 }
 
 SimpleNode Start() : {}
 {
 //Note that this production does not use the token COMMA
 Letter() ( Letter() )*
 { return jjtThis; }
 }
 
 void Letter() : {}
 {
 <LETTER>
 }",,,,,,,,0|i0d5o7:,,,,,76736,,,234
javacc,JAVACC-233,Enable back up of one token/ensure next token at certain grammar points,Improvement,Open,Major,Unresolved,sreeni,arataj,arataj,10/Nov/09 4:55 AM,,10/Nov/09 4:55 AM,,5.0,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","What about a way to ensure that, at certain points of the grammar, backing up a
 single token is safe and, that a next token exists?
 
 I use the former for error recovery, but I do not know if it won't cause weird
 lexer/parser behavior in some cases.
 
 I can ensure the latter by adding artificial choices to the grammar, but I still
 do not know if it works in all cases.
 
 Such features might add a bit of flexibility that one has with hand--made parsers.",,,,,,,,0|i0c0gv:,,,,,70061,,,233
javacc,JAVACC-232,Problem with TRACK_TOKENS - firstToken is wrong,Bug,Resolved,Major,Duplicate,paulcager,carstensis,carstensis,08/Nov/09 12:59 AM,,06/Apr/10 2:18 PM,06/Apr/10 2:18 PM,5.0,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","I have an issue concerning TRACK_TOKENS in jjtree as it sets the wrong
 ""firstToken"" on some nodes in my case.
 
 I'am using the XPath grammar from
 http://www.w3.org/2007/01/applets/xpathApplet.html
 and added the TRACK_TOKENS option and an UnparseVisitor just as in the
 ""VTransformer"" javacc example.
 
 When I parse the XPath expression ""1+2"", I get this result as a dump of the
 created SimpleNode:
 
 |XPath2 (firstToken '1', lastToken EOF)
 | XPath (firstToken '1', lastToken '2')
 | Expr (firstToken '1', lastToken '2')
 | AdditiveExpr (firstToken EOF, lastToken '2') +
 | IntegerLiteral (firstToken '+', lastToken '1') 1
 | IntegerLiteral (firstToken EOF, lastToken '2') 2
 
 Two things are wrong here:
 # firstToken on Literals is wrong (should be the same as lastToken)
 # firstToken on ""Expr"" subnode is wrong (ie. ""AdditiveExpr"" should have '1' as
 firstToken)
 
 When parsing an ""Expr"" (deciding if it's a ""AdditiveExpr"" or
 ""MultiplicativeExpr"", etc.), the parser creates the corresponding ""AdditiveExpr""
 node only when it has already reached the end of the expression. And at that point
 jjtn001.jjtSetFirstToken(getToken(1));
 is already the token *after the end* of the ""AdditiveExpr"".
 
 
 When looking at the code, I see that 2 ""AdditiveExpr"" nodes are created, the
 first has the right firstToken and the second (the one that survives) has the
 wrong one.
 ----------------------------
 final public void AdditiveExpr() throws ParseException {
 /*@bgen(jjtree) #AdditiveExpr(> 1) */
 // *1st*
 SimpleNode jjtn000 = new SimpleNode(this, JJTADDITIVEEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
 try {
 MultiplicativeExpr();
 label_6:
 while (true) {
 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
 case Minus:
 [..]
 }
 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
 case Plus:
 [..]
 }
 MultiplicativeExpr();
 // *2nd*
 SimpleNode jjtn001 = new SimpleNode(this, JJTADDITIVEEXPR);
 boolean jjtc001 = true;
 jjtree.openNodeScope(jjtn001);
 
 // => *wrong token here*, should use the token ""jjtn000.jjtgetFirstToken()""
 instead of ""getToken(1)""???
 jjtn001.jjtSetFirstToken(getToken(1));
 ----------------------------
 
 Here's how I changed the created XPath parser code as a workaround:
 - for terminal symbols I replaced 
 jjtn00x.jjtSetFirstToken(getToken(1));
 with
 jjtn00x.jjtSetFirstToken(getToken(0));
 (the last token was always correct, and for a terminal symbol lastToken ==
 firstToken)
 
 - replaced the remaining occurences of jjtn00x.jjtSetFirstToken(getToken(1))
 with 
 jjtn00x.jjtSetFirstToken(jjtn000FirstToken);
 and put 
 Token jjtn000FirstToken = getToken(1);
 at the beginning of the method like this:
 ----
 final public void RelativePathExpr() throws ParseException {
 StepExpr();
 Token jjtn000FirstToken = getToken(1);
 label_11:
 while (true) {
 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
 ----
 According to my tests, this fixes the problem for the XPath parser, but of
 course I'd be happy to abandon this workaround once the issue has been solved in
 JJTree :)",,,,,,,,0|i01em7:,,,,,8201,,,232
javacc,JAVACC-231,line numbering issue with jjtree files,Bug,Open,Major,Unresolved,paulcager,paulcager,paulcager,09/Sep/09 12:25 PM,,22/Sep/09 8:55 AM,,4.2,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","Report from one of our users:
 
 There was some discussion about a line numbering issue with jjtree files. I
 have had that issue forever, currently in version 4.2. I think I can tell you
 one construct that produces the problem. I have code like:
 
 
 
 void list_of_ports(NodeState state, int depth
 
 ) #ListOfPorts(state.wanted()) :
 
 { state = nodeState(state, _LIST_OF_PORTS, depth); }
 
 {
 
 â€¦
 
 }
 
 
 
 That works fine, but if I change the position of the right parenthesis as
 follows, it forgets to increment the line count. The line number can still be
 wrong, but now it is consistently off by the same amount through most of the
 source file. Much easier to work with.
 
 
 
 void list_of_ports(NodeState state, int depth)
 
 #ListOfPorts(state.wanted()) :
 
 { state = nodeState(state, _LIST_OF_PORTS, depth); }
 
 {
 
 â€¦
 
 }
 
 
 
 -tom",,,,,,,,0|i0akvj:,,,,,61703,,,231
javacc,JAVACC-230,redundant cast to int,Improvement,Resolved,Trivial,Fixed,paulcager,willenson,willenson,17/Aug/09 1:14 PM,,06/Apr/10 2:05 PM,06/Apr/10 2:05 PM,4.2,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","[javac] SQLTokenManager.java:914: warning: [cast] redundant cast to int
 [javac] int hiByte = (int)(curChar >> 8);
 [javac] ^",,,,,,,,0|i05nsf:,,,,,33015,,,230
javacc,JAVACC-229,"Token class does not provide character offset, only line and column number",Improvement,Open,Major,Unresolved,sreeni,aradzivanovich,aradzivanovich,10/Aug/09 5:56 AM,,30/Apr/11 8:01 PM,,4.2,milestone 1,scanner generator,,4,1,,,,,,,,"Operating System: All
 Platform: All","It would be nice to get character offset of a token in a source file.
 
 Please consider the following API:
 
 public class Token {
 ...
 /** Index of the first character of this Token. */
 public int beginOffset;
 /** Index of the last character of this Token. */
 public int endOffset;
 
 
 /** The line number of the first character of this Token. */
 public int beginLine;
 /** The column number of the first character of this Token. */
 public int beginColumn;
 /** The line number of the last character of this Token. */
 public int endLine;
 /** The column number of the last character of this Token. */
 public int endColumn;",,,,,,,,0|i04go7:,,,,,26030,,,229
javacc,JAVACC-228,Wrong line ending in ParserTokenManager,Bug,Open,Major,Unresolved,paulcager,janosch,janosch,27/Jul/09 6:48 AM,,22/Sep/09 9:09 AM,,4.2,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","javacc now automatically adds a @SuppressWarnings(""all"") annotation to the
 classes it generates, but sadly, it does not respect the OS default line ending
 style (as it does everywhere else) and simply uses \n, which leads to
 uncommitable classes (SVN checks for consistent line endings).
 
 In the end, i have to fix the line breaks by hand, which undermines the
 hashcodes of course.",,,,,,,,0|i06xsn:,,,,,40468,,,228
javacc,JAVACC-227,Using VISITOR and NODE_CLASS generates unexpected ParserVisitor.java,Improvement,Open,Critical,Unresolved,paulcager,hbiestro,hbiestro,23/Jul/09 2:02 AM,,09/Sep/09 10:28 AM,,4.1,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Within a parser.jjt, specifying options VISITOR=true and NODE_CLASS=""MyClass"" generates a ParserVisitor 
 that defines a public 'Object visit(SimpleNode node, Object data);' which is unexpected (and inconvenient).
 Since the NODE_CLASS option states ""that any tree nodes created will then be subclasses of NODE_CLASS"", 
 the ParserVisitor should instead define a 'public Object visit(MyClass node, Object data);' instead.",,,,,,,,0|i03wy7:,,,,,22835,,,227
javacc,JAVACC-226,Incomplete generics support in parser generation,Bug,Open,Major,Unresolved,paulcager,icemank,icemank,12/Jul/09 4:32 PM,,09/Sep/09 10:38 AM,,4.2,milestone 1,parser generator,,1,0,,,,,,,,"Operating System: All
 Platform: All","After setting JDK_VERSION=""1.5"", the generated parser file for the most part 
 has correct generics support.
 However, in the function below, the declaration for ""java.util.Iterator it"" is 
 missing the correct generics typing. It should be ""java.util.Iterator<int[]> 
 it"".
 Also, the next line should not need to cast oldentry to int[].
 
 Generated code snippet below:
 ================================================================================
 private void jj_add_error_token(int kind, int pos) {
 if (pos >= 100) return;
 if (pos == jj_endpos + 1) {
 jj_lasttokens[jj_endpos++] = kind;
 } else if (jj_endpos != 0) {
 jj_expentry = new int[jj_endpos];
 for (int i = 0; i < jj_endpos; i++) {
 jj_expentry[i] = jj_lasttokens[i];
 }
 jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); 
 it.hasNext();) {
 int[] oldentry = (int[])(it.next());
 if (oldentry.length == jj_expentry.length) {
 for (int i = 0; i < jj_expentry.length; i++) {
 if (oldentry[i] != jj_expentry[i]) {
 continue jj_entries_loop;
 }
 }
 jj_expentries.add(jj_expentry);
 break jj_entries_loop;
 }
 }
 if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
 }
 }",,,,,,,,0|i0a59r:,,,,,59175,,,226
javacc,JAVACC-225,incohenrent generate_generics behavior,Bug,Resolved,Major,Duplicate,paulcager,marc_mazas,marc_mazas,27/Apr/09 2:40 AM,,14/Jun/09 5:07 AM,14/Jun/09 5:07 AM,4.2,4.3,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","If you set JDK_VERSION >= 1.5 in a jjt and in a jj file it will force
 GENERATE_GENERICS to true for one and not for the other.
 This is because a java block of the expansion_unit
 	{
 	 Options.normalize();
 	}
 appears in the javacc_options() production in JavaCC.jj but not in the JJTree.jjt.
 I believe it should appear in both.
 This implies that an additional import be also added in the JJTree.jjt file:
 import org.javacc.parser.Options;
 
 Therefore if you set JDK_VERSION >= 1.5 it will always generate appropriate
 generics, unless you don't want by setting also GENERATE_GENERICS = false;",,,,,,,,0|i01gl3:,,,,,8520,,,225
javacc,JAVACC-224,no @Deprecated annotations,Improvement,Open,Major,Unresolved,paulcager,ff1959,ff1959,27/Apr/09 1:39 AM,,09/Sep/09 10:41 AM,,4.2,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: Macintosh",Some generated code needs @Deprecated annotation outside of comments.,,,,,,,,0|i06dxb:,,,,,37249,,,224
javacc,JAVACC-223,unchecked warnings due to no generics,Bug,Open,Major,Unresolved,paulcager,ff1959,ff1959,27/Apr/09 1:37 AM,,09/Sep/09 10:45 AM,,4.2,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: Macintosh","Unchecked warnings are generated due to the lack of generics. If it can be
 proven that no warning is necessary, generate @SuppressWarnings(""unchecked""),
 otherwise use generics for type safe code.",,,,,,,,0|i0fd1z:,,,,,89596,,,223
javacc,JAVACC-222,Add option to skip generation of Node.java,Improvement,Open,Major,Unresolved,sreeni,gier,gier,24/Apr/09 3:45 PM,,24/Apr/09 3:45 PM,,4.2,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","My use case is that I have two jjtree files, one sets ""VISITOR=true"" and creates
 a jjtAccept method in Node.java. The other jjtree file sets visitor to false. 
 I build them both at the same time, and the incorrect Node.java file (without
 jjtAccept) overwrites the good Node.java. So I would like to have an option in
 jjtree to skip generation of Node.java.",,,,,,,,0|i06clr:,,,,,37035,,,222
javacc,JAVACC-221,broken VISITOR_EXCEPTION support in javacc-4.2,Bug,Resolved,Critical,Fixed,sreeni,paulcager,paulcager,07/Apr/09 12:36 PM,,14/Jun/09 9:23 AM,14/Jun/09 9:23 AM,4.2,4.3,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","Hi,
 
 I installed javacc-4.2 and could not compile code that worked fine with 
 javacc-4.1. It turned out that in some files the variable 
 VISITOR_EXCEPTION was not replaced correctly and in other files the 
 throws-statement for this exception was missing.
 
 I attached the contents of the templates directory with the fix I 
 applied to make it work again.
 
 Best regards,
 Thomas",,,,,,,,0|i08xa7:,,,,,52049,,,221
javacc,JAVACC-220,Allow caller to provide stdout/stderr streams to ease embedding,New Feature,Open,Major,Unresolved,paulcager,bentmann,bentmann,20/Feb/09 11:30 AM,,09/Sep/09 10:46 AM,,4.0,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Consider a piece of Java code that whishes to run JavaCC embedded within the
 same JVM (e.g. the JavaCC Maven Plugin). For those clients, the tools already
 provide non-terminating main methods, like
 
 public static int mainProgram(String args[]) throws Exception
 
 This feature request is about extending those methods to also accept the
 stdout/stderr stream used by JavaCC to output diagnostic messages, i.e.
 something like
 
 public static int mainProgram(String args[], PrintStream out, PrintStream err)
 throws Exception
 
 The intention is to allow the caller to safely capture the output of JavaCC by
 providing the target streams (redirecting System.out/System.err is not safe).",,,,,,,,0|i04xtb:,,,,,28807,,,220
javacc,JAVACC-219,TOKEN_MANAGER_USES_PARSER can generate invalid code,Bug,Open,Major,Unresolved,sreeni,tcopeland,tcopeland,10/Feb/09 1:37 PM,,10/Feb/09 1:37 PM,,4.2,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","We could raise an exception for this set of options when validating the grammar:
 
 $ cat foo.jj 
 options {
 BUILD_PARSER=false;
 TOKEN_MANAGER_USES_PARSER=true;
 STATIC=false;
 }
 PARSER_BEGIN(Foo)
 public class Foo {}
 PARSER_END(Foo)
 TOKEN : {
 <HELLO : ""hello"">
 }
 void Hello() : {} {
 <HELLO>
 }
 $ /usr/local/javacc-4.2/bin/javacc foo.jj 
 Java Compiler Compiler Version 4.2 (Parser Generator)
 (type ""javacc"" with no arguments for help)
 Reading from file foo.jj . . .
 File ""TokenMgrError.java"" does not exist. Will create one.
 File ""ParseException.java"" does not exist. Will create one.
 File ""Token.java"" does not exist. Will create one.
 File ""SimpleCharStream.java"" does not exist. Will create one.
 Parser generated successfully.
 $ javac *.java
 FooTokenManager.java:13: cannot find symbol
 symbol : class Foo
 location: class FooTokenManager
 public Foo parser = null;
 ^
 FooTokenManager.java:112: cannot find symbol
 symbol : class Foo
 location: class FooTokenManager
 public FooTokenManager(Foo parserArg, SimpleCharStream stream){
 ^
 FooTokenManager.java:120: cannot find symbol
 symbol : class Foo
 location: class FooTokenManager
 public FooTokenManager(Foo parserArg, SimpleCharStream stream, int lexState){
 ^
 3 errors",,,,,,,,0|i07uwn:,,,,,45832,,,219
javacc,JAVACC-218,TRACK_TOKENS behaviour for empty productions,Bug,Open,Major,Unresolved,paulcager,tvernum,tvernum,24/Jan/09 4:41 PM,,06/Apr/10 2:17 PM,,4.2,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","In a JJTree file with a rule like this:
 
 void Modifiers() : {}
 {
 ( <PUBLIC> | <PRIVATE> | <STATIC> | <SYNC> )*
 }
 
 In the case where a declaration has no modifiers, the Modifiers node will be
 created, but it (conceptually) has no tokens.
 
 The behaviour in this case is that JJTree will call jjtSetFirstToken on the
 node, and will pass in the token that follows the (empty) modifiers (so in a
 Java-like language, that would be a type name token).
 JJTree will not call jjtSetLastToken.
 
 This is easy enough to work around in the cost that processes the AST - if the
 last token is null, it was an empty production - but it's not very intuitive,
 and probably not what was intended.",,,,,,,,0|i02yh3:,,,,,17250,,,218
javacc,JAVACC-217,Interaction between TRACK_TOKENS and NODE_SCOPE_HOOK,Improvement,Open,Major,Unresolved,paulcager,tvernum,tvernum,24/Jan/09 4:29 PM,,09/Sep/09 11:03 AM,,4.2,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","With both TRACK_TOKENS and NODE_SCOPE_HOOK turned on, the generated jj file will
 look something like this:
 
 jjtreeOpenNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
 // Production rules
 } finally {
 if (jjtc000) {
 jjtree.closeNodeScope(jjtn000, true);
 jjtreeCloseNodeScope(jjtn000);
 jjtn000.jjtSetLastToken(getToken(0));
 }
 
 Which means that the node that is passed to the open hook, has no idea of the
 first token, and the close hook cannot be sure which is the last token.
 This limits the amount of token processing that the node hooks can do.
 
 At the very least the documentation should make this clear, although it would be
 preferable if the hooks could make use of the node's token.",,,,,,,,0|i05vxb:,,,,,34333,,,217
javacc,JAVACC-216,Java 1.5 grammar lookahead problem,Bug,Open,Major,Unresolved,tcopeland,xlv,xlv,14/Dec/08 1:46 PM,,28/Sep/09 5:30 PM,,4.2,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","A bug report for PMD was submitted with a Java parsing problem. The grammar used
 by PMD is pretty similar to the one in examples/JavaGrammars/1.5/Java1.5.jj.
 
 To reproduce the problem, use the class:
 
 public class BadClass {
 public Class foo() {
 		return (byte[].class);
 }
 }
 
 Note that the problem occurs only for primitive types, (String[].class) is
 parsed correctly. It's somewhere in the CastLookahead rule but I haven't figured
 it out yet...
 
 Xavier",,,,,,,,0|i09anz:,,,,,54217,,,216
javacc,JAVACC-215,Version number not updated in some generated files,Bug,Resolved,Trivial,Fixed,sreeni,xlv,xlv,29/Nov/08 10:50 AM,,09/Sep/09 11:05 AM,09/Sep/09 11:05 AM,4.2,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Some of the files generated with jjtree and javacc are using 4.1 instead of 4.2
 for the version number:
 
 The AST node classes, Node.java, SimpleNode.java
 
 CharStream.java, 
 ParseException.java
 Token.java
 TokenMgrError.java
 
 At least the last ones (generated with javacc) have differences that are not
 only cosmetic ones.
 
 To reproduce:
 
 jjtree Java.jjt
 javacc Java.jj
 
 with the grammar:
 
 http://pmd.svn.sourceforge.net/viewvc/pmd/trunk/pmd/etc/grammar/Java.jjt?view=log",,,,,,,,0|i0fg33:,,,,,90087,,,215
javacc,JAVACC-214,jjtree 4.2 doesn't honor JDK_VERSION,Bug,Resolved,Major,Fixed,sreeni,xlv,xlv,29/Nov/08 10:23 AM,,14/Jun/09 4:28 AM,14/Jun/09 4:28 AM,4.2,milestone 1,jjtree,,1,0,,,,,,,,"Operating System: All
 Platform: All","In the Java grammar used by PMD, we are using the option JDK_VERSION = ""1.5"";
 
 Using javacc 4.1, JJTJavaParserState.java is generated using generics but when
 regenerated with 4.2, it's based on java 1.4.
 
 The grammar used is at:
 
 http://pmd.svn.sourceforge.net/viewvc/pmd/trunk/pmd/etc/grammar/Java.jjt?view=log",,,,,,,,0|i0dfyf:,,,,,78402,,,214
javacc,JAVACC-213,JavaCCGlobals.getIdString problem,Bug,Closed,Major,Duplicate,sreeni,cristiangoina,cristiangoina,19/Nov/08 10:19 AM,,29/Nov/08 3:23 AM,29/Nov/08 3:23 AM,4.1,4.2,general,,0,0,,,,,,,,"Operating System: Windows XP
 Platform: All","I found this problem while I was compiling jboss source code on my Windows XP
 machine. The problem doesn't manifest on Linux and even on Windows there may be
 cases when it doesn't crop up.
 Currently on Microsoft platforms the idString looks like:
 /*@bgen(jjtree) Generated By:JJTree: Do not edit this line.
 C:\users\misc\jboss\jboss-5.0.0.CR2-src\server\output\parsers\org\jboss\ejb\plugins\cmp\ejbql\JBossQLParser.jj
 */
 
 When javacc tries to compile this file I got the following error:
 [javacc] Exception in thread ""main"" java.lang.Error: Invalid escape character
 at line 1 column 63.
 [javacc] at org.javacc.parser.JavaCharStream.readChar(Unknown Source)
 [javacc] at org.javacc.parser.JavaCCParserTokenManager.getNextToken(Unkno
 wn Source)
 [javacc] at org.javacc.parser.JavaCCParser.getToken(Unknown Source)
 [javacc] at org.javacc.parser.JavaCCParser.javacc_options(Unknown Source)
 
 [javacc] at org.javacc.parser.JavaCCParser.javacc_input(Unknown Source)
 [javacc] at org.javacc.parser.Main.mainProgram(Unknown Source)
 [javacc] at org.javacc.parser.Main.main(Unknown Source)
 
 
 I replicated the problem with javacc unit tests by renaming Tree.jt to uTree.jt
 and invoking javacc as part of the javaFiles test:
 ---
 <java failonerror=""true"" fork=""true"" outputproperty=""test7.out""
 classname=""jjtree"" classpath=""../../bin/lib/javacc.jar"">
 <arg line=""uTree.jjt"" />
 </java>
 
 <javacc target=""out-dir/uTree.jj""
 	 javacchome=""../../bin/lib""/>
 
 <echo>${test7.out}</echo>
 ----
 
 The fix for me was to replace line 232 from JavaCCGlobals.getIdString from
 return toolNamePrefix + "" Do not edit this line. "" +
 addUnicodeEscapes(fileName);
 to 
 return toolNamePrefix + "" Do not edit this line. "" + add_escapes(fileName);
 
 On unix like OS this should not be a problem and even on Windows it may show up
 only in certain cases",,,,,,,,0|i0e0kv:,,,,,81743,,,213
javacc,JAVACC-212,Cannot generate grammar documentation with jjdoc: Unknown regular expression type.,Bug,Closed,Major,Fixed,sreeni,shl,shl,18/Nov/08 7:27 PM,,29/Nov/08 3:23 AM,29/Nov/08 3:23 AM,4.1,4.2,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Trying to generate jjdoc got the following exception:
 
 $ ./jjdoc <PATH_TO_FILE>/ConfigParser.jj 
 Java Compiler Compiler Version 4.1 (Documentation Generator Version 0.1.4)
 (type ""jjdoc"" with no arguments for help)
 Reading from file <PATH_TO_FILE>/ConfigParser.jj . . .
 Oops: Unknown regular expression type.
 Oops: Unknown regular expression type.
 Exception in thread ""main"" java.lang.NullPointerException
 	at org.javacc.jjdoc.HTMLGenerator.print(Unknown Source)
 	at org.javacc.jjdoc.HTMLGenerator.println(Unknown Source)
 	at org.javacc.jjdoc.HTMLGenerator.nonterminalsStart(Unknown Source)
 	at org.javacc.jjdoc.JJDoc.emitNormalProductions(Unknown Source)
 	at org.javacc.jjdoc.JJDoc.start(Unknown Source)
 	at org.javacc.jjdoc.JJDocMain.mainProgram(Unknown Source)
 	at org.javacc.jjdoc.JJDocMain.main(Unknown Source)
 	at jjdoc.main(Unknown Source)",,,,,,,,0|i00wt3:,,,,,5316,,,212
javacc,JAVACC-211,Escape character escaped,Bug,Open,Major,Unresolved,sreeni,timp_work,timp_work,07/Nov/08 7:15 AM,,07/Nov/08 7:15 AM,,4.1,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Within the body of a rule
 if(outputDevice.endsWith("".V\"""")) {
 	pageVariablesAvailable = true; 
 }
 
 is transformed into 
 
 if(outputDevice.endsWith("".V\u005c"""")) {
 pageVariablesAvailable = true;
 }
 
 This probably is correct, in some sense, but it breaks the 
 thoughtworks qdox parser used by Maven .
 
 For my money it should be left alone.",,,,,,,,0|i0dix3:,,,,,78882,,,211
javacc,JAVACC-210,javacc.bat,Bug,Resolved,Major,Fixed,sreeni,mwaisberg,mwaisberg,05/Nov/08 8:44 AM,,09/Sep/09 11:06 AM,09/Sep/09 11:06 AM,4.1,5,general,,0,0,,,,,,,,"Operating System: Windows XP
 Platform: All","the ""lib"" folder sits inside the ""bin"" folder, so javacc.bat should be changed 
 to:
 
 java -classpath ""%~dp0lib\javacc.jar"" javacc %1 %2 %3 %4 %5 %6 %7 %8 %9",,,,,,,,0|i0a68n:,,,,,59332,,,210
javacc,JAVACC-209,parsed java file,Bug,Closed,Major,Incomplete,sreeni,matthewsmith1994,matthewsmith1994,28/Oct/08 5:41 PM,,14/Jun/09 5:09 AM,14/Jun/09 5:09 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","I am new in the field. What I want to do are:
 
 Use the entire Lexical Specification and Parser Specification of current Java.
 I want to input an user Java file, and use Javacc to produce an parsed java file
 before it is converted to bytecode. so that I can see how exactly Javacc works.
 I do not know how should I do that. Please give me some guide. Thanks!
 
 Matthew",,,,,,,,0|i0ejmf:,,,,,84828,,,209
javacc,JAVACC-208,new option SUPPORT_CLASS_VISIBILITY_PUBLIC,Task,Resolved,Major,Fixed,paulcager,ericquil,ericquil,26/Sep/08 10:34 AM,,06/Oct/08 11:37 AM,06/Oct/08 11:37 AM,4.1,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","I thought it would be nice to hide the classes by giving them default visibility.
 I called the option SUPPORT_CLASS_VISIBILITY_PUBLIC.
 I will attach the patch.",,,,,,,,0|i0c76f:,,,,,71148,,,208
javacc,JAVACC-207,"tokenizer apparently treats ""if ("" as a token",Bug,Closed,Major,Incomplete,sreeni,sedgee,sedgee,23/Sep/08 7:12 AM,,14/Jun/09 9:38 AM,14/Jun/09 9:38 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: Windows XP
 Platform: PC","I *AM* a newbie, so I'm not certain that this is an issue.
 I'm writing a tokenizer for a language. 
 I'm not using the SKIP capability because, as I tokenize each line, I need to 
 reconstruct the line for later output. So the skip characters are treated as 
 tokens.
 The DemoProblem.jj file is: 
 =============================================
 
 options {
 	BUILD_PARSER=true;
 	IGNORE_CASE=true;
 	COMMON_TOKEN_ACTION=true;
 }
 
 PARSER_BEGIN(DemoProblem)
 
 import java.io.*;
 
 public class DemoProblem 
 {
 
 public DemoProblem(String fileName)
 {
 this(System.in);
 try { ReInit(new FileInputStream(new File(fileName))); }
 catch(Exception e) { e.printStackTrace(); }
 }
 
 
 public static void main(String[] args) {
 
 DemoProblem dpTokenManager;
 FileInputStream input_stream;
 try {
 	input_stream = new java.io.FileInputStream(args[0]);
 	dpTokenManager = new DemoProblem(input_stream);
 	} catch (java.io.FileNotFoundException e) {
 System.out.println(""Parser: File "" + args[0] + "" not found."");
 return;
 }
 
 	 while(dpTokenManager.token_source.handleToken().kind != EOF) {}
 }
 
 }
 
 PARSER_END(DemoProblem)
 
 TOKEN_MGR_DECLS: {
 
 
 	public static Token handleToken() {
 		Token tok;
 
 
 		while(true) {
 			try {
 			 tok = getNextToken();
 			 break;
 			} catch(TokenMgrError e) {
 				try {
 				 String skipped = recoverTo((char)'\n');
 			 SwitchTo(DEFAULT);
 				} catch(java.io.IOException eio) {
 					Integer jjmatchedKind = 0;
 					tok = jjFillToken();
 					break;
 				}
 			}
 		}
 	return tok;
 
 	}
 
 	private static String recoverTo(char delimiter) throws 
 java.io.IOException {
 	 String skipped = """";
 	 char c;
 	 while ((c = input_stream.readChar()) != delimiter) {
 	 skipped += c;
 	 }
 	 return skipped;
 	}
 
 	public static void CommonTokenAction(Token t) {
 		// System.out.println(""|"" + t.image);
 	}
 
 
 }
 TOKEN : {
 	<EOL : ""\n"" >
 }
 
 
 
 <DEFAULT>
 TOKEN : {
 	<DEFAULT_SKIP : <SKIPPER> > {System.out.println(""SKIPPER : "" + 
 matchedToken.image);}: DEFAULT
 |
 	<DEFAULT_COMMENT_SKIP : <COMMENT_SKIPPER> >{System.out.println
 (""COMMENT_SKIPPER : "" + matchedToken.image);} : DEFAULT
 |
 	<DEFAULT_EOL : <EOL>> {System.out.println(""EOL : "" + 
 matchedToken.image);}: DEFAULT
 | 
 	<END : ""end"" >{System.out.println(""end : "" + matchedToken.image);} : 
 IN_END
 |
 	<IF : ""if"" > {System.out.println(""IF : "" + matchedToken.image);}: IN_IF
 |
 	< UNK_NAME : <VARIABLENAME> > {System.out.println (""Unknown token : "" 
 + matchedToken.image);} : DEFAULT
 }
 
 /* Variations for digits */
 TOKEN : {
 	<ANY_NUMBER : (<SIGNED_DIGIT> | <HEX_DIGIT> | <OCTAL_DIGIT> | 
 <FLOATING_POINT_LITERAL>)>
 }
 
 TOKEN : {
 	<SIGNED_DIGIT : ([""+"",""-""])? ([""0""-""9""])+>
 	| <FLOATING_POINT_LITERAL: ([""0""-""9""])+ ""."" ([""0""-""9""])* (<EXPONENT>)? 
 ([""f"",""F"",""d"",""D""])? | ""."" ([""0""-""9""])+ (<EXPONENT>)? ([""f"",""F"",""d"",""D""])? | 
 ([""0""-""9""])+ <EXPONENT> ([""f"",""F"",""d"",""D""])? | ([""0""-""9""])+ (<EXPONENT>)? 
 [""f"",""F"",""d"",""D""]>
 	| <EXPONENT: [""e"",""E""] ([""+"",""-""])? ([""0""-""9""])+>
 	| <LETTER : [ ""a""-""z"", ""A""-""Z"" ] >
 	| < DIGIT: ([ ""0""-""9""])+ >
 	| < FOTHER: [""_"", "".""] >
 	| < NAM_OTHER: [""_""] >
 	| <HEX_DIGIT: (""0"" [""x"", ""X""] ([""0""-""9"", ""a""-""f"", ""A""-""F""] )+ ) >
 	| <OCTAL_DIGIT: (""8"" [""x"", ""X""] ([""0""-""7""] )+ ) >
 | <CHAR_STRING: (""\"""" ( [""a""-""z""] | [""A""-""Z""] | (<REVERSE_SOLIDUS> 
 [""\""""]) | <SKIPPER> | <SPECIAL_CHAR> | <DIGIT> )* ""\"""") >
 	| <REVERSE_SOLIDUS: ""\\"">
 	| <SPECIAL_CHAR: 
 ([""'"", ""."", ""?"", ""/"", ""~"", ""!"", ""@"", ""#"", ""$"", ""%"", ""^"", ""&"", ""*"", ""("", "")"", ""-
 "", ""_"", ""+"", ""="", ""["", ""{"", ""]"", ""}"", "";"", "";"", ""|"", "">"", ""<""]) >
 	
 }
 
 TOKEN : {
 < TEST_CONDITIONS : (""is"" | ""isnot"" | ""=""
 | ""and""
 | ""not""
 | ""or""
 | ""xor""
 | "">""
 | ""<""
 | "">=""
 | ""<=""
 | ""!="") >
 | <INVALID_TEST_CONDITIONS : (""<>"" ) >
 }
 
 TOKEN : {
 <SKIPPER : ("" ""
 | ""\t""
 | ""\r""
 | ""\f""
 | "","" ) >
 }
 
 TOKEN : {
 <COMMENT_SKIPPER : ((""//"" (~[""\n"", ""\r""])* (""\n"" | ""\r"" | ""\r\n"")?)
 | (""--"" (~[""\n"", ""\r""])* (""\n"" | ""\r"" | ""\r\n"")?)) >
 }
 
 
 TOKEN: {
 	<VARIABLENAME : (<LETTER> (<LETTER>|<DIGIT>|<NAM_OTHER>)*) > |
 	<FUNCTIONNAME : ( <VARIABLENAME> (<SKIPPER>)* ""("" ) >
 }
 
 
 <IN_END>
 TOKEN : {
 	<SK18: <SKIPPER> > {System.out.println(""SK18 Token : "" + 
 matchedToken.image);} : IN_END
 |
 	<C_SK18: <COMMENT_SKIPPER> > {System.out.println(""C_SK18 Token : "" + 
 matchedToken.image);} : IN_END
 |
 	<END_EOL : <EOL>> {System.out.println(""END_EOL Token : "" + 
 matchedToken.image);} : DEFAULT
 |
 	<END_IF : ""if""> {System.out.println(""END_IF Token : "" + 
 matchedToken.image);} : IN_END
 |
 	<ENDNAME : <LETTER> (<LETTER>|<DIGIT>|<NAM_OTHER>)* > 
 {System.out.println(""ENDNAME Token : "" + matchedToken.image);} : IN_END
 }
 
 
 <IN_IF>
 TOKEN: {
 < IF_TEST_CONDITION : <TEST_CONDITIONS> > {System.out.println
 (""IF_TEST_CONDITION Token : "" + matchedToken.image);} : IN_IF
 |
 	<SK19: <SKIPPER> > {System.out.println(""SK19 Token : "" + 
 matchedToken.image);} : IN_IF
 |
 	<IF_THEN : ""then"" > {System.out.println(""IF_THEN Token : "" + 
 matchedToken.image);} : DEFAULT
 |
 <IF_PAREN : (""("" | "")"") > {System.out.println(""IF_PAREN Token : "" + 
 matchedToken.image);} : IN_IF
 |
 <IF_DIGIT : <ANY_NUMBER> > {System.out.println(""IF_DIGIT Token : "" + 
 matchedToken.image);} : IN_IF
 |
 <IF_OPERATION : ( ""+""
 | ""-""
 | ""/""
 | ""**""
 | ""*"" ) > {System.out.println(""IF_OPERATION Token : "" + 
 matchedToken.image);} : IN_IF
 |
 <IF_IS_WITHIN : ""within"" > {System.out.println(""IF_IS_WITHIN Token : "" 
 + matchedToken.image);} : IN_IF
 |
 <IF_IS_WITHIN_RANGE : "".."" > {System.out.println
 (""IF_INVALID_TEST_CONDITION Token : "" + matchedToken.image);} : IN_IF
 |
 < IF_INVALID_TEST_CONDITION : <INVALID_TEST_CONDITIONS> > 
 		{System.out.println(""You don't want to use this: "" + 
 matchedToken.image);}: DEFAULT
 |
 <IF_USER_FUNCTION : <FUNCTIONNAME> > {System.out.println
 (""IF_USER_FUNCTION Token : "" + matchedToken.image);} : IN_IF
 |
 <IF_VAR : <VARIABLENAME> > { System.out.println(""You may use this: "" + 
 matchedToken.image);} : IN_IF
 
 }
 
 ================================
 and the input file is:
 // IF tests
 if (myLocalMeasurement is within 715 .. 790) and fryFish(4,5,6) is 
 within 715 .. 790 then
 -- message ""hahaha""
 end if 
 ===================================
 When I run ""java DemoProblem inputFile"", the ""if ("" is treated as a single 
 token, thus it's not recognized within the DEFAULT state.
 If I modify the input file and take out the paren after the if, the ""if"" is 
 correctly recognized within the DEFAULT state.
 I've written code that gets around this issue, but this seems to be a problem - 
 either with my approach (which seems most likely), or possibly with javacc.
 
 Comments/suggestions are welcome -",,,,,,,,0|i0fo5j:,,,,,91394,,,207
javacc,JAVACC-206,ParseException does not serialize correctly,Bug,Resolved,Minor,Fixed,paulcager,paulcager,paulcager,19/Sep/08 9:38 AM,,24/Sep/08 12:45 PM,24/Sep/08 12:45 PM,4.1,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All
 URL: https://javacc.dev.java.net/servlets/ReadMsg?list=users&msgNo=2560","Thanks to Julian Hyde for raising this issue. The full text is in the email he
 sent to the users' list:
 https://javacc.dev.java.net/servlets/ReadMsg?list=users&msgNo=2560.
 
 ParseException is (necessarily) Serializable, but it has a non-volatile ""Token""
 reference which isn't serializable.",,,,,,,,0|i09jvr:,,,,,55710,,,206
javacc,JAVACC-205,JDK_VERSION=1.6 does not invoke 1.5 branches,Bug,Resolved,Major,Fixed,paulcager,rafiyr,rafiyr,04/Sep/08 2:10 AM,,23/Sep/08 3:09 PM,23/Sep/08 3:09 PM,4.1,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","ParseGen.java checks for equality with 1.5 instead of
 Options.jdkVersionAtLeast(1.5) in two places. Leading to the generation of
 older style code.
 
 Also, Options.java explicitly checks against 1.5 and 1.6 instead of the AtLeast
 function.
 
 Options.java-578- public static String stringBufOrBuild() {
 Options.java:579: if (Options.getJdkVersion().equals(""1.5"") ||
 Options.getJdkVersion().equals(""1.6"")) {
 Options.java-580- return ""StringBuilder"";
 --
 ParseGen.java-551- if (Options.getErrorReporting()) {
 ParseGen.java:552: if (!Options.getJdkVersion().equals(""1.5""))
 ParseGen.java-553- ostr.println("" "" + staticOpt() + ""private
 java.util.List jj_expentries = new java.util.ArrayList();"");
 --
 ParseGen.java-625- ostr.println("" for (int i = 0; i <
 jj_expentries.size(); i++) {"");
 ParseGen.java:626: if (!Options.getJdkVersion().equals(""1.5""))
 ParseGen.java-627- ostr.println("" exptokseq[i] =
 (int[])jj_expentries.get(i);"");",,,,,,,,0|i0at8f:,,,,,63057,,,205
javacc,JAVACC-204,"Include javacc version in the ""Generated by javacc"" comment",Improvement,Open,Major,Unresolved,paulcager,rafiyr,rafiyr,04/Sep/08 1:54 AM,,22/Sep/08 3:48 PM,,4.1,milestone 1,general,,1,0,,,,,,,,"Operating System: All
 Platform: All","I have potentially different versions of javacc available on my systems and if
 an issue arises it would be nice to have some verification which version of
 javacc was in fact responsible for generating a given file.
 
 As such I'd suggest adding a version string to the comment javacc already puts
 in generated files.",,,,,,,,0|i0dme7:,,,,,79445,,,204
javacc,JAVACC-203,"@SuppressWarning(""serial"") can conflict with JavaCC Eclipse plugin",Bug,Resolved,Trivial,Fixed,paulcager,paulcager,paulcager,16/Jun/08 2:36 PM,,24/Sep/08 12:57 PM,24/Sep/08 12:57 PM,4.1~beta1,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Version 4.1 generates @SuppressWarning(""serial"") on TokenMgrError.java, which
 conflicts with the ""Automatically suppress warning in generated files"" option in
 JavaCC eclipse plugin. The compiler complains about duplicate annotation of the
 generated file:
 
 @SuppressWarnings(""serial"")
 public @SuppressWarnings(""all"") class TokenMgrError extends Error
 {
 ....
 }
 
 
 I think the easiest thing to do here is to explicitly declare a version ID - it
 does not have to be unique or a good hash value, or anything like that.
 http://c2.com/ppr/wiki/JavaIdioms/AlwaysDeclareSerialVersionUid.html gives a
 good description.",,,,,,,,0|i05fb3:,,,,,31641,,,203
javacc,JAVACC-202,the option TRACK_TOKENS is malfunction,Bug,Closed,Major,Cannot Reproduce,sreeni,ratermir,ratermir,10/Jun/08 11:28 PM,,02/Sep/08 2:43 AM,02/Sep/08 2:43 AM,4.0,4.1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","In documentation, the option TRACK_TOKENS is specified to track first - last
 tokens of each AST node, but this option does nothing.
 jjtree displays warnin message 
 ""Warning: Line 17, Column 5: Bad option name ""TRACK_TOKENS"". Option setting
 will be ignored.""",,,,,,,,0|i0ckzj:,,,,,73385,,,202
javacc,JAVACC-201,Add option to configure file encoding of grammars and parsers,Improvement,Reopened,Major,Unresolved,tcopeland,bentmann,bentmann,31/May/08 3:08 PM,,23/Feb/09 12:31 PM,,4.0,milestone 1,general,,2,1,,,,,,,,"Operating System: All
 Platform: All","Hi,
 
 I am contributing to Maven where we recently started efforts to unify the
 handling of file encoding for all plugins that read source files [0]. As a
 prerequisite, a plugin needs to expose a parameter for the user to configure the
 employed file encoding. Considering the needs of projects with developers spread
 all over the world like open-source software, it is apparent that relying on the
 user's platform encoding does not deliver reliable results. Also, requiring
 users to set the system property ""file.encoding"" on JVM startup is not feasible
 (e.g. in embedded scenarios like IDEs).
 
 The JavaCC Maven Plugin [1] can currently not provide such an option because the
 underlying JavaCC API does support setting the encoding. Hence this issue is a
 request for a new option in JavaCC to configure the file encoding of a grammar
 file and the generated parser file. A similar question had arised some time ago
 on the user mail list [2]. 
 
 More precisely, some new parameter
 -ENCODING <charset>
 would be appreciated that JavaCC, JJTree and JJDoc would use to create an
 InputStreamReader/OutputStreamWriter rather than a FileReader/FileWriter.
 
 Kind regards,
 
 Benjamin Bentmann
 
 
 [0] http://docs.codehaus.org/display/MAVENUSER/POM+Element+for+Source+File+Encoding
 [1] http://mojo.codehaus.org/javacc-maven-plugin/
 [2] https://javacc.dev.java.net/servlets/ReadMsg?listName=users&msgNo=976",,,,,,,,0|i06gif:,,,,,37668,,,201
javacc,JAVACC-200,"""options"" not allowed as identifier",Bug,Closed,Major,Duplicate,sreeni,jschwarz,jschwarz,28/May/08 4:09 PM,,02/Sep/08 2:43 AM,02/Sep/08 2:43 AM,4.0,4.1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: Macintosh","javacc seems to be treating ""options"" as a keyword. It's not allowing it as a java identifier. I had a 
 grammar that I've been using for a long time with javacc 3.2, and attempting to upgrade javacc to 4.0.
 
 Here is a slightly modified Example2 that gets the 
 
 Reading from file jerry.jj . . .
 org.javacc.parser.ParseException: Encountered ""options"" at line 24, column 10.
 
 
 PARSER_BEGIN(Simple2)
 
 public class Simple2 {
 
 public static void main(String args[]) throws ParseException {
 Simple2 parser = new Simple2(System.in);
 parser.Input();
 }
 
 }
 
 PARSER_END(Simple2)
 
 SKIP :
 {
 "" ""
 | ""\t""
 | ""\n""
 | ""\r""
 }
 
 void Input() :
 { String options ; }
 {
 MatchedBraces() <EOF>
 }
 
 void MatchedBraces() :
 {}
 {
 ""{"" [ MatchedBraces() ] ""}""
 }",,,,,,,,0|i08jkf:,,,,,49827,,,200
javacc,JAVACC-199,Exception if jjt-file-path contains escape sequences,Bug,Closed,Major,Duplicate,sreeni,stfpeter,stfpeter,14/Apr/08 12:00 PM,,02/Sep/08 2:42 AM,02/Sep/08 2:42 AM,current,4.1,jjtree,,0,0,,,,,,,,"Operating System: Windows XP
 Platform: PC","There is a little error in the jj-file created by jjtree under Windows XP. The
 comment in the first line results in a exception if the path of the jjt-file
 contains a sequence like \u, which is interpreted from javacc/Java as an escaped
 character and not as the sequence \u . 
 
 Sample of first line: 
 /*@bgen(jjtree) Generated By:JJTree: Do not edit this line. C:\Dokumente und
 Einstellungen\user2\E.....
 
 Exception:
 [javacc] Exception in thread ""main"" java.lang.Error: Invalid escape character
 at line 1 column 92.
 [javacc] at
 org.javacc.parser.JavaCharStream.readChar(JavaCharStream.java:334)
 [javacc] at
 org.javacc.parser.JavaCCParserTokenManager.getNextToken(JavaCCParserTokenManager.java:2402)
 [javacc] at org.javacc.parser.JavaCCParser.getToken(JavaCCParser.java:8140)
 [javacc] at
 org.javacc.parser.JavaCCParser.javacc_options(JavaCCParser.java:203)
 [javacc] at
 org.javacc.parser.JavaCCParser.javacc_input(JavaCCParser.java:153)
 [javacc] at org.javacc.parser.Main.mainProgram(Main.java:156)
 [javacc] at org.javacc.parser.Main.main(Main.java:95)
 
 For my needs i patched the method getOutputFileName in org/javacc/jtree/IO.java
 like this:
 String getOutputFileName()
 
 {
 
 if (File.separator.equals(""\\""))
 
 return ofn.replace(""\\"", ""\\""+""\\"");
 
 return ofn;
 
 }
 
 Probably a URI-conform syntax would be better (file://....).",,,,,,,,0|i065lz:,,,,,35902,,,199
javacc,JAVACC-198,Exception if jjt-file-path contains escape sequences,Bug,Closed,Major,Duplicate,sreeni,stfpeter,stfpeter,14/Apr/08 11:59 AM,,02/Sep/08 2:42 AM,02/Sep/08 2:42 AM,current,4.1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: PC","There is a little error in the jj-file created by jjtree under Windows XP. The
 comment in the first line results in a exception if the path of the jjt-file
 contains a sequence like \u, which is interpreted from javacc/Java as an escaped
 character and not as the sequence \u . 
 
 Sample of first line: 
 /*@bgen(jjtree) Generated By:JJTree: Do not edit this line. C:\Dokumente und
 Einstellungen\user2\E.....
 
 Exception:
 [javacc] Exception in thread ""main"" java.lang.Error: Invalid escape character
 at line 1 column 92.
 [javacc] at
 org.javacc.parser.JavaCharStream.readChar(JavaCharStream.java:334)
 [javacc] at
 org.javacc.parser.JavaCCParserTokenManager.getNextToken(JavaCCParserTokenManager.java:2402)
 [javacc] at org.javacc.parser.JavaCCParser.getToken(JavaCCParser.java:8140)
 [javacc] at
 org.javacc.parser.JavaCCParser.javacc_options(JavaCCParser.java:203)
 [javacc] at
 org.javacc.parser.JavaCCParser.javacc_input(JavaCCParser.java:153)
 [javacc] at org.javacc.parser.Main.mainProgram(Main.java:156)
 [javacc] at org.javacc.parser.Main.main(Main.java:95)
 
 For my needs i patched the method getOutputFileName in org/javacc/jtree/IO.java
 like this:
 String getOutputFileName()
 
 {
 
 if (File.separator.equals(""\\""))
 
 return ofn.replace(""\\"", ""\\""+""\\"");
 
 return ofn;
 
 }
 
 Probably a URI-conform syntax would be better (file://....).",,,,,,,,0|i0a5kf:,,,,,59223,,,198
javacc,JAVACC-197,Wrong matching in lexer,Bug,Open,Critical,Unresolved,sreeni,s_fuhrm,s_fuhrm,20/Mar/08 6:46 AM,,20/Mar/08 7:04 AM,,4.0,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Hi,
 
 I've got the problem that the Lexer recognizes tokens in an illegal way. Example:
 
 <DEFAULT>Current character : \n (10) at line 6 column 13
 Currently matched the first 4 characters as a <IDENTIFIER> token.
 Putting back 1 characters into the input stream.
 ****** FOUND A <IDENTIFIER> MATCH (12.2) ******
 
 Return: version
 Return: line
 Return: start
 Exception in thread ""main"" ParseException: Encountered ""12.2"" at line 6, column 9.
 Was expecting:
 <NUMBER> ...
 
 at N3.generateParseException(N3.java:1436)
 at N3.jj_consume_token(N3.java:1312)
 at N3.version(N3.java:986)
 at N3.line(N3.java:51)
 at N3.start(N3.java:30)
 at N3.main(N3.java:7)
 
 
 
 But take a look at the token definition of ""<IDENTIFIER>"":
 	< IDENTIFIER : [""A""-""Z"", ""a""-""z""] ([""A""-""Z"", ""a""-""z"", ""0""-""9"", ""-"", ""/"", ""."",
 "":"", ""_"" ])+ >
 
 The first letter must be alphabetic, so ""12.2"" will never match an identifier.
 
 If this is really a Javacc problem this is serious.",,,,,,,,0|i0fy6f:,,,,,93018,,,197
javacc,JAVACC-196,TokenManagerError,Bug,Closed,Major,Incomplete,sreeni,gspie,gspie,27/Feb/08 7:05 PM,,02/Sep/08 2:41 AM,02/Sep/08 2:41 AM,4.0,not determined,parser generator,,0,0,,,,,,,,"Operating System: Windows XP
 Platform: Other","I have a paerser that has a TokenManager that generated an exception while 
 scanning a string. Here is the input to the parser:
 
 (#WTSYSTEM.FLEDATOP GE 10000 AND ('NT_System.File_Data_Operations/Sec' LT 
 100000)) ;
 
 And here is what the parser spit out:
 
 Exception in thread ""Thread-38"" 
 candle.fw.util.parsers.filterparser.TokenMgrError: Lexical error at line 1, 
 column 68. Encountered: ""/"" (47), after : ""#\'NT_System.File_Data_Operations""
 
 It appears to have a problem with /Sec
 
 Here are my JavaCC Options:
 
 options{
 static=true;
 DEBUG_PARSER=false;
 DEBUG_LOOKAHEAD=false;
 CACHE_TOKENS=true;
 COMMON_TOKEN_ACTION=false;
 JAVA_UNICODE_ESCAPE=true;
 }",,,,,,,,0|i0ablb:,,,,,60199,,,196
javacc,JAVACC-195,jjtreeintro.html uses html tags inside of a <pre> block,Bug,Closed,Major,Fixed,sreeni,pwagland,pwagland,30/Jan/08 12:47 AM,,02/Sep/08 2:40 AM,02/Sep/08 2:40 AM,4.0,4.1,www,,0,0,,,,,,,,"Operating System: All
 Platform: All",This means that the displayed html will not be what was intended.,,,,,,,,0|i0bemn:,,,,,66523,,,195
javacc,JAVACC-194,Remove extraneous else clauses from SimpleCharStream,Improvement,Open,Major,Unresolved,sreeni,pwagland,pwagland,29/Jan/08 2:42 PM,,30/Jan/08 1:21 AM,,4.0,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Again, this is a standard eclipse warning to not use extraneous else clauses.
 
 This patch makes the file (that) warning clean.",,,,,,,,0|i0csr3:,,,,,74643,,,194
javacc,JAVACC-193,Only emit semLA when needed,Improvement,Closed,Major,Fixed,sreeni,pwagland,pwagland,29/Jan/08 2:03 PM,,02/Sep/08 2:40 AM,02/Sep/08 2:40 AM,4.0,4.1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All",Get rid of another unused variable warning.,,,,,,,,0|i0abmn:,,,,,60205,,,193
javacc,JAVACC-192,the source=1.4 directive is used to compile 1.4 code however the code uses 1.5 only methods.,Bug,Closed,Critical,Fixed,paulcager,pwagland,pwagland,29/Jan/08 1:51 PM,,02/Sep/08 2:39 AM,02/Sep/08 2:39 AM,4.0,4.1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","For Example, line 118 of OutputFile.java uses ""replace(String, String)"", however this method only exists in 
 Java 1.5. It will still compile on a JDK 1.5, even when it is told that the source file is 1.4, however it will not 
 run on a 1.4 system.
 
 Fortunately, none of the 1.5 code is on the production code paths, or at least on none of the ones that I 
 use. However, this should probably be fixed.",,,,,,,,0|i01whz:,,,,,11098,,,192
javacc,JAVACC-191,"javaCC generates code that ""hides"" variables, leading to compiler warnings",Improvement,Open,Major,Unresolved,paulcager,pwagland,pwagland,29/Jan/08 1:24 PM,,25/Mar/08 4:49 AM,,4.0,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Many coding styles do not allow you to ""hide"" variables, that is to define on in the method scope that is 
 also defined on the class scope, yet this is often done in the generated code. This is annoying if you have 
 automatic IDE warnings setup for your projects, since you need to disable it for any project that has javacc 
 code.",,,,,,,,0|i04rrz:,,,,,27829,,,191
javacc,JAVACC-190,It would be useful if there was a consistent coding style.,Bug,Open,Major,Unresolved,paulcager,pwagland,pwagland,29/Jan/08 1:22 PM,,25/Sep/08 2:37 PM,,4.0,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","The code at the moment has a mix between two and three space indents, some files are tab indented, 
 some are space indented. It would be useful if this was made consistent, that way eclipse can be set up to 
 correctly do these indents/spacing requirements for me.
 
 It would also be nice if the files did not have trailing whitespace everywhere, since then when editors strip 
 it off, the cvs diffs do not become overly bloated.",,,,,,,,0|i0ayfb:,,,,,63898,,,190
javacc,JAVACC-189,Allow the jjtAccept methods to specify their return type.,Improvement,Closed,Major,Duplicate,sreeni,pwagland,pwagland,28/Jan/08 3:09 PM,,25/Nov/10 6:52 PM,02/Sep/08 2:38 AM,4.0,4.1,general,,0,0,,,,,,,JAVACC-188,"Operating System: All
 Platform: All","This is essentially the same as issue 160 and issue 188, and is being proposed for the same reasons. If 
 there is agreement, then I will put together a patch.",,,,,,,,0|i02w6v:,,,,,16880,,,189
javacc,JAVACC-188,Allow the visitors to specify what the generated return type should be.,Improvement,Closed,Major,Fixed,paulcager,pwagland,pwagland,28/Jan/08 3:05 PM,,25/Nov/10 6:52 PM,02/Sep/08 2:38 AM,4.0,4.1,general,,0,0,,,,,,,JAVACC-189,"Operating System: All
 Platform: All","This is essentially similar to issue 160.
 
 At the moment we have a script that does this post generation, but as mentioned in the previous ticket, it 
 is nice if the files do not need to be post generation modified. If there is consensus that this is a good 
 idea I will work up and attach a patch.",,,,,,,,0|i0fitj:,,,,,90530,,,188
javacc,JAVACC-187,JJTree does not strip out the VISITOR_EXCEPTION before passing to javacc,Bug,Closed,Major,Fixed,sreeni,pwagland,pwagland,28/Jan/08 2:56 PM,,02/Sep/08 2:37 AM,02/Sep/08 2:37 AM,4.0,4.1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","This means that if you have several ant jobs, one of which runs jjtree, and then runs javacc you will 
 always get the warning:
 
 [javacc] Warning: Line XX, Column YY: Bad option name ""VISITOR_EXCEPTION"". Option setting will be 
 ignored.
 
 This is easy to fix, patch inlined:
 
 Index: src/org/javacc/jjtree/JJTreeGlobals.java
 ===============================================================
 ====
 RCS file: /cvs/javacc/src/org/javacc/jjtree/JJTreeGlobals.java,v
 retrieving revision 1.11
 diff -u -r1.11 JJTreeGlobals.java
 --- src/org/javacc/jjtree/JJTreeGlobals.java	9 Nov 2007 22:33:28 -0000	1.11
 +++ src/org/javacc/jjtree/JJTreeGlobals.java	28 Jan 2008 22:53:48 -0000
 @@ -42,7 +42,7 @@
 	 parserClassBodyStart = null;
 	 parserImports = null;
 	 productions = new Hashtable();
 -	 
 +
 	 jjtreeOptions = new HashSet();
 	 jjtreeOptions.add(""JJTREE_OUTPUT_DIRECTORY"");
 	 jjtreeOptions.add(""MULTI"");
 @@ -60,6 +60,7 @@
 	 jjtreeOptions.add(""NODE_USES_PARSER"");
 	 jjtreeOptions.add(""BUILD_NODE_FILES"");
 	 jjtreeOptions.add(""VISITOR"");
 +	 jjtreeOptions.add(""VISITOR_EXCEPTION"");
 	 jjtreeOptions.add(""VISITOR_DATA_TYPE"");
 }",,,,,,,,0|i093un:,,,,,53113,,,187
javacc,JAVACC-186,Do not generate unused constructors for the generated nodes,Improvement,Open,Major,Unresolved,sreeni,pwagland,pwagland,28/Jan/08 2:29 PM,,06/Feb/08 3:03 PM,,4.0,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","Since often the code will not change from being static to non-static, and the vast majority of nodes will be 
 generated, it would be nice if the unused constructors would not be generated. This helps cut down on 
 the amount of unused code paths in a project.",,,,,,,,0|i08ti7:,,,,,51437,,,186
javacc,JAVACC-185,NFAState includes commented out unused fields,Task,Closed,Major,Fixed,sreeni,pwagland,pwagland,28/Jan/08 3:44 AM,,02/Sep/08 2:36 AM,02/Sep/08 2:36 AM,4.0,4.1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Inline patch:
 
 Index: src/org/javacc/parser/NfaState.java
 ===============================================================
 ====
 RCS file: /cvs/javacc/src/org/javacc/parser/NfaState.java,v
 retrieving revision 1.18
 diff -u -r1.18 NfaState.java
 --- src/org/javacc/parser/NfaState.java	24 Jan 2008 00:39:48 -0000	1.18
 +++ src/org/javacc/parser/NfaState.java	28 Jan 2008 11:41:37 -0000
 @@ -2788,7 +2788,6 @@
 ostr.println("" curPos = 0;"");
 }
 
 - ostr.println("" //int[] nextStates; // not used"");
 ostr.println("" int startsAt = 0;"");
 ostr.println("" jjnewStateCnt = "" + generatedStates + "";"");
 ostr.println("" int i = 1;"");
 @@ -2805,7 +2804,6 @@
 ""TokenMgrError.addEscapes(String.valueOf(curChar)) + \"" (\"" + (int)curChar + \"") "" +
 ""at line \"" + input_stream.getEndLine() + \"" column \"" + input_stream.getEndColumn());"");
 
 - ostr.println("" //int j; // not used"");
 ostr.println("" int kind = 0x"" + Integer.toHexString(Integer.MAX_VALUE) + "";"");
 ostr.println("" for (;;)"");
 ostr.println("" {"");",,,,,,,,0|i0g7xr:,,,,,94599,,,185
javacc,JAVACC-184,spelling typo in the constructed files,Task,Closed,Major,Fixed,sreeni,pwagland,pwagland,27/Jan/08 1:56 PM,,02/Sep/08 2:36 AM,02/Sep/08 2:36 AM,4.0,4.1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","inline patch:
 
 Index: src/org/javacc/parser/JavaFiles.java
 ===============================================================
 ====
 RCS file: /cvs/javacc/src/org/javacc/parser/JavaFiles.java,v
 retrieving revision 1.25
 diff -u -r1.25 JavaFiles.java
 @@ -2285,7 +2285,7 @@
 ostr.println("" }"");
 ostr.println("""");
 ostr.println("" /**"");
 - ostr.println("" * No-argument contructor"");
 + ostr.println("" * No-argument constructor"");
 ostr.println("" */"");
 ostr.println("" public Token() {}"");
 ostr.println("""");",,,,,,,,0|i0aktr:,,,,,61695,,,184
javacc,JAVACC-183,"jjCheckNAddStates(int start, int end) is generated even when not needed.",Improvement,Closed,Major,Fixed,sreeni,pwagland,pwagland,22/Jan/08 9:48 PM,,02/Sep/08 2:35 AM,02/Sep/08 2:35 AM,4.0,4.1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","The jjCheckNAddStates(int start, int end) method is always generated, even though it is not always used. 
 Javacc already has conditional creation of the single argument method, this patch adds conditional 
 creation of the two argument form of the method.
 
 Gets rid of unused code warnings in Eclipse :-)",,,,,,,,0|i0fnkn:,,,,,91300,,,183
javacc,JAVACC-182,Do not generate unused code in RStringLiteral.java,Task,Closed,Major,Fixed,paulcager,pwagland,pwagland,22/Jan/08 3:22 PM,,02/Sep/08 2:35 AM,02/Sep/08 2:35 AM,4.0,4.1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","The jjStartNfaWithStates_* methods are generated more often than they are needed. Attached is a patch to 
 only generate the method if it is used.
 
 Gets rid of unused code warnings in Eclipse :-)",,,,,,,,0|i0g22n:,,,,,93649,,,182
javacc,JAVACC-181,trivial typo in the examples,Improvement,Closed,Major,Fixed,sreeni,pwagland,pwagland,22/Jan/08 2:05 PM,,02/Sep/08 2:33 AM,02/Sep/08 2:33 AM,4.0,4.1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Trivial I know, but every little bit helps polish the product ;-)
 
 Index: examples/JavaGrammars/1.5/Token.java
 ===============================================================
 ====
 RCS file: /cvs/javacc/examples/JavaGrammars/1.5/Token.java,v
 retrieving revision 1.1
 diff -u -r1.1 Token.java
 --- examples/JavaGrammars/1.5/Token.java	27 Dec 2003 23:59:48 -0000	1.1
 +++ examples/JavaGrammars/1.5/Token.java	22 Jan 2008 22:02:55 -0000
 @@ -61,7 +61,7 @@
 * can create and return subclass objects based on the value of ofKind.
 * Simply add the cases to the switch for all those special cases.
 * For example, if you have a subclass of Token called IDToken that
 - * you want to create if ofKind is ID, simlpy add something like :
 + * you want to create if ofKind is ID, simply add something like :
 *
 * case MyParserConstants.ID : return new IDToken();
 *",,,,,,,,0|i0akev:,,,,,61628,,,181
javacc,JAVACC-180,Unused variable specialToken if there is no SPECIAL_TOKEN in the source file,Improvement,Closed,Major,Fixed,sreeni,pwagland,pwagland,22/Jan/08 12:59 AM,,02/Sep/08 2:32 AM,02/Sep/08 2:32 AM,4.0,4.1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","This means that my parser project unnecessarily shows warnings in Eclipse. This creates a mental barrier 
 to keeping the whole project warning free, since there are some that ""are known"", and if that number is 
 not kept at zero, it rapidly creeps up.",,,,,,,,0|i07b5b:,,,,,42631,,,180
javacc,JAVACC-179,Typo,Task,Closed,Minor,Fixed,sreeni@javacc.dev.java.net,s_fuhrm,s_fuhrm,28/Dec/07 7:37 AM,,02/Sep/08 2:30 AM,02/Sep/08 2:30 AM,4.0,4.1,www,,0,0,,,,,,,,"Operating System: All
 Platform: All
 URL: https://javacc.dev.java.net/doc/javaccgrm.html","Replace <*< with <*> (the in-all-states marker) in
 https://javacc.dev.java.net/doc/javaccgrm.html",,,,,,,,0|i07c0f:,,,,,42771,,,179
javacc,JAVACC-178,Target option,Improvement,Open,Trivial,Unresolved,paulcager,s_fuhrm,s_fuhrm,28/Dec/07 7:22 AM,,22/Sep/08 3:53 PM,,4.0,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Hi,
 
 I propose a target option analogous to the -target option of javac.
 
 Stuff that could be toggled for ""-target"":
 
 * 1.5: generics for the collections (currently will get javac warnings if using
 flat collection type Vector)
 
 * 1.2: use more sophisticated collection types, for example ArrayList instead of
 Vector. Vector is expensively synchronized and quite fat.
 
 * 1.5: use fast StringBuilder instead of senselessly-much-synchronized expensive
 StringBuffer
 
 This is really a nice-to-have, therefore P5.",,,,,,,,0|i0fwzz:,,,,,92827,,,178
javacc,JAVACC-177,lengthOfMatch not updated for TOKENs,Bug,Closed,Major,Fixed,paulcager,s_fuhrm,s_fuhrm,28/Dec/07 6:56 AM,,02/Sep/08 2:30 AM,02/Sep/08 2:30 AM,4.0,4.1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Hi,
 
 the lengthOfMatch in the token manager won't get updated if having a TOKEN. It
 WILL get updated for SKIP, SPECIAL_TOKEN and MORE.
 
 This is not documented like this. I'd expect lengthOfMatch always to be set
 correctly.",,,,,,,,0|i0fvof:,,,,,92613,,,177
javacc,JAVACC-176,Reduce StringBuffer allocation code bloat in XXXTokenManager,Task,Closed,Major,Fixed,paulcager,s_fuhrm,s_fuhrm,28/Dec/07 5:52 AM,,02/Sep/08 2:28 AM,02/Sep/08 2:28 AM,4.0,4.1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Hi,
 
 i experience for lexer stuff like this (SGML entities)
 
 <*> TOKEN:
 {
 ...
 < ENTITY_nbsp : "" ""> {replaceChar(image,matchedToken,lengthOfMatch,
 (char)160);}
 | < ENTITY_iexcl : ""&iexcl;""> {replaceChar(image,matchedToken,lengthOfMatch,
 (char)161);}
 | < ENTITY_cent : ""&cent;""> {replaceChar(image,matchedToken,lengthOfMatch,
 (char)162);}
 | < ENTITY_pound : ""&pound;""> {replaceChar(image,matchedToken,lengthOfMatch,
 (char)163);}
 | < ENTITY_curren : ""&curren;""> {replaceChar(image,matchedToken,lengthOfMatch,
 (char)164);}
 | < ENTITY_yen : ""&yen;""> {replaceChar(image,matchedToken,lengthOfMatch,
 (char)165);}
 | < ENTITY_brvbar : ""&brvbar;""> {replaceChar(image,matchedToken,lengthOfMatch,
 (char)166);}
 | < ENTITY_sect : ""&sect;""> {replaceChar(image,matchedToken,lengthOfMatch,
 (char)167);}
 | < ENTITY_uml : ""&uml;""> {replaceChar(image,matchedToken,lengthOfMatch,
 (char)168);}
 ...
 }
 
 the following token manager expansion:
 
 void TokenLexicalActions(Token matchedToken)
 {
 switch(jjmatchedKind)
 {
 ...
 case 3 :
 if (image == null)
 image = new StringBuffer();
 image.append(jjstrLiteralImages[3]);
 replaceChar(image,matchedToken,lengthOfMatch,
 (char)160);
 break;
 case 4 :
 if (image == null)
 image = new StringBuffer();
 image.append(jjstrLiteralImages[4]);
 replaceChar(image,matchedToken,lengthOfMatch,
 (char)161);
 break;
 ...
 
 Would be nice to move the stringbuffer allocation outside of each case in the
 switch statement and reduce the size of the produced code. ""image"" is a member
 of the class so it could be initialized in the constructor.
 
 getNextToken() assigns NULL to image therefore deleting the object. This means
 lexing gets quite expensive because of object allocation. I'd recommend using
 StringBuffer.setLength(0) instead of creating a new 'clean' stringbuffer all the
 time.",,,,,,,,0|i07uy7:,,,,,45839,,,176
javacc,JAVACC-175,JJTree generated source contains invalid escape sequence in opening comment,Bug,Closed,Major,Duplicate,sreeni,gspie,gspie,08/Dec/07 9:23 AM,,02/Sep/08 2:28 AM,02/Sep/08 2:28 AM,4.0,4.1,jjtree,,0,0,,,,,,,,"Operating System: Windows XP
 Platform: Other","JJTree generated the following comment into the .jj file it created:
 /*@bgen(jjtree) Generated By:JJTree: Do not edit this line. C:\b-v620fp1
 \cnp\_antHill\kcjcli\src\candle\fw\util\filterparser\FilterEvaluator.jj */
 
 And the following error was generated by JavaCC:
 
 jtree-filter:
 [javacc] Java Compiler Compiler Version 4.0 (Parser Generator)
 [javacc] (type ""javacc"" with no arguments for help)
 [javacc] Reading from file C:\b-v620fp1\cnp\_antHill\kcjcli\src\candle\fw\uti
 l\filterparser\FilterEvaluator.jj . . .
 [javacc] Exception in thread ""main"" java.lang.Error: Invalid escape character
 at line 1 column 108.
 [javacc] at org.javacc.parser.JavaCharStream.readChar(Unknown Source)
 [javacc] at org.javacc.parser.JavaCCParserTokenManager.getNextToken(Unkno
 wn Source)
 [javacc] at org.javacc.parser.JavaCCParser.jj_ntk(Unknown Source)
 [javacc] at org.javacc.parser.JavaCCParser.javacc_options(Unknown Source)
 
 [javacc] at org.javacc.parser.JavaCCParser.javacc_input(Unknown Source)
 [javacc] at org.javacc.parser.Main.mainProgram(Unknown Source)
 [javacc] at org.javacc.parser.Main.main(Unknown Source)
 
 BUILD FAILED
 C:\b-v620fp1\cnp\kcj\build.xml:30: The following error occurred while executing
 this line:
 C:\b-v620fp1\cnp\ant\imports\stdtargets.xml:52: The following error occurred whi
 le executing this line:
 C:\b-v620fp1\cnp\kcjcli\build.xml:87: C:\ibm-j2sdk1.5.0\jre\bin\java.exe failed
 with return code 1
 
 Here are the first few lines of the file that JJTree generated:
 
 /*@bgen(jjtree) Generated By:JJTree: Do not edit this line. C:\b-v620fp1
 \cnp\_antHill\kcjcli\src\candle\fw\util\filterparser\FilterEvaluator.jj */
 /*@egen*/options{
 static=false; 
 DEBUG_PARSER=false;
 DEBUG_LOOKAHEAD=false;
 CACHE_TOKENS=true;
 COMMON_TOKEN_ACTION=false;
 JAVA_UNICODE_ESCAPE=true;
 }
 PARSER_BEGIN(FilterEvaluator)
 /*
 COPYRIGHT_COMMENT_TAG_BEGIN",,,,,,,,0|i03duf:,,,,,19740,,,175
javacc,JAVACC-174,Generated Nodes Enrichment,Improvement,Open,Major,Unresolved,sreeni,tanelorn,tanelorn,15/Nov/07 2:17 PM,,15/Nov/07 2:17 PM,,current,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","There is currently no simple way to enrich generated nodes code on a
 node-by-node basis without manually modifying them.
 
 A mechanism enabling the definition of an extended base class and implemented
 interfaces, as well as the addition of code is proposed. It would be similar to
 the existing PARSER_BEGIN/PARSER_END block.
 
 The following syntax is suggested (its specifics are still discussed on the
 mailing-list):
 
 NODE_BEGIN(AdditiveExpression)
 
 package my.node.package;
 import some.needed.import;
 
 public class AdditiveExpression extends BinaryOp implements Something {
 public Number evaluate(Number LHS, Number RHS) {
 return add(LHS, RHS);
 }
 }
 
 NODE_END(AdditiveExpression)",,,,,,,,0|i09k3j:,,,,,55745,,,174
javacc,JAVACC-173,Reworking NODE_EXTENDS,Improvement,Closed,Minor,Fixed,paulcager,paulcager,paulcager,09/Nov/07 2:31 PM,,02/Sep/08 2:27 AM,02/Sep/08 2:27 AM,4.0,4.1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","I'm raising this issue to document the problem I first raised on the dev mailing
 list...
 
 The option NODE_EXTENDS was introduced in 4.0 (in response to issue 48),
 and can be used to specify a custom base class which the generated
 SimpleNode will extend. The idea was to reduce the need to manually edit
 the generated files.
 
 This works up to a point - for example you could use this facility to
 add attributes to the Node classes. But I think by having SimpleNode
 extend the custom class we have got the relationship the wrong way
 around. For example:
 
 * The custom class can not override SimpleNode's toString() or dump()
 methods.
 
 * The custom class does not have access to SimpleNode's implementation
 of the Node interface, e.g. it cannot call jjtGetChild etc.
 
 As an illustration, we can't make meaningful use of NODE_EXTENDS within
 the JJtree code itself.
 
 For this reason I think we need an option to provide a custom *subclass*
 of SimpleNode, rather than a superclass. The generated AST nodes would
 then need to extend the custom class.
 
 Does this sound right to everybody?
 
 If you are all in agreement, this is what I'd like to do:
 
 * Keep the existing NODE_EXTENDS option for backwards compatibility,
 but mark it as deprecated in the documentation (NB: although the
 NODE_EXTENDS feature was included in 4.0, there was no documentation for
 it, so I suspect few - if any - people use it).
 
 * Keep the generated SimpleNode the same as it is now.
 
 * Add a NODE_CLASS option to define the name of the user-supplied
 subclass of SimpleNode.
 
 * If NODE_CLASS is specified and MULTI=false, all we need to do is
 generate code to instantiate the custom class rather than SimpleNode.
 
 * If NODE_CLASS is specified and MULTI=true, we need to make the AST
 classes extend the custom class rather than SimpleNode.",,,,,,,,0|i0a9zr:,,,,,59940,,,173
javacc,JAVACC-172,"license in ""binary"" distribution still (old) source license",Bug,Closed,Major,Duplicate,sreeni,mgarcia512,mgarcia512,06/Nov/07 6:42 AM,,02/Sep/08 2:26 AM,02/Sep/08 2:26 AM,4.0,4.1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Hi, 
 
 I've developed an Eclipse plugin that uses javacc.jar. 
 Given that there's no separate ""binary license"", the license that applies to
 javacc.jar as a whole is the one stated in the source files in 
 https://javacc.dev.java.net/files/documents/17/26777/javacc-4.0.zip
 
 As discussed in issue#69 , i.e. 
 https://javacc.dev.java.net/issues/show_bug.cgi?id=69 
 the license on the source files is going to be made open-source-compatible in v4.1 
 
 I'm not asking for the Java5 features of v4.1, but rather whether that license
 issue (first raised in 2005) can be addressed, for example by making available a
 v4.0A source + binary download (no samples, no grammars written by
 thrid-parties, just the files with BSD license). 
 
 Thank you so much. 
 
 
 Miguel 
 
 
 -- 
 Miguel Garcia 
 Institute for Software Systems (STS), AB 4-02
 Technische Universitaet Hamburg-Harburg
 Harburger Schlossstr. 20, 21073 Hamburg Fax: (+49)40-42878-2515
 http://www.sts.tu-harburg.de/~mi.garcia",,,,,,,,0|i0dhbb:,,,,,78622,,,172
javacc,JAVACC-171,Allow a user-specified Token Factory,Improvement,Closed,Major,Fixed,paulcager,paulcager,paulcager,02/Nov/07 5:39 PM,,02/Sep/08 2:25 AM,02/Sep/08 2:25 AM,4.0,4.1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Currently to subclass Token you have to edit the boiler-plate Token.java file,
 which isn't perfect. I'd like an option that allows the user to specify a Token
 Factory. E.g.
 
 options {
 TOKEN_FACTORY = ""users.package.TokenFactory""
 }
 
 where the Tokenfactory has a static method:
 public static Token newToken(int ofKind, String image)
 
 This would be one (small) step to fixing Issue 65 (Object-oriented extensibility
 for JavaCC).
 
 [Hope above makes sense - it's getting late].",,,,,,,,0|i06xqv:,,,,,40460,,,171
javacc,JAVACC-170,Adding a getValue method to Token,Improvement,Closed,Major,Fixed,paulcager,saquigley,saquigley,23/Oct/07 9:30 PM,,25/Nov/10 6:52 PM,02/Sep/08 2:20 AM,4.0,4.1,scanner generator,,0,0,,,,,,,"JAVACC-147, JAVACC-141","Operating System: All
 Platform: All","I think that it would be a good idea to add the following to the Token class:
 
 private Object value = null;
 
 public Object getValue() {
 return value;
 }
 
 public void setValue(object value) {
 this.value = value;
 }
 
 The reason for this is that tokens which are not used as syntactic sugar will
 contain meaningful values that will be used later on by the compiler or
 interpreter. This is pretty standard in compilers. Most compiler textbooks
 describe tokens as consisting of a compulsory type (called kind in JavaCC) and
 an optional attribute value. This attribute value is different from the lexeme
 which is the string matched by the scanner (called image in JavaCC).
 
 Attribute values can be constants of a specific type (e.g. Integer, Decimal,
 Boolean, String) or pointers to the symbol table in the case of identifiers.
 Further explanations can be found in any standard compiler textbook.
 
 The most important part of this request is the implementation of the getValue()
 method. This could be defined in the Token class as:
 public Object getValue() {
 return null;
 }
 Then any subclass of Token that actually wants to return a non-null value could
 override this method as appropriate, with or without a value field. The
 advantage of providing only the getValue() method would be a small reduction in
 the overhead of storing a value for all tokens whether or not they need one. 
 The advantage of my original suggestion is that if the Token constructor was
 modified to take the image as parameter (see issue #141) then the value could
 simply be created at construction time.",,,,,,,,0|i01yfj:,,,,,11411,,,170
javacc,JAVACC-169,Ignore case doesn't handle string literal tokens with mixed case properly,Bug,Reopened,Critical,Unresolved,sreeni,sreeni,sreeni,07/Oct/07 10:33 AM,,16/Jan/08 4:09 PM,,4.0,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","I had IGNORE_CASE set to true and had:
 
 <ON: ""ON"">
 ...
 
 and in the bnf:
 
 ""on"" ""error""
 
 that resulted in ""On"" being recognized as an ID, not ON.
 
 Workaround: Just use all lower case for all the keywords.",,,,,,,,0|i07g47:,,,,,43436,,,169
javacc,JAVACC-168,JavaCC is not BSD licensed,Bug,Closed,Blocker,Fixed,sreeni,robertburrelldonkin,robertburrelldonkin,29/Sep/07 3:54 AM,,02/Sep/08 2:18 AM,02/Sep/08 2:18 AM,4.0,4.1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All
 URL: http://www.jroller.com/robertburrelldonkin/entry/javacc_version_4_0_is","The license found in the JavaCC download is not BSD. It contains an additional
 clause which contains a fields of endeavour restriction incompatable with the
 open source definition.
 
 This can be fixed by removing the word 'licensed' from the final paragraph.",,,,,,,,0|i0fd07:,,,,,89588,,,168
javacc,JAVACC-167,Parsing Error in javacc,Bug,Closed,Blocker,Incomplete,sreeni,balasankarnitin,balasankarnitin,14/Sep/07 3:32 AM,,14/Jun/09 9:37 AM,14/Jun/09 9:37 AM,4.0,milestone 1,parser generator,,2,0,,,,,,,,"Operating System: All
 Platform: All","Hi,
 
 
 I got a parsing error. This is the error(Error modifying the page Encountered
 ""dd"" at line 14, column 63. Was expecting one of: "","" ... ""}""). I'm trying to
 use escape character within double quotes. That time i got this error, i
 couldn't solve this problem please advise me.
 
 Thanks in advance,
 Balasankar.",,,,,,,,0|i0ggnr:,,,,,96012,,,167
javacc,JAVACC-166,JAVACODE nonterminals in choice-points,Bug,Open,Major,Unresolved,paulcager,incubos,incubos,12/Sep/07 9:36 AM,,25/Nov/10 6:52 PM,,4.0,milestone 1,parser generator,,0,0,,,,,,,JAVACC-136,"Operating System: All
 Platform: All","There is no warning when JAVACODE nonterminal is present in a choice-point --
 user would like to see such warning",,,,,,,,0|i0fnzz:,,,,,91369,,,166
javacc,JAVACC-165,Java 1.5 internal code,Improvement,Closed,Major,Fixed,tcopeland,brianegge,brianegge,06/Sep/07 10:51 PM,,02/Sep/08 2:15 AM,02/Sep/08 2:15 AM,current,4.1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Here's a patch for the DfaState class which introduces Java 1.5 constructs. I
 didn't change the types from Hashtables to HashMaps or Vectors to ArrayLists
 because most of the fields are public static, and I didn't want to have to
 change other classes right now. 
 
 I don't know if the dev mailing list handles attachments, so I figured I would
 create a new issue.",,,,,,,,0|i031t3:,,,,,17790,,,165
javacc,JAVACC-164,Add option for line ending,Improvement,Open,Trivial,Unresolved,sreeni,tcopeland,tcopeland,29/Jun/07 7:02 AM,,29/Jun/07 7:02 AM,,4.0,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Per a thread started by Dale Anson on javacc-users, it'd be nice to have a new
 option added to JavaCC that allowed the user to specify what line ending to use
 when generating code. Currently we use the platform default - so a parser
 generated on Windows has ""\r\n"" as the line ending and a parser generated on
 Unix has a ""\n"" line ending. This behavior is fine 99% of the time, but
 sometimes we may want to force a particular line ending.
 
 This is a low priority item; just wanted to get it recorded here so it wasn't
 lost in the list archives.",,,,,,,,0|i0dbz3:,,,,,77757,,,164
javacc,JAVACC-163,Lookahead tutorial contains an error,Bug,Closed,Major,Incomplete,tcopeland,inkinwater,inkinwater,04/May/07 11:50 AM,,05/May/12 5:39 PM,14/Jun/09 9:37 AM,4.0,milestone 1,general,,0,1,,,,,,,,"Operating System: All
 Platform: All","Hi, I found an error in the Lookahead mini tutorial. In the example 
 
 	void BC() :
 	{}
 	{
 	 ""b""
 	 [ LOOKAHEAD( { getToken(1).kind == C && getToken(2).kind != C } )
 	 <C:""c"">
 	 ]
 	}
 
 I think LOOKAHEAD statement should be 
 
 LOOKAHEAD( { getToken(1).kind == C && getToken(2).kind == C } )
 
 Thanks!
 
 Jiao",,,,,,,,0|i01mtj:,,,,,9530,,,163
javacc,JAVACC-162,Use of semantic lookahead leads to compile error with recursing lookahead,Bug,Open,Major,Unresolved,sreeni,samcinty,samcinty,21/Apr/07 10:57 PM,,07/Nov/07 4:19 PM,,4.0,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","The Apache Derby project recently ran into an issue where use of multiple levels of lookahead in a 
 production which includes another production that uses semantic lookahead in one of its choices leads to 
 a compile error. The production using semantic lookahead makes use of a variable passed-in as a 
 parameter to the production. JavaCC generates a grammar without warnings or errors for this grammar, 
 but it fails to compile because the passed-in parameter is not available to the method that is split out of 
 the production for the choice using semantic lookahead which requires the variable.
 
 Attaching a simplified grammar which demonstrates the problem. A workaround was used which confined 
 the choices in the outermost production to use semantic lookahead to avoid multiple levels of lookahead 
 into the later production.",,,,,,,,0|i0dao7:,,,,,77546,,,162
javacc,JAVACC-161,Handling of '\\' when it's the last character in the file,Bug,Closed,Major,Fixed,sreeni,doogie,doogie,31/Mar/07 12:32 PM,,02/Sep/08 2:13 AM,02/Sep/08 2:13 AM,4.0,4.1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","There is an off-by-one error in the JavaCharStream(which is used when unicode
 processing is turned on), when the end of the file(the last character) is '\\'.
 Please see the attachments(small grammar, test file, and patch).",,,,,,,,0|i0ecqv:,,,,,83714,,,161
javacc,JAVACC-160,The jjtAccept methods should allow a way of specifying what the type of data object is.,Improvement,Closed,Major,Fixed,paulcager,pwagland,pwagland,14/Mar/07 5:12 AM,,02/Sep/08 2:10 AM,02/Sep/08 2:10 AM,4.0,4.1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: Macintosh","In my project, we know what the type of the data is, so we have a
 post-processing rule to convert ""Object data"" to ""OurObject data"". Ideally there
 would be a processing option:
 
 VISITOR_DATA_TYPE=com.company.OurObject",,,,,,,,0|i01wmv:,,,,,11120,,,160
javacc,JAVACC-159,"Don't use Stack anymore, as it is synchronised",Improvement,Closed,Major,Fixed,tcopeland,pwagland,pwagland,13/Mar/07 7:13 AM,,02/Sep/08 2:09 AM,02/Sep/08 2:09 AM,4.0,4.1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: Macintosh","Since the parser is not re-entrant anyway, there is no need to have the
 synchronisation in place, since it just adds unneeded synchronisation overhead.",,,,,,,,0|i0d9wn:,,,,,77422,,,159
javacc,JAVACC-158,Remove uneccessary cast from generateParseException when generating for Java 1.5,Improvement,Closed,Major,Fixed,tcopeland,pwagland,pwagland,13/Mar/07 6:35 AM,,02/Sep/08 2:07 AM,02/Sep/08 2:07 AM,4.0,4.1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: Macintosh","In eclipse it is possible to make it complain about unnecessary casts, when this
 is on, there are is one complaint in generateParseException, since it casts an
 int[] to an int[], since the Vector has been made a generic with int[] as it's
 argument.",,,,,,,,0|i02vcn:,,,,,16744,,,158
javacc,JAVACC-157,Minor optimisation for add_error_token,Task,Closed,Major,Fixed,sreeni,pwagland,pwagland,13/Mar/07 6:08 AM,,02/Sep/08 2:04 AM,02/Sep/08 2:04 AM,4.0,4.1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: Macintosh","This patch saves (a measly) 10 bytes in the generated class size, and slightly
 decreases the work that needs to be done, since exists will be set either once
 or twice, instead of 2*loop iterations.
 
 ------------------
 
 --- javacc/src/org/javacc/parser/ParseGen.java 2005-12-23 02:19:54.000000000 +0100
 +++ javacc.n/src/org/javacc/parser/ParseGen.java 2007-03-13
 13:38:42.000000000 +0100
 @@ -505,17 +505,16 @@
 ostr.println("" jj_expentry[i] = jj_lasttokens[i];"");
 ostr.println("" }"");
 ostr.println("" boolean exists = false;"");
 - ostr.println("" for (java.util.Enumeration e =
 jj_expentries.elements(); e.hasMoreElements();) {"");
 + ostr.println("" outerloop: for (java.util.Enumeration e =
 jj_expentries.elements(); e.hasMoreElements();) {"");
 ostr.println("" int[] oldentry = (int[])(e.nextElement());"");
 ostr.println("" if (oldentry.length == jj_expentry.length) {"");
 - ostr.println("" exists = true;"");
 ostr.println("" for (int i = 0; i < jj_expentry.length; i++) {"");
 ostr.println("" if (oldentry[i] != jj_expentry[i]) {"");
 - ostr.println("" exists = false;"");
 - ostr.println("" break;"");
 + ostr.println("" continue outerloop;"");
 ostr.println("" }"");
 ostr.println("" }"");
 - ostr.println("" if (exists) break;"");
 + ostr.println("" exists = true;"");
 + ostr.println("" break;"");
 ostr.println("" }"");
 ostr.println("" }"");
 ostr.println("" if (!exists)
 jj_expentries.addElement(jj_expentry);"");",,,,,,,,0|i0ee0v:,,,,,83921,,,157
javacc,JAVACC-156,jj_expentries is a java.util.Vector,Improvement,Resolved,Minor,Fixed,sreeni,pwagland,pwagland,13/Mar/07 5:06 AM,,02/Sep/08 2:04 AM,02/Sep/08 2:04 AM,4.0,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: Macintosh","Further, since it is used in two separate methods the synchronisation cannot be
 removed, even by Java 6. Further, the class is not used in a thread safe manner
 anyway, since if it was called by two callers at the same time, one of them
 would get a ConcurrentModificationException.
 
 For the above reasons, I think that jj_expentries should be an ArrayList, not a
 Vector.
 
 I believe that there are other Vectors that can also be generated (although not
 in my project), these should probably also be converted over to ArrayList as well.",,,,,,,,0|i09t4v:,,,,,57209,,,156
javacc,JAVACC-155,Wrong token recognition when using mixed case and IGNORE_CASE = true,Bug,Open,Critical,Unresolved,sreeni,oleg_,oleg_,09/Feb/07 11:09 AM,,04/Nov/07 3:29 PM,,4.0,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: Windows XP
 Platform: All","The following example shows wrong token recognition:
 
 options{
 IGNORE_CASE = true;
 STATIC = false;
 DEBUG_TOKEN_MANAGER = true;
 }
 
 PARSER_BEGIN(TestParser)
 
 import java.io.*;
 
 public class TestParser
 {
 public static void main(String args[]) throws ParseException {
 try {
 String str = ""a aa"";
 
 TestParser vp = new TestParser(new StringReader(str));
 vp.parse();
 
 } catch(Exception ex) {
 ex.printStackTrace();
 }
 } // main ends here
 }
 
 PARSER_END(TestParser)
 
 SKIP:
 {
 "" ""
 | ""\t""
 | ""\r""
 | ""\n""
 }
 
 TOKEN:
 {
 <A:""a""> |
 <AB:""Ab""> | // Token recognition works correctly if 
 // this line reads <AB: ""ab""> | 
 <MULT_A:(""a"")+> 
 }
 
 
 void parse():
 {}
 {
 <A> <MULT_A>
 }
 
 The printout is:
 
 C:\test-java\parser>c:\java\j2sdk1.4.2_09\bin\java TestParser
 Current character : a (97)
 Currently matched the first 1 characters as a ""a"" token.
 Possible string literal matches : { ""Ab"" }
 Current character : (32)
 No string literal matches possible.
 No more string literal token matches are possible.
 Starting NFA to match one of : { <MULT_A> }
 Current character : (32)
 Currently matched the first 1 characters as a <MULT_A> token.
 Putting back 1 characters into the input stream.
 ****** FOUND A <MULT_A> MATCH (a) ******
 
 ParseException: Encountered ""a"" at line 1, column 1.
 Was expecting:
 ""a"" ...
 
 at TestParser.generateParseException(TestParser.java:160)
 at TestParser.jj_consume_token(TestParser.java:99)
 at TestParser.parse(TestParser.java:18)
 at TestParser.main(TestParser.java:10)",,,,,,,,0|i03vf3:,,,,,22587,,,155
javacc,JAVACC-154,Implement intersection,Improvement,Open,Major,Unresolved,sreeni,tcopeland,tcopeland,22/Jan/07 1:49 PM,,22/Jan/07 1:52 PM,,4.0,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Implement intersection, e.g. in Java regular expressions you can write
 [0-9&&[345]]
 to match any character that is common to the sets [0-9] and [345]. The
 notation
 [0-9&&[3-5]]
 is equivalent.",,,,,,,,0|i031e7:,,,,,17723,,,154
javacc,JAVACC-153,Allow use of Java's \p regexp classes,Improvement,Open,Major,Unresolved,sreeni,tcopeland,tcopeland,22/Jan/07 1:48 PM,,24/Jan/07 3:03 PM,,4.0,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","It has been proposed to expose, within JavaCC, Java's own methods and
 syntax for specifying classes/types of Unicode char,
 e.g. in regular expressions (see
 http://www.regular-expressions.info/unicode.html)
 
 \p{L} or \p{Letter}
 
 matches any single char, from any script, that Unicode designates as a ""Letter"".
 
 Similarly,
 
 \p{Lowercase_Letter} \p{Uppercase_Letter}
 \p{Non_Spacing_Mark} (for combining diacritics)
 \p{Number}
 \p{Punctuation}
 
 and many more. \P{Letter}, using an uppercase P, matches any single char
 that is _not_ a Letter.",,,,,,,,0|i039jr:,,,,,19044,,,153
javacc,JAVACC-152,LOOKAHEAD does not clear the flag when an exception occurs within the block,Bug,Closed,Major,Fixed,paulcager,mnirhali,mnirhali,18/Jan/07 7:11 PM,,02/Sep/08 2:03 AM,02/Sep/08 2:03 AM,4.0,4.1,parser generator,,1,0,,,,,,,,"Operating System: All
 Platform: All","https://issues.apache.org/jira/browse/DERBY-2103
 
 On the apache derby project we hit the case where within LOOKAHEAD block, if an
 exception occurs, the lookahead flag is not cleared. 
 
 The code generated by the parser wraps this block with setting lookahead flag to
 true before the block and unsetting it after tge block. If the exception occurs
 within the flag, the flag should still be cleared.
 
 A work around may exist in the application, but I think this should be handled
 by javacc itself.",,,,,,,,0|i0216n:,,,,,11857,,,152
javacc,JAVACC-151,Unicode 3.1 non-BMP characters not supported,Bug,Open,Major,Unresolved,sreeni,tcopeland,tcopeland,02/Jan/07 1:35 PM,,02/Jan/07 1:35 PM,,4.0,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","This is just to make sure we have this on the radar. Unicode 3.1 (and Java 1.5)
 introduced characters outside the BMP; e.g., they require up to 21 bits per
 character vs 16. The ""\u"" escaping mechanism only support 4 hex characters, so
 a JavaCharStream can't decode these. I'm not sure what else would be involved.
 
 There's a post about this on the list here:
 
 https://javacc.dev.java.net/servlets/ReadMsg?list=users&msgNo=810
 
 It's about modifying JavaCC's Java grammar so that it accepts these characters
 as valid Java identifiers.",,,,,,,,0|i06uuv:,,,,,39992,,,151
javacc,JAVACC-150,Token manager crash,Bug,Closed,Major,Incomplete,sreeni,nbs51,nbs51,23/Dec/06 3:32 PM,,14/Jun/09 9:36 AM,14/Jun/09 9:36 AM,4.0,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All",the generated lex scanner crashes on char == \u201c,,,,,,,,0|i0beh3:,to be closed,,,,66498,,,150
javacc,JAVACC-149,NODE_PACKAGE produces uncompilable code,Bug,Closed,Major,Fixed,paulcager,ejp,ejp,20/Dec/06 11:44 PM,,02/Sep/08 2:02 AM,02/Sep/08 2:02 AM,4.0,4.1,jjtree,,0,1,,,,,,,,"Operating System: All
 Platform: All","Is the NODE_PACKAGE option supposed to be usable to place the generated node
 classes into a different package from the package named in the PARSER_BEGIN
 block of the .jjt file?
 
 Consider the case where Java.jjt contains both
 NODE_PACKAGE=""com.ejp.scripts.tree' in the OPTIONS block and 'package
 com.ejp.scripts.java' in the PARSER_BEGIN block.
 
 If I do this, the generated node files don't have an import statement for
 'com.ejp.scripts.java.*', so they can't find the JavaParser class defined by the
 .jjt file.
 
 I have my reasons for doing this, Watson. I'd just like to know if this is
 supposed to work. I don't mind if you tell me I'm crazy instead!",,,,,,,,0|i0fto7:,,,,,92288,,,149
javacc,JAVACC-148,OUTPUT_DIRECTORY not copied from .jjt to .jj,Bug,Closed,Major,Fixed,paulcager,tcopeland,tcopeland,01/Nov/06 7:53 PM,,02/Sep/08 2:01 AM,02/Sep/08 2:01 AM,4.0,4.1,jjtree,,1,0,,,,,,,,"Operating System: All
 Platform: All","OUTPUT_DIRECTORY not copied from .jjt to .jj, seems like it should be.",,,,,,,,0|i07vlj:,,,,,45944,,,148
javacc,JAVACC-147,Add access to token's image from JJTree (language extension),Improvement,Reopened,Major,Unresolved,sreeni,saquigley,saquigley,28/Oct/06 9:25 PM,,25/Nov/10 6:52 PM,,4.0,milestone 1,jjtree,,0,0,,,,,,,"JAVACC-146, JAVACC-170","Operating System: All
 Platform: All","This request depends on issue 146.
 
 If you decide to implement #146, then programmers can add ""nodify"" tokens to put
 them into ASTs as so:
 
 void string_literal () :
 {Token t;}
 { t=<STRINGLITERAL> 
 {jjtThis.jjtSetToken(t);}
 }
 
 It would be even more user-friendly to build this mechanism into jjtree by
 providing a special jjtree keyword like #token that programmers could use to
 indicate that a token should be turned into an AST node. For example, the above
 function could be replaced by something like:
 
 void string_literal () #token:
 {} { <STRINGLITERAL> }",,,,,,,,0|i03cjj:,,,,,19529,,,147
javacc,JAVACC-146,Adding tokens to ASTs,Improvement,Closed,Major,Fixed,paulcager,saquigley,saquigley,28/Oct/06 9:11 PM,,25/Nov/10 6:52 PM,02/Sep/08 1:57 AM,4.0,4.1,jjtree,,0,0,,,,,,,JAVACC-147,"Operating System: All
 Platform: All","I have been looking through the jjtree documentation, jjtree examples, and
 source code for a simple way to ""nodify"" tokens such as identifiers and literals
 so they can be easily integrated into ASTs and I have not found anything.
 
 So I modified SimpleNode to include an extra field token of type Token, with a
 new constructor, and set and get methods. I also modified the dump method to
 print out token if the node has no children but has a token.
 
 With these modifications, one can nodify a literal (or any other maningful
 token) as follows:
 
 void string_literal () :
 {Token t;}
 { t=<STRINGLITERAL> 
 {jjtThis.jjtSetToken(t);}
 }
 
 I am attaching SimpleNode.java. The modified code is surrounded by comments.
 It works.",,,,,,,,0|i0akuf:,,,,,61698,,,146
javacc,JAVACC-145,Problems with option JJTREE_OUTPUT_DIRECTORY,Bug,Closed,Major,Fixed,sreeni,saquigley,saquigley,28/Oct/06 1:58 PM,,02/Sep/08 1:50 AM,02/Sep/08 1:50 AM,4.0,4.1,jjtree,,0,0,,,,,,,,"Operating System: Linux
 Platform: All","Here are 2 minor problems I encountered with the JJTREE_OUTPUT_DIRECTORY option:
 
 1) JJTREE_OUTPUT_DIRECTORY does not work on the command line
 ------------------------------------------------------------
 The command:
 jjtree -MULTI=true -VISITOR=true -JJTREE_OUTPUT_DIRECTORY=AST Parser.jjt
 
 Produces:
 
 Java Compiler Compiler Version 4.0 (Tree Builder)
 (type ""jjtree"" with no arguments for help)
 Argument ""JJTREE_OUTPUT_DIRECTORY=AST"" must be an option setting.
 make: *** [Parser.class] Error 1
 
 I think that the best approach would be to make this option work on the command
 line like the other options. If that is not possible, I would suggest
 indicating in the documentation that this option only works in the JavaCC
 options statement.
 
 2) JJTREE_OUTPUT_DIRECTORY in JavaCC options statement no quite right either
 ----------------------------------------------------------------------------
 I then moved the option into in the JavaCC options statement of my .jjt file:
 JJTREE_OUTPUT_DIRECTORY=""AST"";
 and this properly generated the AST classes in the AST directory as specified. 
 
 However, JavaCC also printed this warning message:
 
 Java Compiler Compiler Version 4.0 (Parser Generator)
 (type ""javacc"" with no arguments for help)
 Reading from file Parser.jj . . .
 Warning: Line 3, Column 3: Bad option name ""JJTREE_OUTPUT_DIRECTORY"". Option
 setting will be ignored.
 
 As far as I can tell JJTREE_OUTPUT_DIRECTORY is actually working properly, so
 this warning should be suppressed.",,,,,,,,0|i08g6n:,,,,,49279,,,145
javacc,JAVACC-144,Error line string in TokenMgrError and ParseException,Improvement,Open,Major,Unresolved,sreeni,saquigley,saquigley,28/Oct/06 9:37 AM,,28/Oct/06 9:37 AM,,4.0,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","I am glad to see that TokenMgrError will become an exception rather than an
 error because it will simplify error recovery a great deal!
 
 TokenMgrException and ParseException would be much more user-friendly if they
 contained easily accessible variables with information that could be used to
 generate different error messages than the default one:
 - errorline: currently found in currentToken.next.beginLine
 - errorcolumn: currently found in currentToken.next.beginColumn
 - linestring: the entire string of the line where the error occurs
 
 This way, getMessage could be rewritten to (for example), show the line with the
 problem with a marker under the token where the error occurs, and then the error
 message. E.g. 
 
 Error in line x:
 blah blah blah blih blah blah blah
 ^
 Expected ""blah""
 
 Thank you.",,,,,,,,0|i0agj3:,,,,,60999,,,144
javacc,JAVACC-143,jjDoc does not show help,Bug,Closed,Trivial,Fixed,sreeni,mattze,mattze,26/Oct/06 2:16 AM,,02/Sep/08 1:44 AM,02/Sep/08 1:44 AM,4.0,4.1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","when invoking ""jjDoc"" w/o command line parameters, the help message won't show 
 up.
 
 In JJDocMain.help_message() a ostr.flush() at the end did fix this for me.",,,,,,,,0|i0fc9z:,,,,,89470,,,143
javacc,JAVACC-142,"""jjtree -NODE_USES_PARSER"" gives a ""bad option"" warning",Bug,Closed,Major,Fixed,paulcager,tcopeland,tcopeland,24/Oct/06 6:20 AM,,02/Sep/08 1:43 AM,02/Sep/08 1:43 AM,4.0,4.1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","It seems like JJTree doesn't recognize some boolean options in the same way
 that JavaCC does. For example, ""jjtree -NODE_USES_PARSER"" results in a
 ""bad option"" warning:
 
 ===================
 $ jjtree -node_uses_parser c.jjt
 Java Compiler Compiler Version 4.0 (Tree Builder)
 (type ""jjtree"" with no arguments for help)
 Warning: Bad option ""-node_uses_parser"" will be ignored.
 [...]
 ===================
 
 But with ""jjtree -NODE_USES_PARSER=true"", all's well:
 
 ===================
 $ jjtree -node_uses_parser=true c.jjt
 Java Compiler Compiler Version 4.0 (Tree Builder)
 (type ""jjtree"" with no arguments for help)
 Reading from file c.jjt . . .
 Annotated grammar generated successfully in ./c.jj
 ===================",,,,,,,,0|i07t93:,,,,,45564,,,142
javacc,JAVACC-141,jjFillToken not OOP makes it hard to subclass Token,Improvement,Closed,Major,Fixed,paulcager,saquigley,saquigley,22/Oct/06 4:23 PM,,25/Nov/10 6:52 PM,02/Sep/08 1:42 AM,4.0,4.1,scanner generator,,0,0,,,,,,,JAVACC-170,"Operating System: All
 Platform: All","jjFillToken uses a constructor with only kind as parameters and then fills in
 the token details by changing all the token fields directly one by one. 
 
 To follow good OOP practice, it would have been preferable to use a constructor
 with parameters for all the values that are changed after the construction:kind,
 image, beginLine, beginColumn, endLine, endColumn.
 
 If this were only about style, I would not bother reporting this issue. 
 However, the current coding of jjFillToken makes it very hard to create
 subclasses of Token for special-purpose tokens which also contain a value
 separate from the image field, in particular number, character and string
 literals. If the constructor used had all this information in the parameters,
 then newToken could switch on kind, and pass all the information to the
 subclasses, which would just call super and then calculate the value. As it is
 now, the values can not be created at construction time because the token is
 empty. Therefore the values have to be computed the first time they are
 requested, which could be in toString or getValue. Also to be efficient, you
 need to use flags to only calculate the value once. This is not good.
 
 I did not ask to have modification perms, but I certainly know how to fix this
 problem; so I could provide fixes (a new Token.java and a new jjFillToken) if
 you are interested.",,,,,,,,0|i0evhr:,,,,,86751,,,141
javacc,JAVACC-140,patch to remove pmd warnings in generated code,Task,Closed,Minor,Fixed,sreeni,brittanysoftware,brittanysoftware,02/Oct/06 7:20 PM,,02/Sep/08 1:41 AM,02/Sep/08 1:41 AM,current,4.1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","The attached patch replaces
 
 sb.append("" "") -> sb.append(' ')
 
 and
 
 return (c) -> return c
 
 in the generated code. Both constructs generate warnings when pmd is run on the
 generated code.
 
 The append change is also done on two example classes.
 
 Xavier",,,,,,,,0|i0d5fr:,,,,,76698,,,140
javacc,JAVACC-139,NODE_PACKAGE should be appended to OUTPUT_DIRECTORY for jjtree,Improvement,Open,Major,Unresolved,sreeni,mat007,mat007,01/Oct/06 6:06 PM,,21/Oct/07 1:09 PM,,4.0,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","For javacc having :
 
 options
 {
 OUTPUT_DIRECTORY = ""directory""
 }
 
 PARSER_BEGIN(Parser)
 package my.package;
 ...
 PARSER_END(Parser)
 
 Generated files are created in ""directory/my/package"".
 
 However for jjtree :
 
 options
 {
 OUTPUT_DIRECTORY = ""directory""
 NODE_PACKAGE = ""my.package""
 }
 
 Generated files get created in ""directory"" and not in ""directory/my/package"".
 In order to have the files created in the proper directory the OUTPUT_DIRECTORY
 should be :
 
 OUTPUT_DIRECTORY = ""directory/my/package""
 
 This does not seem very consistent, maybe NODE_PACKAGE should be appended to
 OUTPUT_DIRECTORY for jjtree.",,,,,,,,0|i059in:,,,,,30703,,,139
javacc,JAVACC-138,error while compiling java programs,Bug,Closed,Major,Incomplete,sreeni,guru_prasanna,guru_prasanna,14/Sep/06 3:23 AM,,14/Jun/09 9:36 AM,14/Jun/09 9:36 AM,4.0,milestone 1,general,,0,0,,,,,,,,"Operating System: Windows XP
 Platform: All","Hi,
 
 I am new to java world. I have created a grammar definition. After executing
 javacc with my definition file. I am compiling the with javac *.java. the javac
 compiler gives me following errors,
 
 C:\guru\ejjbasic>javac *.java
 Note: eJJbasic.java uses unchecked or unsafe operati
 Note: Recompile with -Xlint:unchecked for details.
 
 C:\guru\ejjbasic>javac -Xlint *.java
 eJJbasic.java:1996: warning: [serial] serializable class eJJbasic.LookaheadSucce
 ss has no definition of serialVersionUID
 static private final class LookaheadSuccess extends java.lang.Error { }
 ^
 eJJbasic.java:2072: warning: [unchecked] unchecked call to addElement(E) as a me
 mber of the raw type java.util.Vector
 if (!exists) jj_expentries.addElement(jj_expentry);
 ^
 eJJbasic.java:2148: warning: [unchecked] unchecked call to addElement(E) as a me
 mber of the raw type java.util.Vector
 jj_expentries.addElement(jj_expentry);
 ^
 ParseException.java:11: warning: [serial] serializable class ParseException has
 no definition of serialVersionUID
 public class ParseException extends Exception {
 ^
 SimpleCharStream.java:204: warning: [dep-ann] deprecated item is not annotated w
 ith @Deprecated
 static public int getColumn() {
 ^
 SimpleCharStream.java:213: warning: [dep-ann] deprecated item is not annotated w
 ith @Deprecated
 static public int getLine() {
 ^
 TokenMgrError.java:2: warning: [serial] serializable class TokenMgrError has no
 definition of serialVersionUID
 public class TokenMgrError extends Error
 ^
 7 warnings
 
 
 My version for javacc and javac are as follows,
 
 C:\guru\ejjbasic>javac -version
 javac 1.6.0-beta2
 
 C:\guru\ejjbasic>javacc
 Java Compiler Compiler Version 4.0 (Parser Generator)
 
 
 From the error messages I understand that classes generated by javacc is no more
 valid in the new version of java. So I would like to know whether javacc will
 have new releases whic will be compatible with newer version of java or not. Or
 am I doing something wrong?
 
 guru",,,,,,,,0|i08htz:,,,,,49546,,,138
javacc,JAVACC-137,index.html in 4.0 lists incorrect current version,Bug,Closed,Trivial,Fixed,sreeni,patrods1,patrods1,25/Aug/06 6:02 AM,,02/Sep/08 1:39 AM,02/Sep/08 1:39 AM,4.0,4.1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","The file doc/index.html in the 4.0 release states:
 
 ""Our latest release of JavaCC is Version 3.2.""",,,,,,,,0|i0dl2v:,,,,,79232,,,137
javacc,JAVACC-136,"""Multiple Optional OR"" with JavaCode : no loop break",Bug,Closed,Major,Fixed,sreeni,obuchwal,obuchwal,08/Aug/06 1:24 AM,,25/Nov/10 6:52 PM,02/Sep/08 1:33 AM,4.0,4.1,parser generator,,0,0,,,,,,,JAVACC-166,"Operating System: Mac OS X
 Platform: Macintosh","I'm using JAVACC 4.0 and I founded a problem with the generation of the parser with ""Multiple optional 
 OR"" production, such as:
 
 (A | B | LOOKAHEAD( ... ) JAVACODE_METHOD() )*
 
 The produced code contain a loop ""while"" with the correct entries, but the breaking code at the beginning 
 of the loop is not inserted when one of the entry contain a javacode method (even with a lookahead).
 Thus the produced java is not valid because the instruction after the loop is not reachable.
 
 Best regards",,,,,,,,0|i0fi2v:,,,,,90410,,,136
javacc,JAVACC-135,"Generated prologue comments include filenames containing ""\u"" which leads to lexical errors.",Bug,Closed,Major,Fixed,paulcager,ekmek,ekmek,07/Aug/06 7:08 AM,,29/Nov/08 3:23 AM,29/Nov/08 3:23 AM,4.0,4.2,jjtree,,1,0,,,,,,,,"Operating System: Windows XP
 Platform: All","This issue describes the same behaviour as in Issue 81, generated files in
 subdirectories starting with the letter ""u"", get a comment in their header with
 illegal unicode escapes on windows (as it uses backslashes as directory separators).
 
 sreeni stated that this bug is fixed in javacc-4.0 with the function
 ""addUnicodeEscape()"" for filenames. This is wrong, javacc-4.0 still shows the
 same behaviour, as the stated function is plain useless for the given case. This
 function only replaces chars with values less than 0x20 or greater than 0x7e
 with a correct unicode-representatiuon. This has nothing to do with the issue
 itself. The bug arises, as the combination \u (happens for example if the
 jjt-file lies in a util-package) just consists of regular ASCII-characters, an
 as such wont' get replaced by ""addUnicodeEscape()"".
 
 This wouldn't be a great deal, if it wasn't written to a file and then get
 parsed by the java-compiler as a unicode escape (\u), illegally followed by
 letters (as in util). A simple fix would be, to use the slash instead as a
 separator, as java woll work with both ways on windows.
 
 Please fix this bug, as it makes it impossible to set up projects with an
 automated ant-buildfile where parser-files are stored in an util-package (or any
 directory where the absolute path contains a directory starting with a ""u""). I
 guess there are more people out there, which spend hours to puzzle out why their
 parser generation is breaking, and propably won't find this bug report.
 
 With kind regards,
 Tobias",,,,,,,,0|i0dabr:,,,,,77490,,,135
javacc,JAVACC-134,Removing vestiges of OPTIMIZE_TOKEN_MANAGER,Task,Closed,Major,Fixed,tcopeland,tcopeland,tcopeland,14/Jul/06 8:41 PM,,02/Sep/08 1:31 AM,02/Sep/08 1:31 AM,4.0,4.1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Here's the little patch to fix; I'll wait for a couple days to ensure no one
 objects and then apply it:
 
 Index: src/org/javacc/parser/Main.java
 ===================================================================
 RCS file: /cvs/javacc/src/org/javacc/parser/Main.java,v
 retrieving revision 1.5
 diff -r1.5 Main.java
 55d54
 < System.out.println("" OPTIMIZE_TOKEN_MANAGER (default true)"");
 Index: www/doc/commandline.html
 ===================================================================
 RCS file: /cvs/javacc/www/doc/commandline.html,v
 retrieving revision 1.2
 diff -r1.2 commandline.html
 67d66
 < OPTIMIZE_TOKEN_MANAGER (default true)
 Index: www/doc/javaccgrm.html
 ===================================================================
 RCS file: /cvs/javacc/www/doc/javaccgrm.html,v
 retrieving revision 1.6
 diff -r1.6 javaccgrm.html
 257,260d256
 < <TD ALIGN=LEFT VALIGN=BASELINE>""OPTIMIZE_TOKEN_MANAGER"" ""=""
 <EM>java_boolean_literal</EM> "";""</TD>
 < </TR>
 < <TR>
 < <TD></TD><TD ALIGN=CENTER VALIGN=BASELINE>|</TD>",,,,,,,,0|i06oiv:,,,,,38966,,,134
javacc,JAVACC-133,JDK_VERSION and StringBuilder,Improvement,Closed,Major,Fixed,sreeni,tcopeland,tcopeland,10/Jul/06 2:31 PM,,02/Sep/08 1:31 AM,02/Sep/08 1:31 AM,4.0,4.1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Using StringBuilder vs StringBuffer would be a nice JDK_VERSION=1.5
 optimization. Just recording this for possible future efforts...",,,,,,,,0|i088rj:,,,,,48077,,,133
javacc,JAVACC-132,Provide PDF format of all JavaCC documentation.,Improvement,Open,Major,Unresolved,sreeni,colbertphilippe,colbertphilippe,14/Jun/06 7:51 AM,,16/Oct/07 4:16 PM,,4.0,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","One of the difficulties in learning/teaching JavaCC is a lack of printed 
 material or an eletronic format that can be printed. I would suggest that you 
 provide the Adobe PDF format for all documentation. The PDF format can be 
 printed and provide printed material.",,,,,,,,0|i06duv:,,,,,37238,,,132
javacc,JAVACC-131,facing problem using lexical states in javacc,Bug,Closed,Major,Incomplete,sreeni,arshika,arshika,12/Jun/06 6:05 AM,,14/Jun/09 9:36 AM,14/Jun/09 9:36 AM,4.0,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Hello,
 
 I m facing a problem in parsing a file through javacc.
 In the following example, a token INT is defined, and another token ANYCHAR is 
 also defined which is more generalised than INT, but if anything matches with 
 INT in place of ANYCHAR,then it is taken as INT only, and error is given.
 
 TOKEN:{
 | < INT : ( <DIGIT> )+ >
 | < #DIGIT : [""0"" - ""9""] >
 | < ANYCHAR:([""A""-""Z"",""a""-""z"",""0""-""9"",""=""]+>
 }
 
 Now , for example, if 15 is encountered where ANYCHAR is expected, it gives an 
 error.Can Lexical states help in this?But there is no specific token for 
 defining a lexical state in this context.
 
 Kindly, give some possible solution as soon as possible..",,,,,,,,0|i0atnb:,,,,,63124,,,131
javacc,JAVACC-130,Incorrect parser generated for JDK 1.2 and 1.3,Bug,Closed,Major,Fixed,sreeni,iceman_k,iceman_k,31/May/06 9:31 PM,,02/Sep/08 1:29 AM,02/Sep/08 1:29 AM,4.0,4.1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","According to the documentation, JDK 1.2 and above are supported.
 However, the generated parser contains the new RuntimeException(Exception e) 
 constructor, which is not valid for JDK 1.2 and 1.3.",,,,,,,,0|i0d23r:,,,,,76158,,,130
javacc,JAVACC-129,OUTPUT_FILE seems to be ignored when specified in *.jjt file,Bug,Closed,Major,Fixed,sreeni,zaskar,zaskar,23/May/06 8:16 AM,,02/Sep/08 1:28 AM,02/Sep/08 1:28 AM,4.0,4.1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","The option OUTPUT_FILE seems to be ignored by JJTree when it is specified in 
 the *.jjt file instead of the command line.",,,,,,,,0|i0ac33:,,,,,60279,,,129
javacc,JAVACC-128,JJTREE_OUTPUT_DIRECTORY is copied to *.jj file,Bug,Closed,Trivial,Fixed,sreeni,zaskar,zaskar,23/May/06 8:14 AM,,02/Sep/08 1:28 AM,02/Sep/08 1:28 AM,4.0,4.1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","When the JJTREE_OUTPUT_DIRECTORY option is set in a *.jjt file, it is copied to 
 the generated *.jj file. This causes JavaCC to display a warning.",,,,,,,,0|i0dtqf:,,,,,80634,,,128
javacc,JAVACC-127,Bugfix patch for Parser debugInfo indent,Bug,Open,Major,Unresolved,sreeni,guf,guf,17/May/06 5:14 AM,,16/Jan/08 2:41 PM,,4.0,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Hi
 I have found a bug with the parser debug output where the indent is not reset
 correctly when a lookahead bails out and normal calling continues.
 
 I have searched here and not found a fix for it, (but I did find a speed-up
 patch by doogie, which I incorporated into my patch also), so I am posting this.
 
 It does 3 things:
 - incorporates doogie's change to use StringBuffers rather than println("" "") loops.
 - fixes the indent when it detects a lookahead bailout
 - notices when a ParserException is being thrown and changes ""Return:"" to
 ""Bailout:""
 
 That last one is a bit of a hack - rather than catch and re-throw the exception
 as a mechanism to notice it, I simply set a static flag on ParserException when
 it's constructors are called, and in the Parser debug method trace_return() I
 check that flag, and if it's true, I assume the call to this method is in a
 finally clause being run because the newly created exception is being thrown up
 the stack.
 I leave it to the Parser writer to reset this flag if they handle the exception
 so that parsing continues.
 
 --8<------------------------------------------------------------------
 
 --- ParseGen.java	2005-12-22 17:19:54.000000000 +0800
 +++ ParseGen_.java	2006-05-17 19:49:34.736006500 +0800
 @@ -582,7 +582,8 @@
 ostr.println("""");
 
 if (Options.getDebugParser()) {
 - ostr.println("" "" + staticOpt() + ""private int trace_indent = 0;"");
 + ostr.println("" "" + staticOpt() + ""private StringBuffer trace_indent =
 new StringBuffer();"");
 + ostr.println("" "" + staticOpt() + ""private int trace_lookahead_indent =
 0;"");
 ostr.println("" "" + staticOpt() + ""private boolean trace_enabled = true;"");
 ostr.println("""");
 ostr.println("" "" + staticOpt() + ""final public void enable_tracing() {"");
 @@ -594,24 +595,33 @@
 ostr.println("" }"");
 ostr.println("""");
 ostr.println("" "" + staticOpt() + ""final private void trace_call(String
 s) {"");
 + ostr.println("" if (s.indexOf(\""LOOKING AHEAD\"") > -1) {"");
 + ostr.println("" trace_lookahead_indent += 2;"");
 + ostr.println("" } else {"");
 + ostr.println("" trace_indent.setLength(trace_indent.length() -
 trace_lookahead_indent);"");
 + ostr.println("" trace_lookahead_indent = 0;"");
 + ostr.println("" }"");
 ostr.println("" if (trace_enabled) {"");
 - ostr.println("" for (int i = 0; i < trace_indent; i++) {
 System.out.print(\"" \""); }"");
 + ostr.println("" System.out.print(trace_indent);"");
 ostr.println("" System.out.println(\""Call: \"" + s);"");
 ostr.println("" }"");
 - ostr.println("" trace_indent = trace_indent + 2;"");
 + ostr.println("" trace_indent.append(\"" \"");"");
 ostr.println("" }"");
 ostr.println("""");
 ostr.println("" "" + staticOpt() + ""final private void
 trace_return(String s) {"");
 - ostr.println("" trace_indent = trace_indent - 2;"");
 + ostr.println("" trace_indent.setLength(trace_indent.length() - 2);"");
 + ostr.println("" if (s.indexOf(\""LOOKAHEAD \"") > -1) {"");
 + ostr.println("" trace_lookahead_indent -= 2;"");
 + ostr.println("" }"");
 ostr.println("" if (trace_enabled) {"");
 ostr.println("" for (int i = 0; i < trace_indent; i++) {
 System.out.print(\"" \""); }"");
 - ostr.println("" System.out.println(\""Return: \"" + s);"");
 + ostr.println("" 
 System.out.println((ParseException.wasError?\""Bailout: \"":\""Return: \"") + s);"");
 ostr.println("" }"");
 ostr.println("" }"");
 ostr.println("""");
 ostr.println("" "" + staticOpt() + ""final private void trace_token(Token
 t, String where) {"");
 ostr.println("" if (trace_enabled) {"");
 - ostr.println("" for (int i = 0; i < trace_indent; i++) {
 System.out.print(\"" \""); }"");
 + ostr.println("" System.out.print(trace_indent);"");
 ostr.println("" System.out.print(\""Consumed token: <\"" +
 tokenImage[t.kind]);"");
 ostr.println("" if (t.kind != 0 &&
 !tokenImage[t.kind].equals(\""\\\""\"" + t.image + \""\\\""\"")) {"");
 ostr.println("" System.out.print(\"": \\\""\"" + t.image + \""\\\""\"");"");
 @@ -622,7 +632,7 @@
 ostr.println("""");
 ostr.println("" "" + staticOpt() + ""final private void trace_scan(Token
 t1, int t2) {"");
 ostr.println("" if (trace_enabled) {"");
 - ostr.println("" for (int i = 0; i < trace_indent; i++) {
 System.out.print(\"" \""); }"");
 + ostr.println("" System.out.print(trace_indent);"");
 ostr.println("" System.out.print(\""Visited token: <\"" +
 tokenImage[t1.kind]);"");
 ostr.println("" if (t1.kind != 0 &&
 !tokenImage[t1.kind].equals(\""\\\""\"" + t1.image + \""\\\""\"")) {"");
 ostr.println("" System.out.print(\"": \\\""\"" + t1.image +
 \""\\\""\"");"");
 
 --8<------------------------------------------------------------------
 
 --- JavaFiles.java	2005-05-26 14:42:00.000000000 +0800
 +++ JavaFiles_.java	2006-05-17 19:29:09.043155100 +0800
 @@ -1714,6 +1714,13 @@
 ostr.println("" * mechanisms so long as you retain the public fields."");
 ostr.println("" */"");
 ostr.println(""public class ParseException extends Exception {"");
 + ostr.println("" /**"");
 + ostr.println("" * This static field is set when a ParseException is
 created,"");
 + ostr.println("" * and the Parser debugging code checks it to see if it
 should be printing \""Return\"" or \""BailOut\""."");
 + ostr.println("" * If an exception gets dealt with and the parser continues"");
 + ostr.println("" * it is the Parser's responsibility to clear this flag."");
 + ostr.println("" */"");
 + ostr.println("" public static boolean wasError = false;"");
 ostr.println("""");
 ostr.println("" /**"");
 ostr.println("" * This constructor is used by the method
 \""generateParseException\"""");
 @@ -1737,6 +1744,7 @@
 ostr.println("" currentToken = currentTokenVal;"");
 ostr.println("" expectedTokenSequences = expectedTokenSequencesVal;"");
 ostr.println("" tokenImage = tokenImageVal;"");
 + ostr.println("" ParseException.wasError = true;"");
 ostr.println("" }"");
 ostr.println("""");
 ostr.println("" /**"");
 @@ -1752,11 +1760,13 @@
 ostr.println("" public ParseException() {"");
 ostr.println("" super();"");
 ostr.println("" specialConstructor = false;"");
 + ostr.println("" ParseException.wasError = true;"");
 ostr.println("" }"");
 ostr.println("""");
 ostr.println("" public ParseException(String message) {"");
 ostr.println("" super(message);"");
 ostr.println("" specialConstructor = false;"");
 + ostr.println("" ParseException.wasError = true;"");
 ostr.println("" }"");
 ostr.println("""");
 ostr.println("" /**"");
 
 --8<------------------------------------------------------------------",,,,,,,,0|i0fzj3:,,,,,93237,,,127
javacc,JAVACC-126,"Use of keyword ""options"" as a variable is invalid",Bug,Closed,Critical,Fixed,sreeni,dleedei,dleedei,03/May/06 6:57 AM,,02/Sep/08 1:27 AM,02/Sep/08 1:27 AM,4.0,4.1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","I have a javaCC project which was working with an older version of the 
 eclipse_javacc plugin. Now using Java CC 4.0 parser generator I get this error:
 
 
 >javacc XQueryParser.jj 
 Java Compiler Compiler Version 4.0 (Parser Generator)
 (type ""javacc"" with no arguments for help)
 Reading from file XQueryParser.jj . . .
 org.javacc.parser.ParseException: Encountered ""options"" at line 142, column 25.
 Was expecting one of:
 <IDENTIFIER> ...
 ""("" ...
 ""<"" ...
 ""."" ...
 ""["" ...
 
 Detected 1 errors and 0 warnings.
 
 
 
 
 The ""bad code"" in question is a simple variable called ""options""
 	private HashMap options = new HashMap();
 
 Chaning the name to something else works
 	private HashMap xoptions = new HashMap();",,,,,,,,0|i04dbr:,,,,,25488,,,126
javacc,JAVACC-125,Constants in a class instead of an interface,Improvement,Closed,Major,Incomplete,sreeni,siyer,siyer,24/Apr/06 8:51 AM,,14/Jun/09 9:35 AM,14/Jun/09 9:35 AM,4.0,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Hi,
 
 Since static import is available in Java 1.5, it would be nice if JavaCC could,
 based on a compile-time option, write out the lexical constants to a class file
 rather than an interface. Then, one could use the ""static import"" construct to
 import the constants and avoind ""implementing"" the interface, which is a hack.
 
 Thanks.
 
 Swami",,,,,,,,0|i09n7b:,,,,,56248,,,125
javacc,JAVACC-124,Deprecation warnings in JavaCharStream,Bug,Closed,Major,Fixed,sreeni,dlsmith,dlsmith,19/Apr/06 1:29 PM,,02/Sep/08 1:26 AM,02/Sep/08 1:26 AM,4.0,4.1,general,,0,0,,,,,,,,"Operating System: All
 Platform: Macintosh","Compiling the generated JavaCharStream file under Java 5.0 (with deprecation warnings enabled) 
 generates the following warnings:
 
 [javac] <clipped>/JavaCharStream.java:348: warning: [dep-ann] deprecated name isnt annotated 
 with @Deprecated
 [javac] public int getColumn() {
 [javac] ^
 [javac] <clipped>/JavaCharStream.java:357: warning: [dep-ann] deprecated name isnt annotated 
 with @Deprecated
 [javac] public int getLine() {
 
 When JVM_VERSION is set to 1.5 or later, these warnings should be eliminated by adding a 
 ""@Deprecated"" annotation to each method.",,,,,,,,0|i0aqcv:,,,,,62591,,,124
javacc,JAVACC-123,jjtClose() exception,Bug,Closed,Major,Duplicate,sreeni,homme26,homme26,12/Apr/06 10:52 PM,,02/Sep/08 5:38 AM,02/Sep/08 5:38 AM,4.0,not determined,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","The following exception always occur when an exception is thrown
 from Node.jjtClose()
 
 Caused by: java.util.EmptyStackException
 	at java.util.Stack.peek(Stack.java:79)
 	at java.util.Stack.pop(Stack.java:61)
 	at
 javacc.parser.JJTJava1_5ParserState.closeNodeScope(JJTJava1_5ParserState.java:109)
 	at javacc.parser.Java1_5Parser.getRootNode(Java1_5Parser.java:138)
 	at ast.Parser.parseSN(Parser.java:32)
 	... 24 more
 
 (JJTJava1_5Parse) is a parser generated with javacc
 
 This exception bring no usefull information , the exception that
 comes from jjtClose() is discarded although its the primary error source.
 
 Please retrow it as a nested exception.
 
 Beforehand , this EmptyStackException exception my reveal JJtree bug?",,,,,,,,0|i06qen:,,,,,39271,,,123
javacc,JAVACC-122,Seeming contradiction,Bug,Open,Major,Unresolved,sreeni,tballard,tballard,01/Apr/06 8:34 PM,,23/Oct/06 6:01 PM,,current,milestone 1,general,,1,0,,,,,,,,"Operating System: All
 Platform: Other","Exception in thread ""main"" com.amis.bolt.ParseException: Encountered ""("" at line
 26, column 15.
 Was expecting one of:
 <DOUBLE_QUOTE_STR> ...
 <FLOAT> ...
 <INT> ...
 <SINGLE_QUOTE_STR> ...
 ""("" ...
 
 Encountered ""("" when expecting ""(""! This is either a bug or a seriously
 confusing error message. The only unusual thing I'm doing is using 4 lexical
 states. I might be able concoct a simple example if this is a real issue.",,,,,,,,0|i06vtb:,,,,,40147,,,122
javacc,JAVACC-121,jjtThis.token = <IDENTIFIER> is not translated properly,Bug,Closed,Critical,Fixed,sreeni,sreeni,sreeni,30/Mar/06 6:06 PM,,02/Sep/08 1:24 AM,02/Sep/08 1:24 AM,4.0,4.1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","Identifier():
 {}
 {
 jjtThis.token=<IDENITFIER>
 }
 
 translates to:
 
 void Identifier() : {/*@bgen(jjtree) Identifier */
 ASTIdentifier jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 /*@egen*/}^M
 {/*@bgen(jjtree) Identifier */
 try {
 /*@egen*/ <IDENTIFIER>/*@bgen(jjtree)*/
 } finally {
 if (jjtc000) {
 jjtree.closeNodeScope(jjtn000, true);
 }
 }
 /*@egen*/^M
 }^M
 
 
 Pretty bad. Should fix asap.",,,,,,,,0|i0dqgv:,,,,,80105,,,121
javacc,JAVACC-120,Ident Example Question,Bug,Closed,Major,Cannot Reproduce,tcopeland,deepsage,deepsage,25/Mar/06 7:39 AM,,02/Sep/08 5:40 AM,02/Sep/08 5:40 AM,4.0,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","These two lines appear to do the same thing, I don't think they should.
 
 < Id: [""a""-""z"",""A""-""Z""] ( [""a""-""z"",""A""-""Z"",""0""-""9""] )* >
 
 < Id: [""a""-""z"",""A""-""Z""] ( [""0""-""9""] )* >
 
 I am very new to JavaCC and I'm really looking for documentation or something 
 to explain the above.",,,,,,,,0|i0fm0v:,,,,,91049,,,120
javacc,JAVACC-119,JJTree Node classes do not import the parser package,Bug,Closed,Major,Duplicate,sreeni,npiguet,npiguet,15/Mar/06 2:58 AM,,02/Sep/08 5:30 AM,02/Sep/08 5:30 AM,4.0,4.1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","JJTree generated node classes do not import the parser package.
 
 If the option NODE_PACKAGE = ""some.package.nodes"" is set, and that parser is
 defined with a package name such as
 
 PARSER_BEGIN( Parser )
 package some.package;
 ...
 PARSER_END( Parser)
 
 The nodes generated by JJTree do not import some.package, but the constructor of
 the nodes need a Parser instance. So obviously the generated code doesn't compile
 
 There are two possible solutions to this:
 1 - Let the generated node classes import the parser package
 2 - remove the NODE_PACKAGE options altogether, and use the package
 declaration of the parser (thus forcing the nodes and the parser to be in the
 same package)
 
 In the current state, the NODE_PACKAGE option doesn't make much sense, either it
 should allow you to use a separate package for the Nodes and the parser, or it
 should use the package declaration of the Parser (just as JavaCC does).",,,,,,,,0|i0d3lb:,,,,,76399,,,119
javacc,JAVACC-118,generateParseException() bug,Bug,Open,Major,Unresolved,paulcager,siyer,siyer,06/Mar/06 6:13 AM,,22/Sep/08 3:57 PM,,4.0,milestone 1,parser generator,,1,0,,,,,,,,"Operating System: All
 Platform: All","In one of our projects involving JavaCC, we implemented the deep error recovery
 scheme suggested in the JavaCC manual. We noticed that ParseException object
 that is thrown in case of a parsing error is not the same as that instantiated
 within the error_skipto() method using the generateParseException() method. The
 former contains the token that is to be consumed, but the latter does not -- it
 just contains the expected tokens. Our workaround was to pass the exception
 object as an argument to error_skipto() method.
 
 Swami",,,,,,,,0|i039pr:,,,,,19071,,,118
javacc,JAVACC-117,Annotations with empty curly braces cause the Java grammar to fail,Bug,Closed,Major,Fixed,sreeni,dgreen,dgreen,21/Feb/06 12:56 PM,,02/Sep/08 1:22 AM,02/Sep/08 1:22 AM,4.0,4.1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","For example, the following annotation causes the Java grammar to fail:
 
 @ManyToOne(cascade = {}, optional = false)
 
 The exception that I see is as follows:
 
 test.javacc.java5.ParseException: Parse error at line 205, column 31. 
 Encountered: }
 	at test.javacc.java5.JavaParser.generateParseException(JavaParser.java:8709)
 	at test.javacc.java5.JavaParser.jj_consume_token(JavaParser.java:8661)
 	at test.javacc.java5.JavaParser.MemberValue(JavaParser.java:5153)
 	at test.javacc.java5.JavaParser.MemberValueArrayInitializer(JavaParser.java:5176)
 	at test.javacc.java5.JavaParser.MemberValue(JavaParser.java:5119)
 	at test.javacc.java5.JavaParser.MemberValuePair(JavaParser.java:5103)
 	at test.javacc.java5.JavaParser.MemberValuePairs(JavaParser.java:5070)
 	at test.javacc.java5.JavaParser.NormalAnnotation(JavaParser.java:5019)
 	at test.javacc.java5.JavaParser.Annotation(JavaParser.java:4982)
 	at test.javacc.java5.JavaParser.Modifiers(JavaParser.java:379)
 	at
 test.javacc.java5.JavaParser.ClassOrInterfaceBodyDeclaration(JavaParser.java:979)
 	at test.javacc.java5.JavaParser.ClassOrInterfaceBody(JavaParser.java:920)
 	at test.javacc.java5.JavaParser.ClassOrInterfaceDeclaration(JavaParser.java:516)
 	at test.javacc.java5.JavaParser.TypeDeclaration(JavaParser.java:431)
 	at test.javacc.java5.JavaParser.CompilationUnit(JavaParser.java:183)",,,,,,,,0|i0cilj:,,,,,72998,,,117
javacc,JAVACC-116,jjStopAtPos breaks jjmatchedKind value?,Bug,Closed,Major,Incomplete,sreeni,kmaxima,kmaxima,09/Feb/06 6:54 AM,,14/Jun/09 9:35 AM,14/Jun/09 9:35 AM,4.0,milestone 1,general,,0,0,,,,,,,,"Operating System: Windows XP
 Platform: All","I'm using JAVACC 4.0. I found the jjStopAtPos() method breaks jjmatchedKind 
 value?
 
 My Input text is very simple. just like following.
 
 sc_in< > in1, in5;
 
 I attatch the DEBUG_TOKEN_MANAGER log, input file, and parser source code.
 Parser source code is very simple contrary to it's size. (Most code is not 
 used, but size does matter, I think.)
 
 regards.
 
 input file =======================================================
 sc_in< > in1, in5;
 
 
 
 
 DEBUG_TOKEN_MANAGER log ==========================================
 
 msg : Reading from file D:\trash\ast\testsystemc\stage1.h . . .
 Call: compile_unit
 Call: port_var_declaration
 <DEFAULT>Current character : s (115) at line 1 column 1
 Possible string literal matches : { ""short"", ""signed"", ""sizeof"", ""static"", 
 ""struct"", ""switch"", ""static_cast"", ""sc_module"", ""sc_in"", 
 ""sc_out"", ""sc_inout"", ""sc_fifo_in"", ""sc_fifo_out"", ""sc_port"", 
 ""sc_fifo"" } 
 <DEFAULT>Current character : c (99) at line 1 column 2
 Possible string literal matches : 
 { ""sc_module"", ""sc_in"", ""sc_out"", ""sc_inout"", 
 ""sc_fifo_in"", ""sc_fifo_out"", ""sc_port"", ""sc_fifo"" } 
 <DEFAULT>Current character : _ (95) at line 1 column 3
 Possible string literal matches : 
 { ""sc_module"", ""sc_in"", ""sc_out"", ""sc_inout"", 
 ""sc_fifo_in"", ""sc_fifo_out"", ""sc_port"", ""sc_fifo"" } 
 <DEFAULT>Current character : i (105) at line 1 column 4
 Possible string literal matches : { , ""sc_in"", 
 ""sc_inout"" } 
 <DEFAULT>Current character : n (110) at line 1 column 5
 Currently matched the first 5 characters as a ""sc_in"" token.
 Possible string literal matches : { , ""sc_inout"" } 
 <DEFAULT>Current character : < (60) at line 1 column 6
 No string literal matches possible.
 No more string literal token matches are possible.
 Starting NFA to match one of : { <ID> }
 <DEFAULT>Current character : < (60) at line 1 column 6
 Currently matched the first 5 characters as a ""sc_in"" token.
 Putting back 1 characters into the input stream.
 ****** FOUND A ""sc_in"" MATCH (sc_in) ******
 
 Consumed token: <""sc_in"" at line 1 column 1>
 <DEFAULT>Current character : < (60) at line 1 column 6
 Currently matched the first 1 characters as a ""<"" token.
 Possible string literal matches : { ""<<="", ""<="", ""<<"" } 
 <DEFAULT>Current character : (32) at line 1 column 7
 No more string literal token matches are possible.
 Starting NFA to match one of : { }
 <DEFAULT>Current character : (32) at line 1 column 7
 Currently matched the first 1 characters as a ""<"" token.
 Putting back 1 characters into the input stream.
 ****** FOUND A ""<"" MATCH (<) ******
 
 Consumed token: <""<"" at line 1 column 6>
 <DEFAULT>Skipping character : (32)
 <DEFAULT>Skipping character : (32)
 <DEFAULT>Current character : > (62) at line 1 column 9
 Currently matched the first 1 characters as a "">"" token.
 Possible string literal matches : { "">>="", "">="", "">>"" } 
 <DEFAULT>Current character : (32) at line 1 column 10
 No more string literal token matches are possible.
 Starting NFA to match one of : { }
 <DEFAULT>Current character : (32) at line 1 column 10
 Currently matched the first 1 characters as a "">"" token.
 Putting back 1 characters into the input stream.
 ****** FOUND A "">"" MATCH (>) ******
 
 Consumed token: <"">"" at line 1 column 9>
 <DEFAULT>Skipping character : (32)
 <DEFAULT>Current character : i (105) at line 1 column 11
 Possible string literal matches : { ""if"", ""inline"", ""int"" } 
 <DEFAULT>Current character : n (110) at line 1 column 12
 Possible string literal matches : { ""inline"", ""int"" } 
 <DEFAULT>Current character : 1 (49) at line 1 column 13
 No string literal matches possible.
 No more string literal token matches are possible.
 Starting NFA to match one of : { <ID> }
 <DEFAULT>Current character : 1 (49) at line 1 column 13
 Currently matched the first 3 characters as a <ID> token.
 Possible kinds of longer matches : { <ID> }
 <DEFAULT>Current character : , (44) at line 1 column 14
 Currently matched the first 3 characters as a <ID> token.
 Putting back 1 characters into the input stream.
 ****** FOUND A <ID> MATCH (in1) ******
 
 Consumed token: <<ID>: ""in1"" at line 1 column 11>
 <DEFAULT>Current character : , (44) at line 1 column 14
 Currently matched the first 1 characters as a "","" token.
 Possible string literal matches : { "", "" } 
 <DEFAULT>Current character : (32) at line 1 column 15
 No more string literal token matches are possible.
 Currently matched the first 2 characters as a "", "" token.
 ****** FOUND A "", "" MATCH (, ) ******
 
 Return: port_var_declaration
 Return: compile_unit
 Exception in thread ""main"" com.foo.com.ParseException: Encountered "", "" at line 
 1, column 14.
 Was expecting:
 "","" ...
 
 	at com.foo.com.eg1.generateParseException(eg1.java:818)
 	at com.foo.com.eg1.jj_consume_token(eg1.java:688)
 	at com.foo.com.eg1.port_var_declaration(eg1.java:48)
 	at com.foo.com.eg1.compile_unit(eg1.java:35)
 	at com.foo.com.eg1.main(eg1.java:26)
 
 
 
 
 
 
 parser source code ( .jj file ) =================================
 
 
 options {
 	JDK_VERSION = ""1.5"";
 	DEBUG_PARSER=true;
 	DEBUG_TOKEN_MANAGER=true;
 }
 PARSER_BEGIN(eg1)
 package com.foo.com;
 
 public class eg1 {
 
 	private static void msg(String s) {
 			System.out.println( ""msg : "" + s);
 	}
 
 public static void main(String args[]) throws ParseException {
 
 	java.io.InputStream input;
 	int ai = 0;
 
 	if( ai == (args.length-1)) {
 		msg( ""Reading from file "" + args[ai] + "" . . ."" );
 		try {
 			input = new java.io.FileInputStream( args[ai] );
 		} catch ( java.io.FileNotFoundException e ) {
 			msg(""File "" + args[0] + "" not found."");
 			return;
 		}
 
 	 eg1 parser = new eg1( input );
 		parser.enable_tracing();
 		parser.compile_unit();
 		msg(""Program parsed successfully."");
 
 	}
 }
 }
 PARSER_END(eg1)
 
 SKIP :
 {	"" ""
 	| ""\t"" | ""\r"" | ""\n""
 	| ""//"" : IN_LINE_COMMENT
 	| ""/*"" : IN_COMMENT
 	| ""#"" : PREPROCESSOR_OUTPUT
 }
 
 <IN_LINE_COMMENT> SKIP:
 {	""\n"" : DEFAULT
 }
 
 <IN_LINE_COMMENT> MORE:
 {	< ~[] >
 }
 
 <IN_COMMENT> SKIP:
 {	""*/"" : DEFAULT
 }
 
 <IN_COMMENT> MORE:
 {	< ~[] >
 }
 
 <PREPROCESSOR_OUTPUT> SKIP:
 {	""\n"" : DEFAULT
 }
 
 <PREPROCESSOR_OUTPUT> MORE:
 {	< ~[] >
 }
 
 TOKEN :
 {	 < LCURLYBRACE: ""{"" > | < RCURLYBRACE: ""}"" > | < 
 LSQUAREBRACKET: ""["" > | < RSQUAREBRACKET: ""]"" >
 	| < LPARENTHESIS: ""("" > | < RPARENTHESIS: "")"" > | < 
 SCOPE: ""::"" > | < COLON: "":"" >
 	| < SEMICOLON: "";"" > | < COMMA: "","" > | < 
 QUESTIONMARK: ""?"" > | < ELLIPSIS: ""..."" >
 	| < ASSIGNEQUAL: ""="" > | < TIMESEQUAL: ""*="" > | < 
 DIVIDEEQUAL: ""/="" > | < MODEQUAL: ""%="" >
 	| < PLUSEQUAL: ""+="" > | < MINUSEQUAL: ""-="" > | < 
 SHIFTLEFTEQUAL: ""<<="" > | < SHIFTRIGHTEQUAL: "">>="" >
 	| < BITWISEANDEQUAL: ""&="" > | < BITWISEXOREQUAL: ""^="" > | < 
 BITWISEOREQUAL: ""|="" > | < OR: ""||"" >
 	| < AND: ""&&"" > | < BITWISEOR: ""|"" > | < 
 BITWISEXOR: ""^"" > | < AMPERSAND: ""&"" >
 	| < EQUAL: ""=="" > | < NOTEQUAL: ""!="" > | < 
 LESSTHAN: ""<"" > | < GREATERTHAN: "">"" >
 	| < LESSTHANOREQUALTO: ""<="" > | < GREATERTHANOREQUALTO: "">="" > | < 
 SHIFTLEFT: ""<<"" > | < SHIFTRIGHT: "">>"" >
 	| < PLUS: ""+"" > | < MINUS: ""-"" > | < 
 STAR: ""*"" > | < DIVIDE: ""/"" >
 	| < MOD: ""%"" > | < PLUSPLUS: ""++"" > | < 
 MINUSMINUS: ""--"" > | < TILDE: ""~"" >
 	| < NOT: ""!"" > | < DOT: ""."" > | < 
 POINTERTO: ""->"" > | < DOTSTAR: "".*"" >
 	| < ARROWSTAR: ""->*"" > | < AUTO: ""auto"" > | < 
 BREAK: ""break"" > | < CASE: ""case"" >
 	| < CATCH: ""catch"" > | < CHAR: ""char"" > | < 
 CONST: ""const"" > | < CONTINUE: ""continue"" >
 	| < _DEFAULT: ""default"" > | < DELETE: ""delete"" > | < 
 DO: ""do"" > | < DOUBLE: ""double"" >
 	| < ELSE: ""else"" > | < ENUM: ""enum"" > | < 
 EXTERN: ""extern"" > | < FLOAT: ""float"" >
 	| < FOR: ""for"" > | < FRIEND: ""friend"" > | < 
 GOTO: ""goto"" > | < IF: ""if"" >
 	| < INLINE: ""inline"" > | < INT: ""int"" > | < 
 LONG: ""long"" > | < NEW: ""new"" >
 	| < PRIVATE: ""private"" > | < PROTECTED: ""protected"" > | < 
 PUBLIC: ""public"" > | < REDECLARED: ""redeclared"" >
 	| < REGISTER: ""register"" > | < RETURN: ""return"" > | < 
 SHORT: ""short"" > | < SIGNED: ""signed"" >
 	| < SIZEOF: ""sizeof"" > | < STATIC: ""static"" > | < 
 STRUCT: ""struct"" > | < CLASS : ""class"" >
 	| < SWITCH: ""switch"" > | < TEMPLATE: ""template"" > | < 
 THIS: ""this"" > | < TRY: ""try"" >
 	| < TYPEDEF: ""typedef"" > | < UNION: ""union"" > | < 
 UNSIGNED: ""unsigned"" > | < VIRTUAL: ""virtual"" >
 	| < VOID: ""void"" > | < VOLATILE: ""volatile"" > | < 
 WHILE: ""while"" > | < OPERATOR: ""operator"" >
 	| < TRUETOK: ""true"" > | < FALSETOK: ""false"" > | < 
 THROW: ""throw"" > | < MUTABLE: ""mutable"" >
 	| < BOOL: ""bool"" > | < USING: ""using"" > | < 
 TYPEID: ""typeid"" > | < EXPORT: ""export"" >
 	| < WCHAR_T: ""wchar_t"" > | < TYPENAME: ""typename"" > | < 
 EXPLICIT: ""explicit"" > | < CONST_CAST: ""const_cast"" >
 	| < ZERO : ""0"" > | < NAMESPACE : ""namespace"" > | < 
 REINTERPRET_CAST: ""reinterpret_cast"" >
 	| < STATIC_CAST: ""static_cast"" > | < DYNAMIC_CAST: ""dynamic_cast"" >
 }
 
 
 TOKEN :
 {
 	 < MOD_CLASSNAME : ""sc_module"" >
 	| < MOD_MACRO : ""SC_MODULE"" >
 	| < SC_IN : ""sc_in"" >
 	| < SC_OUT : ""sc_out"" >
 	| < SC_INOUT : ""sc_inout"" >
 	| < SC_FIFOIN : ""sc_fifo_in"" >
 	| < SC_FIFOOUT : ""sc_fifo_out"" >
 	| < SC_PORT : ""sc_port"" >
 	| < SC_FIFO : ""sc_fifo"" > 
 
 	
 	| < SCCTOR_MACRO : ""SC_CTOR"" >
 	| < SC_METHOD : ""SC_METHOD"" >
 	| < SC_THREAD : ""SC_THREAD"" >
 	| < SC_CTHREAD : ""SC_CTHREAD"" >
 	| <EVERYTHING :~[]>
 }
 
 TOKEN [IGNORE_CASE] :
 {
 	 < OCTALINT : <ZERO> ([""0""-""7""])* >
 	| <	OCTALLONG : <OCTALINT> ""l"" >
 	| <	UNSIGNED_OCTALINT : <OCTALINT> ""u"" >
 	| <	UNSIGNED_OCTALLONG : <OCTALINT> (""ul"" | ""lu"") >
 	
 	| <	DECIMALINT : [""1""-""9""] ([""0""-""9""])* >
 	| <	DECIMALLONG : <DECIMALINT> [""u"",""l""] >
 	| <	UNSIGNED_DECIMALINT : <DECIMALINT> ""u"" >
 	| <	UNSIGNED_DECIMALLONG : <DECIMALINT> (""ul"" | ""lu"") >
 	
 	
 	| <	HEXADECIMALINT : ""0x"" ([""0""-""9"",""a""-""f""])+ >
 	| <	HEXADECIMALLONG : <HEXADECIMALINT> ([""u"",""l""])? >
 	| <	UNSIGNED_HEXADECIMALINT : <HEXADECIMALINT> ""u"" >
 	| <	UNSIGNED_HEXADECIMALLONG : <HEXADECIMALINT> (""ul"" | ""lu"") >
 	
 	
 	| <	FLOATONE : (([""0""-""9""])+ ""."" ([""0""-""9""])* | ([""0""-""9""])* ""."" 
 ([""0""-""9""])+)
 								(""e"" ([""-
 "",""+""])? ([""0""-""9""])+)? ([""f"",""l""])? >
 	
 	| <	FLOATTWO : ([""0""-""9""])+ ""e"" ([""-"",""+""])?	([""0""-""9""])+ 
 ([""f"",""l""])? >
 }
 
 TOKEN :
 {
 
 	< CHARACTER : ( ""L"" )? ""'""
 	 (	 (~[""'"",""\\"",""\n"",""\r""])
 	 | (""\\"" (
 						 
 [""n"",""t"",""v"",""b"",""r"",""f"",""a"",""\\"",""?"",""'"",""\""""]
 						|
 						 ""0"" ([""0""-""7""])*
 						|
 						 [""1""-""9""] ([""0""-""9""])*
 						|
 						 (""0x"" | ""0X"") ([""0""-""9"",""a""-
 ""f"",""A""-""F""])+
 					 )
 		 )
 	 )
 	 ""'"" >
 
 | <	STRING : (""L"")? ""\""""
 	 ( ( ~[""\"""",""\\"",""\n"",""\r""])
 	 | (""\\"" (
 						 
 [""n"",""t"",""v"",""b"",""r"",""f"",""a"",""\\"",""?"",""'"",""\""""]
 						|
 						 ""0"" ([""0""-""7""])*
 						|
 						 [""1""-""9""] ([""0""-""9""])*
 						|
 						 (""0x"" | ""0X"") ([""0""-""9"",""a""-
 ""f"",""A""-""F""])+
 					 )
 		 )
 	 )*
 	 ""\"""" >
 }
 
 TOKEN :
 {	< ID : [""a""-""z"",""A""-""Z"", ""_""] ([""a""-""z"",""A""-""Z"",""0""-""9"",""_""])* >
 }
 
 void compile_unit() : { }
 {
 	port_var_declaration()
 }
 
 void port_var_declaration() : {}
 {
 	""sc_in"" ""<"" "">"" <ID> <COMMA> <ID> "";""
 }
 
 void function_params() : {}
 {
 	typename() ( LOOKAHEAD( 1 ) <ID> )? ( "", "" typename() ( <ID> )? )*
 }
 
 void member_variable() : {}
 {
 	port_var_declaration()
 }
 
 void template_argment() : {}
 {
 	 types() | <STRING> | constant()
 }
 
 void types():{}
 {
 	buildin_type_specifier()
 	| ( ""::"" )? ( LOOKAHEAD( namespace()) namespace())? typename() ( ""<"" 
 template_argment() "">"" )?	
 }
 
 void typename() : {}
 {
 	 < ""sc_module"" >
 	| sc_template_typename()
 	| <ID>
 }
 
 void sc_template_typename() : {}
 {
 	 < ""sc_fifo"" >
 	| sc_port_template_typename()
 }
 
 void sc_port_template_typename() : {}
 {
 	 < ""sc_in"" >
 	| < ""sc_out"" >
 	| < ""sc_inout"" >
 	| < ""sc_fifo_in"" >
 	| < ""sc_fifo_out"" >
 	| < ""sc_port"" >
 }
 
 void namespace() : {}
 {
 	typename() ( LOOKAHEAD( 2 ) ""::"" typename())* ""::""
 }
 
 void buildin_type_specifier() : {}
 {
 	 ""char"" | ""wchar_t"" | ""bool"" | ""short"" | ""int"" | ""long"" | ""signed""
 	| ""unsigned"" | ""float"" | ""double"" | ""void""
 }
 
 void constant() : {}
 {	 <ZERO> | <OCTALINT> | <OCTALLONG> | <DECIMALINT> | <DECIMALLONG>
 	 | <HEXADECIMALINT> | <HEXADECIMALLONG> | <UNSIGNED_OCTALINT>
 	 | <UNSIGNED_OCTALLONG> | <UNSIGNED_DECIMALINT> | <UNSIGNED_DECIMALLONG>
 	 | <UNSIGNED_HEXADECIMALINT> | <UNSIGNED_HEXADECIMALLONG>
 	 | <CHARACTER> | <FLOATONE> | <FLOATTWO>
 	 | ""true"" | ""false""
 }",,,,,,,,0|i0e0vz:,,,,,81793,,,116
javacc,JAVACC-115,JJTree and javaCC do not always generate package specs,Bug,Closed,Critical,Duplicate,sreeni,adroffner,adroffner,03/Feb/06 1:15 PM,,02/Sep/08 5:27 AM,02/Sep/08 5:27 AM,4.0,4.1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","JJTree and javaCC do not always generate package specs to match the declared
 parser. For example, Node.java and ParseException.java are in the default package.
 I think it is a bug to leave these classes in the default package.
 
 Why isn't there a run-time jar, e.g. javaccrt.jar? Is this for efficiency on old
 Java, or legal reasons? This is the best solution.
 
 Otherwise, the declared parser package spec should go into the java files.
 
 An option could choose betwwen a run-time JAR or in-line *.java file, with the
 package spec.",,,,,,,,0|i0fapj:,,,,,89216,,,115
javacc,JAVACC-114,#81 fix not applied to downloadable 4.0 binaries,Bug,Closed,Major,Duplicate,sreeni,faux,faux,01/Feb/06 5:20 PM,,02/Sep/08 1:20 AM,02/Sep/08 1:20 AM,4.0,4.1,general,,1,0,,,,,,,,"Operating System: Windows XP
 Platform: All","Issue 81 (https://javacc.dev.java.net/issues/show_bug.cgi?id=81) has not been 
 fixed in the downloadable binaries and source linked to from the front page. (
 ie. https://javacc.dev.java.net/files/documents/17/26776/javacc-4.0.tar.gz)
 
 A working binary is (temporarily) avaliable at http://faux.uwcs.co.uk/javacc.jar
 (http://faux.uwcs.co.uk/javacc.jar.asc) for anyone else who's project is being 
 blocked by this.",,,,,,,,0|i09qm7:,,,,,56801,,,114
javacc,JAVACC-113,JJTREE_OUTPUT_DIRECTORY not listed in jjtree help,Bug,Closed,Major,Fixed,tcopeland,gk5885,gk5885,15/Jan/06 6:12 AM,,02/Sep/08 1:18 AM,02/Sep/08 1:18 AM,4.0,4.1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","The JJTREE_OUTPUT_DIRECTORY option listed in the jjtree documentation is not listed in the command line 
 help produced by jjtree.",,,,,,,,0|i09z67:,,,,,58187,,,113
javacc,JAVACC-112,enum is reserved keyword under 1.5,Bug,Closed,Major,Fixed,sreeni,castortech,castortech,28/Dec/05 2:03 PM,,02/Sep/08 1:17 AM,02/Sep/08 1:17 AM,current,4.1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","many places in the code, enum is used as an identifier, making it conflict with
 java 1.5 since enum is now a keyword. Suggest renaming all instances to enu to
 avoid the conflict and allow javacc to compile under 1.5",,,,,,,,0|i0d4z3:,,,,,76623,,,112
javacc,JAVACC-111,grammar on SQL,New Feature,Closed,Trivial,Incomplete,sreeni,chen_x_y,chen_x_y,26/Dec/05 6:47 AM,,14/Jun/09 9:34 AM,14/Jun/09 9:34 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Dear all:
 I want some samples on the grammar on SQL. Is there any grammar files 
 about this issue? If yes, would you please send to my mail address:
 
 watson@shonetown.com or chen_x_y@hotmail.com
 
 Thanks",,,,,,,,0|i0c127:,,,,,70157,,,111
javacc,JAVACC-110,JJTree doesn't allow the node names with full class path,Improvement,Open,Major,Unresolved,sreeni,obuchwal,obuchwal,18/Dec/05 4:08 AM,,02/Sep/08 3:11 AM,,current,not determined,jjtree,,0,0,,,,,,,,"Operating System: Mac OS X
 Platform: Macintosh","For having many nodes with similar names, we would like to specify the node name of a production with 
 its full and absolute class path. 
 But currently only an identifier is expected after the # character",,,,,,,,0|i0crhb:,,,,,74437,,,110
javacc,JAVACC-109,Generating into packages,Improvement,Closed,Major,Incomplete,sreeni,olofw,olofw,15/Sep/05 1:37 AM,,14/Jun/09 9:34 AM,14/Jun/09 9:34 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","All generated classes are generated into the default package. This causes a
 major problem since it is illegal to import a class from the default namespace
 in Java 5. To get around this, one must write all code that uses the generator
 into the default package or be prepared to move the files after each
 modification of the grammar file. This should be fairly easy to fix.",,,,,,,,0|i0d47r:,,,,,76500,,,109
javacc,JAVACC-108,Avoiding java.lang.Error in generated code,Improvement,Resolved,Major,Incomplete,sreeni,vfedik,vfedik,14/Aug/05 1:14 PM,,02/Sep/08 3:13 AM,02/Sep/08 3:13 AM,current,not determined,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Would like to rework JavaCC so that Errors won't be thrown in generated code.
 Having them is counterintuitive for third-party developers as they slip ""common
 sense"" try-catches and may lead to the abrupt termination of the running
 application. For example, I suggest substituting java.lang.Error in
 XYZParser#ReInit and XYZTokenManager#ReInit with java.lang.IllegalStateException.
 
 This issue relates to the Issue #12, which proposed making TokenMgrError a
 subclass of Exception. Well, why not make ParseException and TokenizeException
 (a new name for that class?) bot unchecked? By implementing the change on my own
 code I learned that it's not feasible having TokenizeException being a checked
 one as this necessitated surrounding every invocation of XYZparser#getToken with
 a try-catch.
 
 Seems like a major change that cannot be delivered 100% backward-compatible. Any
 comments?",,,,,,,,0|i0eeaf:,,,,,83964,,,108
javacc,JAVACC-107,Access modifiers for productions,Improvement,Resolved,Major,Fixed,sreeni,vfedik,vfedik,11/Aug/05 12:07 PM,,13/Aug/05 10:01 AM,13/Aug/05 10:01 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","If (re)structuring grammars, I often end up with many utility-productions (e.g.
 lookahead) that I don't want to expose to end users. Therefore, it would be
 helpful to be able to specify access modifiers to BNF and Javacode productions. 
 
 I've implemented the change myself that involved some modifications in files
 jjtree/JJTree.jjt, parser/JavaCC.jj, parser/NormalProduction.java and
 parser/ParseEngine.java. If you're interested in including it, I can create a
 patchfile.",,,,,,,,0|i0cjs7:,,,,,73190,,,107
javacc,JAVACC-106,JDK 1.5 grammar additions,Bug,Open,Major,Unresolved,sreeni,vfedik,vfedik,10/Aug/05 3:38 AM,,02/Sep/08 3:09 AM,,current,not determined,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","According to the JLS3, PackageDeclaration() (see #7.4.1), EnumConstant() (see
 #8.9) and FormalParameter()/LocalVariableDeclaration() (see #8.4.1/14.4) may be
 prefixed by Annotations().",,,,,,,,0|i0coc7:,,,,,73928,,,106
javacc,JAVACC-105,parser instance reference in non-static TokenManager,Improvement,Resolved,Major,Fixed,sreeni,hagen_schendel,hagen_schendel,09/Aug/05 5:53 AM,,14/Aug/05 6:42 AM,14/Aug/05 6:42 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","If STATIC is FALSE, add a field called ""parser"" in cu_name+""TokenManager"" and
 set it by constructor.",,,,,,,,0|i0falr:,,,,,89199,,,105
javacc,JAVACC-104,frfrfr,New Feature,Closed,Major,Incomplete,sreeni,zzllj,zzllj,02/Aug/05 6:07 AM,,14/Jun/09 9:33 AM,14/Jun/09 9:33 AM,current,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: Windows XP
 Platform: All",rer,,,,,,,,0|i0a5uf:,,,,,59268,,,104
javacc,JAVACC-103,debug_parser and debug_token_manager should also print the line/col info,Improvement,Resolved,Major,Fixed,sreeni,sreeni,sreeni,25/Jul/05 11:50 AM,,22/Dec/05 5:20 PM,22/Dec/05 5:20 PM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","It will be greatly helpful if the debuginfor included the line/col # for
 consumed chars with debug_token_manager and consumed token(s) with debug_parser.",,,,,,,,0|i0b4zj:,,,,,64961,,,103
javacc,JAVACC-102,String instead of InputStream,Improvement,Closed,Major,Incomplete,sreeni,alfranio,alfranio,22/Jul/05 1:58 AM,,14/Jun/09 9:33 AM,14/Jun/09 9:33 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Instead of reading from an inputstream I would like to feed the parser with
 strings, is it possible ?
 If it is, how could I do that ?
 
 Best regards,
 
 Alfranio Junior",,,,,,,,0|i060bb:,,,,,35044,,,102
javacc,JAVACC-101,ReInit(InputStream) causes a stack overflow.,Bug,Resolved,Major,Fixed,sreeni,jsoutter,jsoutter,21/Jul/05 5:33 AM,,22/Dec/05 10:27 AM,22/Dec/05 10:27 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","For: javacc-4.0beta1.zip
 
 Calling ReInit(InputStream) on the generated parser class causes a 
 StackOverflowError.
 
 The issue is that ReInit(InputStream) is recursivly defined in the generated 
 class.
 
 static public void ReInit(java.io.InputStream stream) {
 ReInit(stream);
 }
 
 Example input file. In this example, the error appears in ExampleParser.java.
 
 
 options {
 	STATIC = true;
 	KEEP_LINE_COLUMN = true;
 	CACHE_TOKENS = true;
 	DEBUG_PARSER = false;
 }
 
 PARSER_BEGIN( ExampleParser )
 
 package com.any ;
 
 public class ExampleParser
 {
 }
 
 PARSER_END( ExampleParser )
 
 
 TOKEN :
 {
 <EXAMPLE:			""Example"" >
 }
 
 
 SKIP :
 {
 	< 					( "" "" | ""\t"" ) >
 }
 
 
 void all() :
 { }
 {
 	( <EXAMPLE> )*
 	
 	<EOF>
 }",,,,,,,,0|i08jdz:,,,,,49798,,,101
javacc,JAVACC-100,random expression generation according to EBNF,New Feature,Open,Major,Unresolved,sreeni,lpimmes,lpimmes,16/Jul/05 9:52 AM,,22/Dec/05 1:06 PM,,current,not determined,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","The javacc tool is great; I do enjoy working with it.
 But, for my own peace of mind, I want to generate many random sentences 
 (natural language expressions) given a working EBNF grammer (including lexer), 
 to:
 1) test for ambiguity
 2) to view combinations of expressions
 
 I have managed to take an existing grammar, and have the parser parse each 
 sentence properly (as expectecd). Note because of recursion, I had to 
 eventually force the generation of a terminal symbol, so as not cause a stack 
 overflow.
 Fine, but for a non trivial language, which has many syntactic features, this 
 is time consuming, and error prone.
 
 The best scenario would be parser compiles with no errors, nor warnings.
 Invoke a function, to generate random sentences, which are displayed on console.
 Any suggestions?
 Thanks for your time.
 Luke",,,,,,,,0|i08nsf:,,,,,50511,,,100
javacc,JAVACC-99,Support nested classes as nodes,New Feature,Resolved,Major,Fixed,sreeni,vfedik,vfedik,15/Jul/05 8:16 AM,,13/Aug/05 2:42 PM,13/Aug/05 2:42 PM,current,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","Sometimes it comes in handy to use static nested classes in tree construction.
 For example, if parsing try-catch-finally statements, the ""catch"" and ""finally""
 could be represented by classes TryStatement#Catch and TryStatement#Finally,
 respectively. A regular ""dotted"" naming syntax would be fine.
 
 I've figured out that the desired functionality can be achieved by modifying two
 files:
 
 A) src/org/javacc/jjtree/JJTree.jjt:
 <patch>
 @@ -793,12 +793,10 @@
 ASTNodeDescriptor node_descriptor() #NodeDescriptor :
 {
 Token t, n = null;
 + String s = null;
 }
 {
 - ""#"" ( t=identifier() | t=<VOID> )
 - {
 -		 jjtThis.name = t.image;
 -		 }
 + ""#"" ( s = Name() { jjtThis.name = s; } | t = <VOID> { jjtThis.name = t.image; } )
 [
 LOOKAHEAD(1)
 ""(""
 </patch>
 
 B) src/org/javacc/jjtree/ASTNodeDescriptor.java
 <patch>
 @@ -68,7 +68,7 @@
 
 String getNodeId()
 {
 - return ""JJT"" + name.toUpperCase();
 + return ""JJT"" + name.toUpperCase().replace('.', '_');
 }
 </patch>
 
 The latter patch ensures that during the formation of constant names all dots
 are replaced with underscores.",,,,,,,,0|i0ajzr:,,,,,61560,,,99
javacc,JAVACC-98,Incomplete ExplicitConstructorInvocation syntax in Java 1.5 grammar,Bug,Reopened,Major,Unresolved,sreeni,vfedik,vfedik,15/Jul/05 7:50 AM,,04/Jan/06 5:58 AM,,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Accoring to the JLS3, #8.8.7.1, both alternate constructor invocations (i.e.
 ""this(..)"") and superclass constructor invocations (i.e. ""super(..)"") may take
 explicit type arguments. I've been using the following fragment in my work:
 
 void ExplicitConstructorLookahead() :
 {}
 {
 	LOOKAHEAD ( [ TypeArguments() ] ( <THIS> | <SUPER> ) <LPAREN> )
 	[ TypeArguments() ] ( <THIS> | <SUPER> ) <LPAREN>
 	|
 	PrimaryExpression() <DOT> [ TypeArguments() ] <SUPER> <LPAREN>
 }
 
 Note that in order to avoid accepting regular ""this""-es and ""super""-s in the
 static context of ExplicitConstructorInvocation, the PrimaryExpression()
 production has been enchanced as suggested in the issue #91.",,,,,,,,0|i0fyzb:,,,,,93148,,,98
javacc,JAVACC-97,Need to support HexadecimalFloatingPointLiterals in Java1.5 grammar,Bug,Resolved,Major,Fixed,sreeni,vfedik,vfedik,15/Jul/05 7:12 AM,,13/Aug/05 12:41 PM,13/Aug/05 12:41 PM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","A not so well known language addition into Java 1.5 are hexadecimal
 floatting-point literals. For general discussion, see JLS3, #3.10.2. Anyway,
 here's what I came up with:
 
 < FLOATING_POINT_LITERAL:
 	<DECIMAL_FLOATING_POINT_LITERAL>
 	|
 	<HEXADECIMAL_FLOATING_POINT_LITERAL>
 >
 |
 < #FD_SUFFIX: [""f"",""F"",""d"",""D""] >
 |
 < #DECIMAL_FLOATING_POINT_LITERAL:
 	([""0""-""9""])+ ""."" ([""0""-""9""])* (<DECIMAL_EXPONENT>)? (<FD_SUFFIX>)?
 	|
 	""."" ([""0""-""9""])+ (<DECIMAL_EXPONENT>)? (<FD_SUFFIX>)?
 	|
 	([""0""-""9""])+ <DECIMAL_EXPONENT> (<FD_SUFFIX>)?
 	|
 	([""0""-""9""])+ (<DECIMAL_EXPONENT>)? <FD_SUFFIX>
 >
 |
 < #DECIMAL_EXPONENT: [""e"",""E""] ([""+"",""-""])? ([""0""-""9""])+ >
 |
 < #HEXADECIMAL_FLOATING_POINT_LITERAL:
 	""0"" [""x"", ""X""] ([""0""-""9"",""a""-""f"",""A""-""F""])+ (""."")? <HEXADECIMAL_EXPONENT>
 (<FD_SUFFIX>)?
 	|
 	""0"" [""x"", ""X""] ([""0""-""9"",""a""-""f"",""A""-""F""])* ""."" ([""0""-""9"",""a""-""f"",""A""-""F""])+
 <HEXADECIMAL_EXPONENT> (<FD_SUFFIX>)?
 >
 |
 < #HEXADECIMAL_EXPONENT: [""p"",""P""] ([""+"",""-""])? ([""0""-""9""])+ >",,,,,,,,0|i0f2vz:,,,,,87949,,,97
javacc,JAVACC-96,Code generated by JavaCC produces many warnings in modern IDEs,Bug,Closed,Major,Fixed,tcopeland,bmotik,bmotik,14/Jul/05 1:24 AM,,02/Sep/08 1:15 AM,02/Sep/08 1:15 AM,current,4.1,parser generator,,3,0,,,,,,,,"Operating System: All
 Platform: All","The code produced by JavaCC generates many warnings in modern IDEs, such as 
 Eclipse. From the parser I get the the following complaints: 
 
 - The field SPARQLParser.jj_semLA is never read locally.
 - This empty statement may be unintended. (Occurs on numerous places in the 
 parser.)
 
 From the token manager I get the following warnings (some of them occur several 
 times in different methods):
 
 - The method jjStopAtPos(int, int) from the type SPARQLParserTokenManager is 
 never used locally.
 - The method jjCheckNAddStates(int) from the type SPARQLParserTokenManager is 
 never used locally.
 - The local variable nextStates is never read.
 - The local variable j is never read.
 - The local variable l is never read.
 - The local variable i1 is never read.
 - The local variable l1 is never read.
 - The local variable i2 is never read.
 - The local variable l2 is never read.
 - The local variable kind is never read.
 - Import 'xx' is not used. (These imports come from the parser.)
 - 
 
 Furthermore, generated exceptions do not contain a serialVersionID field.
 
 
 Similar problems were reported in Issue #40, and they were dismissed with an 
 argument that ""JavaCC-generated files should not be style-checked by IDEs. 
 However, in most modern IDEs (I've tried it with JBuilder 2005, Eclipse 3.1 and 
 OmniCore Code Guide 7.0), it is not possible to turn off style-checking for 
 some files selectively. Eclipse 3.1 is slightly better than the other tools, as 
 it supports the @SuppressWarnings annotation. Still, the fact remains that the 
 only way to turn these warnings off is from WITHIN the source files. However, 
 this does not work for the unused imports - the only way to get rid of those 
 warnings is to delete the imports.
 
 Currently, to get rid of those warnings, one can either turn them completely 
 off in the IDE, which is bad (warnings can often point to errors), or to 
 manually edit the generated files (which is clearly suboptimal). I see two 
 possible ways of handling this issue.
 
 The preferred way is to generate code which does not raise any warning. For 
 example, one might generate class members, such as jj_semLA, jjStopAtPos or 
 jjCheckNAddStates, at the end of the file, provided that they are used by the 
 generated code. For the imports, one might introduce an additional option to 
 JavaCC, e.g. COPY_IMPORTS_TO_TOKEN_MANAGER = true.
 
 If this is too complicated, then JavaCC might simply generate code which 
 contains @SuppressWarnings(""all"") in front of each class. This should happen 
 only in Java 1.5 mode, and is therefore not so general as the previous 
 solution, but would still help.
 
 Additionally, in Java 1.5 mode it would be good to output @SuppressWarnings
 (â€œserialâ€�) for all generated exceptions.
 
 Sincerely yours,
 
 Boris Motik",,,,,,,,0|i063e7:,,,,,35543,,,96
javacc,JAVACC-95,Infrequently-utilized LOOKAHEAD causes OutOfMemoryError,Bug,Open,Critical,Unresolved,sreeni,cemerick,cemerick,10/Jul/05 9:09 PM,,02/Sep/08 3:10 AM,,current,not determined,parser generator,,1,0,,,,,,,,"Operating System: All
 Platform: All","The parser generated by javacc 3.2 uses a few different Token references in its
 implementation of LOOKAHEAD, including jj_scanpos and jj_lastpos. When a
 LOOKAHEAD directive is encountered in a grammar and is required infrequently
 during a parsing run, both jj_scanpos and jj_lastpos can grow out of control,
 causing an OutOfMemoryError.
 
 The root cause of this is that jj_scanpos and jj_lastpos are not nulled out (or
 otherwise disconnected from the main 'token' attribute), so the standard
 jj_ntk() calls end up building a linked list of Token instances rooted at the
 first token used in the original LOOKAHEAD processing, assigned to jj_scanpos
 and/or jj_lastpos.
 
 The given URL includes a testcase: a sample grammar, and a test file. The
 grammar uses a LOOKAHEAD directive once, and then proceeds to continue parsing
 the rest of the 2MB test file. With a 64MB max heap size, the generated parser
 reliably throws an OutOfMemoryError. The grammar's main-method then will report
 the depth of the jj_scanpos linked list.
 
 There appears to be a simple solution. Here's a function inthe sample grammar's
 generated parser that is involved in setting up the processing of a LOOKAHEAD:
 
 ---
 final private boolean jj_2_1(int xla) {
 jj_la = xla; jj_lastpos = jj_scanpos = token;
 try { return !jj_3_1(); }
 catch(LookaheadSuccess ls) { return true; }
 }
 ---
 
 Notice that jj_lastpos and jj_scanpos are both assigned to the current token
 reference, but that isn't being cleaned up. Changing this function to the
 following resolves the OutOfMemoryError, and appears to result in no adverse
 functional effects:
 
 ---
 final private boolean jj_2_1(int xla) {
 jj_la = xla; jj_lastpos = jj_scanpos = token;
 try { return !jj_3_1(); }
 catch(LookaheadSuccess ls) { return true; }
 finally {
 jj_lastpos = jj_scanpos = null;
 }
 }
 ---
 
 That just lets the garbage collection do its job after the LOOKAHEAD processing
 is done with the lists of tokens headed by the jj_lastpos and jj_scanpos references.",,,,,,,,0|i02dlz:,,,,,13870,,,95
javacc,JAVACC-94,"RFE: epsilon (""nothing"" aka ""empty"") matches",Improvement,Closed,Major,Incomplete,sriram,boyland,boyland,04/Jul/05 8:11 PM,,14/Jun/09 9:32 AM,14/Jun/09 9:32 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: Sun","My grammar sometimes needs to specify a ""nothing"".
 (1) JJTREE doesn't permit one to attach tree creations in series
 (perhaps another RFE?)
 ... #Node1(2) #Node2(1)
 (2) Sometimes we want different nodes for situations:
 Something() ( Optionalstuff() #Node1(2)
 | #Node2(1) )
 
 We currently fake this by having a nonterminal: ""nothing"" and write
 
 
 Something() (OptionalStuff() #Node1(2)
 | nothing() #Node2(1))
 
 that consists of the ""optional keyword"" ""supercalifragilisticexpialadocious""
 that we *hope* never actually appears in the input.
 
 This is a horrible hack that could go away if we were permitted to write:
 
 void nothing() : {}
 {
 ()
 }
 
 I'm submitting this as an RFE since it is a longstanding issue with JavaCC, but
 technically it is a bug since the JavaCC documentation says:
 
 expansion 	::= 	( expansion_unit )*
 
 In other words, *Zero* or more expansion_units is an expansion.
 (JavaCC requires actually *one* or more)",,,,,,,,0|i06n67:,,,,,38747,,,94
javacc,JAVACC-93,Generated comment causes Invalid Unicode Error,Bug,Closed,Major,Duplicate,sreeni,mpdaugh,mpdaugh,01/Jul/05 12:26 PM,,02/Sep/08 5:28 AM,02/Sep/08 5:28 AM,current,4.1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Hi, I've been having some trouble with JavaCC files in a ""util"" directory in my 
 WSAD project. At the top of every generated file is the line:
 
 /* Generated By:JJTree: Do not edit this line. C:\Documents and 
 Settings\u0068095\My Documents\workspace\v1\Project\source\util\[FILENAME] */
 
 The unicode error occurs at the ""\utils,"" because ""\u"" indicates a unicode 
 character. I searched online and noticed that other people have encountered 
 this problem on Windows machines as well.
 
 My thought is that this could be fixed by having JavaCC output ""/"" instead 
 of ""\"" in Windows filenames (Windows will accept either one these days). This 
 could be achieved by adding the line ""fileName = fileName.replaceAll
 (""\\"", ""/"");"" at line 239 of org.javacc.parser.JavaCCGlobals.java (Just 
 before ""return toolNamePrefix+"" Do not edit this line. "" + fileName);"")
 
 Thank you for your response.",,,,,,,,0|i07omn:,,,,,44815,,,93
javacc,JAVACC-92,JJTreeExamples eg2 README and generated .java contain errors,Bug,Resolved,Major,Fixed,tcopeland,mbmast,mbmast,29/Jun/05 1:19 PM,,11/Jul/05 6:53 AM,11/Jul/05 6:53 AM,current,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","REAME for \javacc-3.2\examples\JJTreeExamples example eg2 contains an error and 
 the generated code contains an error.
 
 The README states that after javacc has been run, the user should enter the 
 following command:
 
 javac eg2.java
 
 This should be:
 
 javac *.java
 
 Also, eg2.java contains an error. jjtn000 is an instance of ASTMyID. ASTMyID 
 nor any of its base classes contains a setName() method:
 
 D:\javacc-3.2\examples\JJTreeExamples>javac *.java
 eg2.java:191: cannot resolve symbol
 symbol : method setName (java.lang.String)
 location: class ASTMyID
 jjtn000.setName(t.image);
 ^
 1 error",,,,,,,,0|i05lvb:,,,,,32704,,,92
javacc,JAVACC-91,1.5 grammar: Improve Parsing of ExplicitConstructorInvocation,Improvement,Resolved,Major,Fixed,sreeni,teegee,teegee,19/Jun/05 5:09 AM,,22/Dec/05 12:50 PM,22/Dec/05 12:50 PM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Consider the following code:
 
 public class Test {
 public Test() {
 super(); // matched correctly as an ExplicitConstructorInvocation
 Test.this.super(); // matched as a method invocation
 }
 }
 
 The grammar provided with the beta of JavaCC 4.0 parses this.
 However, it does incorrectly, as ""Test.this.super()"" is not matched as an
 ExplicitConstructorInvocation but an ordinary method invocation, even if the
 first super-invocation is left out.
 I came up with the following bugfix:
 Use a global boolean variable ""allowSuper"", which is initially set to true.
 Within ConstructorDeclaration, set it to false when checking for
 ExplicitConstructorInvocation, and back to true right afterwards. Within the
 PrimarySuffix-production, add a semantic lookahead:
 LOOKAHEAD(2, {allowSuper}) ""."" ""super""
 
 Best Regards,
 
 Tobias",,,,,,,,0|i0h01j:,,,,,99152,,,91
javacc,JAVACC-90,Convert Extended Backus Naur Form grammar to a JavaCC grammar,Improvement,Open,Major,Unresolved,gpaulissen,gpaulissen,gpaulissen,25/May/05 6:28 AM,,22/Dec/05 12:49 PM,,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","The tool JJDoc produces a BNF grammer from a JavaCC parser specification. Is the
 opposite possible, i.e. from BNF to JavaCC. Actually I have written a simple
 Extended BNF to JavaCC converter (using a JavaCC specification of ENBF) and I am
 willing to contribute it to the project but I think it needs some review.",,,,,,,,0|i059cn:,,,,,30676,,,90
javacc,JAVACC-89,Example Java grammars do not accept negative numbers,Bug,Resolved,Major,Won't Fix,sreeni,neilplus,neilplus,18/May/05 11:30 AM,,20/May/05 1:00 AM,20/May/05 1:00 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: Linux
 Platform: PC","It seems to me as if the example Java grammars disallow negative numbers. For
 example, in javacc-3.2/examples/JavaGrammars/Java1.0.2.jj, I can see: 
 
 ====
 
 < #DECIMAL_LITERAL: [""1""-""9""] ([""0""-""9""])* >
 |
 < #HEX_LITERAL: ""0"" [""x"",""X""] ([""0""-""9"",""a""-""f"",""A""-""F""])+ >
 |
 < #OCTAL_LITERAL: ""0"" ([""0""-""7""])* >
 |
 < FLOATING_POINT_LITERAL:
 ([""0""-""9""])+ ""."" ([""0""-""9""])* (<EXPONENT>)? ([""f"",""F"",""d"",""D""])?
 | ""."" ([""0""-""9""])+ (<EXPONENT>)? ([""f"",""F"",""d"",""D""])?
 | ([""0""-""9""])+ <EXPONENT> ([""f"",""F"",""d"",""D""])?
 | ([""0""-""9""])+ (<EXPONENT>)? [""f"",""F"",""d"",""D""]
 >
 
 ====
 
 where I would expect to see something like: 
 
 ====
 
 < #DECIMAL_LITERAL: ([""+"",""-""])? [""1""-""9""] ([""0""-""9""])* >
 |
 < #HEX_LITERAL: ""0"" [""x"",""X""] ([""0""-""9"",""a""-""f"",""A""-""F""])+ >
 |
 < #OCTAL_LITERAL: ""0"" ([""0""-""7""])* >
 |
 < FLOATING_POINT_LITERAL:
 ([""+"",""-""])? ([""0""-""9""])+ ""."" ([""0""-""9""])* (<EXPONENT>)?
 ([""f"",""F"",""d"",""D""])?
 | ([""+"",""-""])? ""."" ([""0""-""9""])+ (<EXPONENT>)? ([""f"",""F"",""d"",""D""])?
 | ([""+"",""-""])? ([""0""-""9""])+ <EXPONENT> ([""f"",""F"",""d"",""D""])?
 | ([""+"",""-""])? ([""0""-""9""])+ (<EXPONENT>)? [""f"",""F"",""d"",""D""]
 >
 
 ====
 
 assuming numbers in octal or hex shouldn't have signs. 
 
 This surfaced after someone cut & pasted the snippet in question into the
 grammar for an application I'm currently working on. The copied version rejects
 all negative numbers, but the change shown above makes it work as expected. 
 
 Neil.",,,,,,,,0|i01mcf:,,,,,9453,,,89
javacc,JAVACC-88,jdk 1.5 generics,Bug,Resolved,Major,Duplicate,sreeni,er,er,17/May/05 3:28 AM,,16/Dec/05 8:40 AM,16/Dec/05 8:40 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Really a little bug; still i had a little shock: 
 
 nested generics as 
 void addPath(Set<List<String>> innerPaths) : 
 do not work 
 but there is a simple workaround: 
 
 void addPath(Set<List<String> > innerPaths) : 
 
 greetings 
 
 ernst",,,,,,,,0|i0c0r3:,,,,,70107,,,88
javacc,JAVACC-87,ParseException builds message string with += instead of StringBuffer,Bug,Resolved,Major,Fixed,tcopeland,rosejr,rosejr,09/May/05 1:59 PM,,26/May/05 2:44 PM,26/May/05 2:44 PM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","In ParseException.getMessage(), a potentially very large String is built by
 repeated concatenation instead of using StringBuffer. After n appends, the i-th
 appended string has been copied n-i times: O(n^2) performance.
 
 This can result in an apparent deadlock when trying to print a parse error. In
 my case, the error string was 507 KB. Using StringBuffer allows it to be
 printed almost immediately. For example:
 
 StringBuffer exp = new StringBuffer();
 int maxSize = 0;
 for (int i = 0; i < expectedTokenSequences.length; i++) {
 if (maxSize < expectedTokenSequences[i].length) {
 maxSize = expectedTokenSequences[i].length;
 }
 for (int j = 0; j < expectedTokenSequences[i].length; j++) {
 exp.append (tokenImage[expectedTokenSequences[i][j]] + "" "");
 }
 if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
 exp.append ( ""..."");
 }
 exp.append(eol + "" "");
 }
 String expected = exp.toString();",,,,,,,,0|i0cl73:,,,,,73419,,,87
javacc,JAVACC-86,ReInit(InputStream) is recursive,Bug,Resolved,Major,Fixed,sreeni,robinsharp,robinsharp,03/May/05 4:19 AM,,03/May/05 5:43 AM,03/May/05 5:43 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","This ReInit method in the ""main(String[] args)"" class is recursive 
 
 static public void ReInit(java.io.InputStream stream) {
 ReInit(stream);
 }
 
 
 May be it should match the constructor ... 
 
 public MainClass(java.io.InputStream stream) {
 this(stream, null);
 }
 
 
 and pass a null through to the other ReInit method
 
 static public void ReInit(java.io.InputStream stream) {
 ReInit(stream, null);
 }",,,,,,,,0|i0bm67:,,,,,67745,,,86
javacc,JAVACC-85,Divide by 0 error,Bug,Resolved,Minor,Fixed,sriram,sshimko,sshimko,02/May/05 10:10 AM,,11/Jul/05 6:54 AM,11/Jul/05 6:54 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","A patch committed to CVS on 2005-04-30 (and found recent 4.0beta1) causes a
 divide by zero error in the generated SimpleCharStream file. The source appears
 to be the new tab width patch first submitted with issue 22. The patch
 originally attached to issue 22 initialized tabSize to 8 however the version
 that made it into CVS initialized it as 0. 
 
 Thanks,
 Spencer Shimko
 
 Index: JavaFiles.java
 ===================================================================
 RCS file: /cvs/javacc/src/org/javacc/parser/JavaFiles.java,v
 retrieving revision 1.7
 diff -u -r1.7 JavaFiles.java
 --- JavaFiles.java 30 Apr 2005 07:08:10 -0000 1.7
 +++ JavaFiles.java 2 May 2005 17:07:54 -0000
 @@ -236,7 +236,7 @@
 ostr.println(prefix + ""protected int maxNextCharInd = 0;"");
 ostr.println(prefix + ""protected int nextCharInd = -1;"");
 ostr.println(prefix + ""protected int inBuf = 0;"");
 - ostr.println(prefix + ""protected int tabSize = 0;"");
 + ostr.println(prefix + ""protected int tabSize = 8;"");
 ostr.println("""");
 ostr.println(prefix + ""protected void setTabSize(int i) { tabSize = i; }"");
 ostr.println(prefix + ""protected int getTabSize(int i) { return tabSize; }"");
 @@ -984,7 +984,7 @@
 ostr.println(prefix + ""protected char[] buffer;"");
 ostr.println(prefix + ""protected int maxNextCharInd = 0;"");
 ostr.println(prefix + ""protected int inBuf = 0;"");
 - ostr.println(prefix + ""protected int tabSize = 0;"");
 + ostr.println(prefix + ""protected int tabSize = 8;"");
 ostr.println("""");
 ostr.println(prefix + ""protected void setTabSize(int i) { tabSize = i; }"");
 ostr.println(prefix + ""protected int getTabSize(int i) { return tabSize; }"");",,,,,,,,0|i09sd3:,,,,,57084,,,85
javacc,JAVACC-84,JavaCC should generate JDK 1.5 compatible code,Improvement,Resolved,Major,Fixed,sreeni,sreeni,sreeni,30/Apr/05 10:14 AM,,03/May/05 5:49 AM,03/May/05 5:49 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","There are a few places whjere we use containers like Stack/Vector in the
 generated code. Those should be properly typed for 1.5. Needs a new option
 JDK_VERSION which can be set to 1.5 for generating this code.",,,,,,,,0|i0b5uv:,,,,,65102,,,84
javacc,JAVACC-83,Java 5 Bad generics handling,Bug,Resolved,Major,Duplicate,sriram,germano_pt,germano_pt,28/Apr/05 12:15 AM,,16/Dec/05 8:57 AM,16/Dec/05 8:57 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","When using sub-generics types the number of â€˜>â€™ generated is incorrect.
 For instance,
 new HashMap<String, Vector<String>>()
 will result on
 new HashMap<String, Vector<String>>>()
 
 Similarly,
 new HashMap<String, Vector<Vector<String>>>
 outputs
 HashMap<String, Vector<Vector<String>>>>>>
 
 This happens with the lastest CVS build.",,,,,,,,0|i0by5z:,,,,,69688,,,83
javacc,JAVACC-82,Overly generous with the '>' characters.,Bug,Resolved,Major,Fixed,sriram,tballard,tballard,20/Apr/05 2:07 PM,,16/Dec/05 8:57 AM,16/Dec/05 8:57 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","ArrayList<HashMap<String, ArrayList<Pair<String,Object>>>>
 
 translates to 
 
 ArrayList<HashMap<String, ArrayList<Pair<String,Object>>>>>>>>>
 
 in section between PARSER_BEGIN and PARSER_END
 
 This is the java 1.5 parser, and it basically seemed to be doubling the number
 of trailing '>' characters.
 
 You must have seen this by now so probably ignore it.",,,,,,,,0|i0d9kv:,,,,,77369,,,82
javacc,JAVACC-81,"Generated prologue comments include filenames containing ""\u"" which leads to lexical errors.",Task,Resolved,Major,Fixed,sreeni,hagen_schendel,hagen_schendel,07/Apr/05 4:39 AM,,22/Dec/05 12:54 PM,22/Dec/05 12:54 PM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","JJTree puts filenames into the header comment of the generated files.
 Therefor it uses JavaCCGlobals.getIdString.
 When using e.g. Windows filenames a path may occur containing ""\u"" such as 
 in ""C:\home\user"". This leads to the Java compiler throwing a lexical error as 
 it is searching for a unicode number.
 The problem can be caught in JavaCCGlobals.getIdString by replacing all
 occurrences of ""\u"" with ""\\u"".",,,,,,,,0|i0b0jr:,,,,,64242,,,81
javacc,JAVACC-80,Wrong line numbers in Javacc error reports,Bug,Closed,Major,Fixed,paulcager,masmith72,masmith72,18/Mar/05 5:51 AM,,02/Sep/08 1:12 AM,02/Sep/08 1:12 AM,current,4.1,jjtree,,1,0,,,,,,,,"Operating System: Linux
 Platform: PC","The reported line numbers on the javacc warning messages are sometimes
 inaccurate. An initial investigation has led me to believe that this is due to
 the way that the jjtree ""white's out"" non-javacc operations. Specifically, the
 white-out operations appear to mask whitespace characters (e.g., linefeed
 characters '\n') whilst whiteing out a token using the
 org.javacc.jjtree.SimpleNode.java's whiteOut method call. I have tried out the
 followin replacement for this method, and it appears to work. However, I do not
 propeerly understand the code, so cannot be confident that this is, in general,
 a sensible patch. So I submit it for your consideration.
 
 String whiteOut(Token t)
 {
 String s = """";
 String image = t.image;
 
 for (int i = 0; i < t.image.length(); ++i) {
 char ch = image.charAt(i);
 
 if (ch != '\t' && ch != '\n' && ch != '\r' && ch != '\f') {
 s += "" "";
 } else {
 	s += ch;
 }
 }
 return s;
 }
 
 A few days ago I looked at the messages and could not see any reportingof this
 issue.
 
 Hope this is helpful,
 
 Anthony.",,,,,,,,0|i08ocf:,,,,,50601,,,80
javacc,JAVACC-79,Make it easy to access token image,New Feature,Resolved,Major,Fixed,sriram,sreeni,sreeni,14/Mar/05 8:21 AM,,11/Jul/05 6:54 AM,11/Jul/05 6:54 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","See my email regarding memory leaks due to holding on to tokens too long:
 
 https://javacc.dev.java.net/servlets/ReadMsg?list=dev&msgNo=189
 
 Since most often people to do thigns like t=<ID> just to get the image, I
 propose a feature to directly access the image, like:
 
 s=<ID>.image
 
 In fact, it will be good to provide accessors like the above all the token
 attributes (image, beginLine, endLien etc.) so that one doesn't need to get
 tokens for simple things.",,,,,,,,0|i030s7:,,,,,17624,,,79
javacc,JAVACC-78,Repetition Range Specifications doesn't work in jjtree.,Bug,Closed,Major,Fixed,sriram,frankgauthier,frankgauthier,01/Mar/05 12:33 PM,,02/Sep/08 1:03 AM,02/Sep/08 1:03 AM,current,4.0,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","Repetition Range Specifications don't work in jjtree.
 
 Including the following Three Letter Acronym in a .jj grammar compiles and
 executes as expected:
 
 TOKEN:
 {
 <TLA: ([""A""-""Z""]){3}>
 }
 
 Using the same Token specification in a .jjt grammar gives the following error
 at jjtree-compile time:
 
 
 ""Error parsing input: Encountered ""{"" at line 60, column 28.
 Was expecting one of: ...""",,,,,,,,0|i05qrz:,,,,,33499,,,78
javacc,JAVACC-77,Generate Unicode aware code for user CharStreams,Improvement,Closed,Major,Incomplete,sreeni,pkuzel,pkuzel,01/Mar/05 1:35 AM,,14/Jun/09 9:31 AM,14/Jun/09 9:31 AM,current,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Having header:
 
 options {
 // USER_CHAR_STREAM = true;
 UNICODE_INPUT = true; // generate unicode aware code
 BUILD_PARSER = false;
 STATIC = false;
 LOOKAHEAD = 1;
 }
 
 javacc 3.2 generates TokenManager that contains:
 
 public void ReInit(SimpleCharStream stream)
 {
 jjmatchedPos = jjnewStateCnt = 0;
 curLexState = defaultLexState;
 input_stream = stream;
 ReInitRounds();
 }
 
 javacc 2.0 generated:
 
 public void ReInit(UCode_CharStream stream)
 {
 jjmatchedPos = jjnewStateCnt = 0;
 curLexState = defaultLexState;
 input_stream = stream;
 ReInitRounds();
 }
 
 
 In my application I have own implementation of CharStream, taking data from
 Swing document (StringParserInput). 
 
 Currently I must use following trick:
 
 
 1. declare 3 classes in my.javacchack package:
 
 public class StringParserInout extends SimpleCharStream implements CharStream {
 // implements CharStream contract
 }
 
 public class UCode_CharStream extends StringParserInput {
 // empty make javacc generated TokenManager happy
 }
 
 // replacement for JavaCC generated SimpleCharStream
 public class SimpleCharStream {
 static boolean staticFlag = false;
 }
 
 
 2. import the package into generated code:
 
 syntax.jj content snippet:
 
 PARSER_BEGIN(CSSSyntax)
 
 package org.netbeans.modules.css.text.syntax.javacc;
 
 // import own stream implementations
 import org.netbeans.modules.css.text.syntax.javacchack.*;
 
 
 3. generate TokenManager
 
 $ javacc syntax.jj
 Reading from file CSSSyntax.jj . . .
 Note: UNICODE_INPUT option is specified. Please make sure you create the
 parser/lexer usig a Reader with the correct character encoding.
 File ""SimpleCharStream.java"" does not exist. Will create one.
 Parser generated successfully.
 
 
 4. remove Javacc generated streams:
 
 $ rm SimpleCharStream.java
 
 
 5. compile it
 
 ant
 
 
 Summary:
 
 A support for custom CharStream would be helpfull. It would eliminate need for
 above trick. Javacc should generate code using CharStream interface instead of
 particular implementations.",,,,,,,,0|i05udj:,,,,,34082,,,77
javacc,JAVACC-76,LookaheadSuccess Stack Trace,Bug,Closed,Major,Fixed,sreeni,john_b_pratt,john_b_pratt,05/Feb/05 10:25 AM,,02/Sep/08 3:11 AM,02/Sep/08 3:11 AM,current,4.1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","I am playing with writing simple extentions to Java using JavaCC & JJTree. I
 fed the following simple program into Parser 2.9.7:
 
 public class TestUse
 {
 public static void main(String[] args) throws Exception
 {
 System.out.println(Num<int>.compute(1, 1));
 }
 }
 
 When I tried to acquire the CompilationUnit from the parser, the use of ""<int>""
 (which I realize is not legal) resulted in the following stack trace:
 
 <code><pre><blockquote>
 Exception in thread ""main""
 net.sourceforge.jrefactory.parser.JavaParser$LookaheadSuccess
 	at net.sourceforge.jrefactory.parser.JavaParser.<init>(JavaParser.java:10862)
 	at Jpp.main(Jpp.java:11)
 </blockquote></pre></code>
 
 I did not expect a stack trace (just an error message). When I tracked down
 line 10862 in JavaParser, here is the code that I found:
 
 <code><pre>
 static private final class LookaheadSuccess extends java.lang.Error { }
 final private LookaheadSuccess jj_ls = new LookaheadSuccess();
 final private boolean jj_scan_token(int kind) {
 if (jj_scanpos == jj_lastpos) {
 jj_la--;
 if (jj_scanpos.next == null) {
 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
 } else {
 jj_lastpos = jj_scanpos = jj_scanpos.next;
 }
 } else {
 jj_scanpos = jj_scanpos.next;
 }
 if (jj_rescan) {
 int i = 0; Token tok = token;
 while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
 if (tok != null) jj_add_error_token(kind, i);
 }
 if (jj_scanpos.kind != kind) return true;
 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
 return false;
 }
 </pre></code>
 
 Would it be more helpful if ""throw jj_ls"" was replaced with ""throw new
 LookaheadSuccess()"" ? I made this change which gave me the following trace (in
 case it helps resolve the issue faster). Lastly, I'm not clear on why
 LookaheadSuccess is an error and not an exception.
 
 <code><pre><blockquote>
 Exception in thread ""main""
 net.sourceforge.jrefactory.parser.JavaParser$LookaheadSuccess
 	at
 net.sourceforge.jrefactory.parser.JavaParser.jj_scan_token(JavaParser.java:10879)
 	at net.sourceforge.jrefactory.parser.JavaParser.jj_3R_181(JavaParser.java:10541)
 	at net.sourceforge.jrefactory.parser.JavaParser.jj_3R_151(JavaParser.java:7110)
 	at net.sourceforge.jrefactory.parser.JavaParser.jj_3R_96(JavaParser.java:7237)
 	at net.sourceforge.jrefactory.parser.JavaParser.jj_3_31(JavaParser.java:7259)
 	at net.sourceforge.jrefactory.parser.JavaParser.jj_3R_81(JavaParser.java:7266)
 	at net.sourceforge.jrefactory.parser.JavaParser.jj_3R_160(JavaParser.java:10318)
 	at net.sourceforge.jrefactory.parser.JavaParser.jj_3R_106(JavaParser.java:10327)
 	at net.sourceforge.jrefactory.parser.JavaParser.jj_3R_188(JavaParser.java:8100)
 	at net.sourceforge.jrefactory.parser.JavaParser.jj_3R_148(JavaParser.java:8247)
 	at net.sourceforge.jrefactory.parser.JavaParser.jj_3R_94(JavaParser.java:8310)
 	at net.sourceforge.jrefactory.parser.JavaParser.jj_3R_194(JavaParser.java:8368)
 	at net.sourceforge.jrefactory.parser.JavaParser.jj_3R_156(JavaParser.java:8407)
 	at net.sourceforge.jrefactory.parser.JavaParser.jj_3R_98(JavaParser.java:8579)
 	at net.sourceforge.jrefactory.parser.JavaParser.jj_3_35(JavaParser.java:8653)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.jj_rescan_token(JavaParser.java:11037)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.generateParseException(JavaParser.java:10980)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.jj_consume_token(JavaParser.java:10858)
 	at net.sourceforge.jrefactory.parser.JavaParser.PrimaryPrefix(JavaParser.java:4782)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.PrimaryExpression(JavaParser.java:4667)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.PostfixExpression(JavaParser.java:4580)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.UnaryExpressionNotPlusMinus(JavaParser.java:4545)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.UnaryExpression(JavaParser.java:4403)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.MultiplicativeExpression(JavaParser.java:4313)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.AdditiveExpression(JavaParser.java:4256)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.ShiftExpression(JavaParser.java:4195)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.RelationalExpression(JavaParser.java:4165)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.InstanceOfExpression(JavaParser.java:4091)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.EqualityExpression(JavaParser.java:4035)
 	at net.sourceforge.jrefactory.parser.JavaParser.AndExpression(JavaParser.java:3992)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.ExclusiveOrExpression(JavaParser.java:3949)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.InclusiveOrExpression(JavaParser.java:3906)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.ConditionalAndExpression(JavaParser.java:3863)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.ConditionalOrExpression(JavaParser.java:3820)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.ConditionalExpression(JavaParser.java:3778)
 	at net.sourceforge.jrefactory.parser.JavaParser.Expression(JavaParser.java:3671)
 	at net.sourceforge.jrefactory.parser.JavaParser.ArgumentList(JavaParser.java:5066)
 	at net.sourceforge.jrefactory.parser.JavaParser.Arguments(JavaParser.java:5021)
 	at net.sourceforge.jrefactory.parser.JavaParser.PrimarySuffix(JavaParser.java:4874)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.PrimaryExpression(JavaParser.java:4675)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.StatementExpression(JavaParser.java:5765)
 	at net.sourceforge.jrefactory.parser.JavaParser.Statement(JavaParser.java:5307)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.BlockStatement(JavaParser.java:5553)
 	at net.sourceforge.jrefactory.parser.JavaParser.Block(JavaParser.java:5468)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.MethodDeclaration(JavaParser.java:2617)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.ClassBodyDeclaration(JavaParser.java:1355)
 	at net.sourceforge.jrefactory.parser.JavaParser.ClassBody(JavaParser.java:1219)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.UnmodifiedClassDeclaration(JavaParser.java:648)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.ClassDeclaration(JavaParser.java:578)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.TypeDeclaration(JavaParser.java:485)
 	at
 net.sourceforge.jrefactory.parser.JavaParser.CompilationUnit(JavaParser.java:358)
 	at Jpp.main(Jpp.java:13)
 </blockquote></pre></code>
 
 Sorry if this is all the fault of jrefactory and not an improvement to
 jjtree/javacc.",,,,,,,,0|i06olr:,,,,,38979,,,76
javacc,JAVACC-75,Java1.5.jj fails to parse java/util/concurrent/ScheduledThreadPoolExecutor.java,Bug,Resolved,Critical,Fixed,sreeni,cpacheco,cpacheco,20/Jan/05 12:32 PM,,21/Jan/05 10:49 PM,21/Jan/05 10:49 PM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: Linux
 Platform: PC","Hi,
 
 I have tested the code generated by the grammar in Java1.5.jj by parsing every
 file in the sources for the JDK 1.5. The parser failed to parse only the file 
 
 java/util/concurrent/ScheduledThreadPoolExecutor.java
 
 The error message given is:
 
 Parsing: ./java/util/concurrent/ScheduledThreadPoolExecutor.java 
 
 
 ParseException: Parse error at line 142, column 45. Encountered: . 
 
 
 at JavaParser.generateParseException(Unknown Source) 
 
 
 at JavaParser.jj_consume_token(Unknown Source) 
 
 
 at JavaParser.BlockStatement(Unknown Source) 
 
 
 at JavaParser.Block(Unknown Source) 
 
 
 at JavaParser.MethodDeclaration(Unknown Source) 
 
 
 at JavaParser.ClassOrInterfaceBodyDeclaration(Unknown Source) 
 
 
 at JavaParser.ClassOrInterfaceBody(Unknown Source) 
 
 
 at JavaParser.ClassOrInterfaceDeclaration(Unknown Source) 
 
 
 at JavaParser.ClassOrInterfaceBodyDeclaration(Unknown Source) 
 
 
 at JavaParser.ClassOrInterfaceBody(Unknown Source) 
 
 
 at JavaParser.ClassOrInterfaceDeclaration(Unknown Source) 
 
 
 at JavaParser.TypeDeclaration(Unknown Source) 
 
 
 at JavaParser.CompilationUnit(Unknown Source) 
 
 
 at Main.parseFilesFromFileList(Unknown Source) 
 
 
 at Main.main(Unknown Source) 
 
 You can find the file in the sources of the JDK distribution.
 
 Carlos.",,,,,,,,0|i06ulb:,,,,,39949,,,75
javacc,JAVACC-74,duplicating the visitor method,Bug,Closed,Minor,Cannot Reproduce,paulcager,wdixon,wdixon,19/Jan/05 4:21 AM,,02/Sep/08 5:39 AM,02/Sep/08 5:39 AM,current,not determined,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","When trying to make use of the #directives in JJTREE to customize
 the resulting AST - I have run into a minor annoyance - where
 the JavaParserVisitor interface ends up duplicating the visitor method
 
 
 i.e. public Object visit(SimpleNode node, Object data);
 
 
 This happens when I introduce a rule:
 
 
 SimpleNode PrimitiveType() #SimpleNode :
 {Token t;}
 {
 ( ""void"" | ""boolean"" )
 { 
 return jjtThis;
 }
 }",,,,,,,,0|i0earz:,,,,,83395,,,74
javacc,JAVACC-73,Simplify the handing of character streams,Task,Open,Major,Unresolved,kjkoster,kjkoster,kjkoster,15/Jan/05 1:26 PM,,11/Jul/05 6:54 AM,,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Dear JavaCC Gurus,
 
 I think that there's a problem with JavaCC options and
 the API regarding Unicode input. At least they do not
 work as I (intuitively) think they should.
 
 ***********************************************************
 
 Background: I want to write a JavaCC parser that
 reads programs stored in a Unicode file (let's assume it's in Unicode
 UTF-8 encoding). It might include any legal Unicode character
 in the BMP. Assume the language is named Foo and the
 input file is named ""inputFile.utf8"". I.e. inputFile.utf8 is a
 source file written in the Foo language, which makes use of
 Unicode characters. I want to instantiate my JavaCC parser
 using a CharStream, either
 
 Foo parser = new Foo (new SimpleCharStream
 (new InputStreamReader
 (new 
 FileInputStream(""inputFile.utf8""),
 ""UTF-8""))) ;
 
 or
 
 Foo parser = new Foo (new JavaCharStream
 (new InputStreamReader
 (new 
 FileInputStream(""inputFile.utf8""),
 ""UTF-8""))) ;
 
 In both cases, the FileInputStream will provide a stream of raw
 bytes from ""inputFile.utf8"", and the InputStreamReader will interpret
 those bytes as UTF-8 and convert them into 16-bit Java Unicode
 chars. The InputStreamReader then provides a stream of chars.
 Then the SimpleCharStream or JavaCharStream is
 instantiated on the InputStreamReader, providing a bridge to
 the Foo tokenizer. I.e. the Foo tokenizer will repeatedly call the
 SimpleCharStream or JavaCharStream to get the next char.
 
 The only difference between SimpleCharStream and JavaCharStream
 is that JavaCharStream performs the extra trick of intercepting any 6-char
 sequence of the form \uHHHH, where H is a hex digit, and converting it
 into a single 16-bit Java char before sending it to the tokenizer.
 
 That's how I understand it; corrections would be welcome.
 *****************************************************************
 
 JavaCC ""options"" Affecting Unicode Input (as I understand them):
 
 Since JavaCC 2.1 the option UNICODE_INPUT is obsolete
 and ignored. (One now relies on standard Java Reader classes,
 like InputStreamReader in the examples above, to handle
 Unicode. Readers are Unicode-savvy.)
 
 If you set
 USER_CHAR_STREAM = true ; // default is false
 then javacc automatically generates a file CharStream.java
 which is an _interface_; and then YOU have to write a new
 class XXXCharStream.java that implements this CharStream.java
 interface. 
 I want to use the built-in SimpleCharStream.java or JavaCharStream.java,
 so it _seems_ I should leave
 
 USER_CHAR_STREAM = false ;
 
 If you indicate
 
 USER_CHAR_STREAM = false ; // the default value
 JAVA_UNICODE_ESCAPE = false ; // the default value
 
 then JavaCC generates the file SimpleCharStream.java and
 does _not_ generate the interface file CharStream.java
 
 If you indicate
 
 USER_CHAR_STREAM = false ; // the default value
 JAVA_UNICODE_ESCAPE = true ; // the default value
 
 then JavaCC generates the file JavaCharStream.java and
 does not generate the interface CharStream.java
 
 If you indicate
 
 USER_CHAR_STREAM = true ;
 JAVA_UNICODE_ESCAPE = true;
 
 or
 USER_CHAR_STREAM = true;
 JAVA_UNICODE_ESCAPE = false ;
 
 the result is the same:
 JavaCC generates the CharStream.java interface
 but ignores the setting of JAVA_UNICODE_ESCAPE. I.e.
 if USER_CHAR_STREAM = true then neither SimpleCharStream.java
 nor JavaCharStream.java is generated.
 
 **********************************************************************
 
 Problems:
 
 1. Judging by their names, it looks like the automatically generated
 SimpleCharStream.java and JavaCharStream.java classes
 were _intended_ to instantiate CharStream.java, but they do not.
 
 For example, the automatically generated file SimpleCharStream.java starts
 
 /* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 3.0 
 */
 /**
 * An implementation of interface CharStream, where the stream is assumed to
 * contain only ASCII characters (without unicode processing).
 */
 public class SimpleCharStream
 {
 .....
 
 
 In order for it to implement the CharStream interface, the first line
 would have to be
 
 public class SimpleCharStream implements CharStream
 {
 ...
 
 and the interface CharStream.java would need to be generated as well
 to support it. But as shown above, according to the setting of the options,
 if CharStream.java is generated, then neither SimpleCharStream.java
 not JavaCharStream.java is generated. Conversely, if SimpleCharStream.java
 or JavaCharStream.java is generated, then the interface CharStream.java
 it not generated.
 
 
 2. As stated at the beginning, I want/need to instantiate my parser
 using a CharStream, either
 
 Foo parser = new Foo (new SimpleCharStream
 (new InputStreamReader
 (new 
 FileInputStream(""inputFile.utf8""),
 ""UTF-8""))) ;
 
 or
 
 Foo parser = new Foo (new JavaCharStream
 (new InputStreamReader
 (new 
 FileInputStream(""inputFile.utf8""),
 ""UTF-8""))) ;
 
 
 However, as documented in ""The JavaCC API Routines"" (and
 confirmed in my tests), the contructor that accepts a CharStream
 
 TheParser.TheParser(CharStream stream)
 
 ""is available only when the option USER_TOKEN_MANAGER is
 false and USER_CHAR_STREAM is true.""
 
 **************** Problem Summary *************************
 
 A. If you set USER_CHAR_STREAM = true, so that you can use the
 TheParser.TheParser(CharStream stream)
 constructor, JavaCC generates only the CharStream.java
 interface (and not SimpleCharStream.java or JavaCharStream.java)
 
 B. If you set USER_CHAR_STREAM = false, so that JavaCC generates
 SimpleCharStream.java or JavaCharStream.java, then the
 constructors just above become unavailable.
 
 C. In order for the TheParser.TheParser(CharStream stream)
 constructor to work, the argument must be a CharStream, i.e.
 it must implement the CharStream.java interface. But the
 generated files SimpleCharStream.java and JavaCharStream.java,
 whose names suggest that they are implementations of CharStream.java,
 do NOT, in fact, implement CharStream.java.
 
 ******************* Big Question **************************
 
 Am I missing something here? Corrections would be welcome.
 
 Thanks,
 
 Ken Beesley",,,,,,,,0|i01jhb:,,,,,8989,,,73
javacc,JAVACC-72,Usage of ReInit () method,New Feature,Closed,Blocker,Incomplete,sreeni,khurram_faraaz,khurram_faraaz,11/Jan/05 5:23 AM,,14/Jun/09 9:31 AM,14/Jun/09 9:31 AM,current,milestone 1,general,,0,1,,,,,,,,"Operating System: Linux
 Platform: Other","Sir,
 
 I am using javacc.
 I have a separate function that has the lexical specifications and the code
 related for my task.
 
 When i call the method once ,the parser works fine.
 
 But when i call the same method more than once, I get the following error message,
 
 ERROR: Second call to constructor of static parser. You must
 either use ReInit() or set the JavaCC option STATIC to false
 during parser generation.
 
 Please tell me how to use the ReInit method
 
 I pass the input to the parser in this way,
 Convert
 {
 public static void main(String s[])
 {
 String str=Conv_to_unicode(""select ename from emp"");
 System.out.println(str);
 Conv_to_unicode(String temp)
 {
 StringReader r=new StringReader(temp);
 Convert con_obj=new Convert(r);
 ...
 ....
 ......
 }
 }
 }
 
 
 It gives an error if i call the Conv_to_unicode method more than once from the main.
 
 I have also set the static option to true, in the options section.
 
 
 PLease let me know how to use ReInit and overcome the error.
 
 Any help in this regard would be very useful.
 
 Thanking you,
 
 khurram",,,,,,,,0|i020lj:,,,,,11762,,,72
javacc,JAVACC-71,"make JavaCC create paths, not just dirs",Task,Resolved,Major,Fixed,kjkoster,kjkoster,kjkoster,10/Jan/05 1:24 PM,,11/Jul/05 6:54 AM,11/Jul/05 6:54 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","JavaCC creates non-existent directories, but only not the entire path.",,,,,,,,0|i0gad3:,,,,,94992,,,71
javacc,JAVACC-70,JJTree and current state,Bug,Closed,Major,Incomplete,sriram,wdixon,wdixon,10/Jan/05 6:00 AM,,14/Jun/09 9:31 AM,14/Jun/09 9:31 AM,current,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","The documentation suggests something like this:
 
 
 void jjtreeOpenNodeScope(Node n) {
 ((SimpleNode)n).first = getToken(1);
 }
 
 void jjtreeCloseNodeScope(Node n) {
 SimpleNode node = (SimpleNode)n;
 node.last = getToken(0);
 }
 
 
 However - if you are attempting to use #void - to customize the construction of
 the parse tree:
 
 void ConditionalOrExpression() #void :
 {Token t;}
 {
 ConditionalAndExpression() ( t=""||"" ConditionalAndExpression() {
 jjtThis.setType(t); } #BinaryExpression(2) )*
 }
 
 
 It appears that the BinaryExpression node improperly sets the node scope
 using (jjtreeOpenNodeScope) - to the next token after last...
 
 That is - when all is said and done - first == last.next ????
 
 Any ideas how to correct this?",,,,,,,,0|i0eec7:,,,,,83972,,,70
javacc,JAVACC-69,copyright notice in source code is not open source,Bug,Closed,Blocker,Fixed,sreeni,bothner,bothner,09/Jan/05 5:05 PM,,02/Sep/08 1:01 AM,02/Sep/08 1:01 AM,current,4.1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","The copyright notice that appears in most of the javacc source files (for
 example javacc-3.2/src/javacc.java) is *not* an open-source or Free Software
 license. I can go into into more detail if necessary, but it's fairly obvious
 that it violates the Open Source definition in a number of ways,
 
 One might argue that the top-level LICENSE is to one that counts, and it shows
 the *intent* that javacc be open-source. It is also possible that the effective
 license is the ""intersection"" of the top-level LICENSE file and the copyright
 notice in the source files. What counts is what a court of law would decide,
 and I suspect a cautious corporate lawyer might recomend avoiding the whole mess.
 
 I notice that Fedora Core 3 (the most recent version) of Red Hat's
 non-enterprise GNU/Linux distribution ships with Antrl but not javacc. I don't
 know their reasons, but I know Red Hat is very careful about IP issues. I
 certainly would have recommended against including javacc in any collection of
 Free Software because of the unclear licensing.
 
 I marked this as P1 in *my* opinion, because the problem is easily fixable, and
 I think it makes javacc unacceptable to people who are careful about licenses. 
 I was going to use javacc for a presentation, but even for this
 non-mission-critical use I will first see if antlr is suitable.",,,,,,,,0|i08mw7:,,,,,50366,,,69
javacc,JAVACC-68,Examples/SimpleExamples/README incorrect,Bug,Resolved,Major,Fixed,sreeni,gpaulissen,gpaulissen,07/Jan/05 12:28 AM,,22/Dec/05 12:04 PM,22/Dec/05 12:04 PM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","The README in javacc-3.2/Examples/SimpleExamples lists different files
 
 Files in SimpleExamples:
 
 IdList.jj
 NL_Xlator.jj
 README
 Simple1.jj
 Simple2.jj
 Simple3.jj
 
 Files in README:
 
 	Simple1.jj
 	Simple2.jj
 	Simple3.jj
 	Simple4.jj
 	NL_Xlator.jj",,,,,,,,0|i0609r:,,,,,35037,,,68
javacc,JAVACC-67,patch that refactors Options to be safer to work with,Task,Resolved,Major,Fixed,kjkoster,kjkoster,kjkoster,30/Dec/04 1:13 PM,,09/Jan/05 6:48 AM,09/Jan/05 6:48 AM,current,milestone 1,general,,0,1,,,,,,,,"Operating System: All
 Platform: All","I have prepared a patch set that moved all option querying into methods, rather 
 than as string option queries sprinkled all over the place. This patch cleans 
 out three unused options (and their documentation) and includes some fixes to 
 unused imports.
 
 The patch is rather large. I welcome any feedback.
 
 The patch may be found at:
 
 http://www.kjkoster.org/options.patch
 http://www.kjkoster.org/JJTreeOptions.java
 http://www.kjkoster.org/JJDocOptions.java
 
 There are two new Java files that I could not include in the patch itself. Place 
 these in their respective package direcory.",,,,,,,,0|i0a3s7:,,,,,58934,,,67
javacc,JAVACC-66,Token consumed action/callback in parser,New Feature,Open,Major,Unresolved,sriram,trobinson,trobinson,29/Dec/04 4:35 PM,,17/Dec/05 1:16 PM,,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","I would find it very helpful to have a hook in the generated parser when a token
 is consumed, similar to the COMMON_TOKEN_ACTION in the scanner generator. It
 would differ from the COMMON_TOKEN_ACTION in two important ways: 1) it has
 access to the parser state (i.e. as a member of the parser), and 2) it is not
 affected by lookahead, so it is synchronized with other parser actions. This can
 be implemented very easily by adding a call in jj_consume_token(). Here's a
 patch to implement this feature:
 
 diff -ur javacc-3.2/src/org/javacc/parser/Options.java
 javacc-3.2-new/src/org/javacc/parser/Options.java
 --- javacc-3.2/src/org/javacc/parser/Options.java 2003-06-09
 14:45:06.000000000 -0500
 +++ javacc-3.2-new/src/org/javacc/parser/Options.java 2004-12-17
 16:17:11.997625000 -0600
 @@ -89,6 +89,7 @@
 optionValues.put(""FORCE_LA_CHECK"", Boolean.FALSE);
 optionValues.put(""COMMON_TOKEN_ACTION"", Boolean.FALSE);
 optionValues.put(""CACHE_TOKENS"", Boolean.FALSE);
 + optionValues.put(""TOKEN_CONSUMED_HOOK"", Boolean.FALSE);
 optionValues.put(""KEEP_LINE_COLUMN"", Boolean.TRUE);
 optionValues.put(""OUTPUT_DIRECTORY"", ""."");
 }
 diff -ur javacc-3.2/src/org/javacc/parser/ParseGen.java
 javacc-3.2-new/src/org/javacc/parser/ParseGen.java
 --- javacc-3.2/src/org/javacc/parser/ParseGen.java 2003-08-08
 14:21:56.000000000 -0500
 +++ javacc-3.2-new/src/org/javacc/parser/ParseGen.java 2004-12-17
 16:21:22.872625000 -0600
 @@ -385,6 +385,9 @@
 if (Options.B(""DEBUG_PARSER"")) {
 ostr.println("" trace_token(token, \""\"");"");
 }
 + if (Options.B(""TOKEN_CONSUMED_HOOK"")) {
 + ostr.println("" jj_token_consumed(token);"");
 + }
 ostr.println("" return token;"");
 ostr.println("" }"");
 if (Options.B(""CACHE_TOKENS"")) {
 
 As a concrete usage of this feature, I have found it to be a very
 straightforward way to associate comments with objects built by the parser. For
 example:
 
 PARSER_BEGIN(MyParser)
 public class MyParser
 {
 private SourceObject curObj;
 private final LinkedList objStack = new LinkedList();
 
 private void beginCapture(SourceObject obj)
 {
 objStack.addLast(curObj);
 curObj = obj;
 }
 
 private void endCapture(SourceObject obj)
 {
 assert (obj == curObj);
 curObj = (SourceObject) objStack.removeLast();
 }
 
 private void jj_token_consumed(Token t)
 {
 if (curObj != null)
 {
 curObj.applyCommentsFrom(t);
 }
 }
 }
 PARSER_END(MyParser)
 
 ProgramDecl program_decl() :
 {
 String id;
 ProgramDecl program = new ProgramDecl();
 beginCapture(program);
 }
 {
 <PROGRAM> id = identifier() { program.setIdentifier(id); }
 (
 <LBRACE> program_block_body(program) <RBRACE>
 |
 <BEGIN> program_block_body(program) <END>
 )
 {
 endCapture(program);
 return program;
 }
 }
 
 Here, every time the parser consumes a terminal, it can associate any comments
 contained in its special token chain with the non-terminal wrapper object
 currently on the top of the object stack.",,,,,,,,0|i08i5z:,,,,,49600,,,66
javacc,JAVACC-65,Object-oriented extensibility for JavaCC,Improvement,Open,Major,Unresolved,sreeni,trobinson,trobinson,28/Dec/04 1:38 PM,,30/Nov/12 6:00 PM,,current,not determined,general,,2,1,,,,,,,,"Operating System: All
 Platform: All","I think the most useful improvements for a future release of JavaCC (4.0?)
 concern it's object-oriented extensibility. Currently, JavaCC outputs a large
 number of static files (Token, TokenManager, ParseException, TokenMgrError,
 etc.) in addition to large amounts of boilerplate code in generated parsers.
 JavaCC would be much easier to extend, and JavaCC-based projects easier to
 maintain, if the static files were placed in a library and the boilerplate
 scanner/parser code were moved to library base classes.
 
 As a specific example, it is currently very awkward to have the TokenManager
 instantiate derived Token classes. The documented way to do this is to modify
 the generated Token.java file and add subclass instantiation cases to the switch
 statement in newToken(). In addition to causing JavaCC to generate a warning,
 this approach makes it difficult to upgrade to new versions of JavaCC if they
 generate a different Token.java. Moving Token.java to a JavaCC-supplied library
 and introducing a factory method in the scanner base class would be a much
 better approach. In addition to removing the need to modify generated code, it
 would allow arbitrary scanner state (such as what file is being read) to be
 associated with the token.",,,,,,,,0|i04tf3:,,,,,28095,,,65
javacc,JAVACC-64,Ant scripts fail when using Java 1.5,Bug,Resolved,Major,Fixed,sreeni,jwesley,jwesley,18/Dec/04 11:23 AM,,24/Dec/04 10:11 AM,24/Dec/04 10:11 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","When running ant scripts the compiler fails saying ""(try -source 1.4 or lower to
 use 'enum' as an identifier)"".
 
 Simply adding 'source=""1.4""' to the ""javac"" task in the ant scripts will allow
 it to compile successfully.",,,,,,,,0|i02us7:,,,,,16652,,,64
javacc,JAVACC-63,"JJT...State may be left in an inconsistent state, resulting in an EmptyStackException",Bug,Open,Major,Unresolved,sriram,danwyand,danwyand,13/Dec/04 1:07 AM,,11/Nov/07 3:37 PM,,current,4.0,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","Summary:
 
 jjtree generates code that may be left in an inconsistent state if a user
 implementation of Node.jjtClose throws an exception. In this inconsistent state,
 the generated code will call JJT...State.closeNodeScope on the same node
 multiple times, possibly resulting in an EmptyStackException when trying to pop
 a node off of the marks stack. This EmptyStackException masks the original
 exception, and makes the fault very difficult to find.
 
 
 Details:
 
 jjtree marks nodes as closed by setting jjtcNNNN (referred to here as the ""jjtc
 flag"") to false, AFTER a call to closeNodeScope. The jjtc flag is then used in
 catch and finally clauses to see if the node should be closed.
 
 The call to closeNodeScope first closes the node scope, and then calls
 Node.jjtClose, which is intended to be implemented by the user. If the user's
 implementation of Node.jjtClose throws a RuntimeException, the jjtc flag is
 never set to false, and catch/finally clauses see the inconsistent value of the
 jjtc flag and call closeNodeScope on the already-closed node.
 
 
 Fix:
 
 By setting the jjtc flag to false before calling closeNodeScope, any calls to
 jjtClose will be made only when the parser is in a consistent state, and
 exceptions from jjtClose will not break JJT...State.
 
 For calls to closeNodeScope involving a non-trivial condition, the condition
 will have to be tested prior to setting the jjtc flag. I would suggest that
 generated code that looks like:
 
 jjtree.closeNodeScope(jjtn<number>, <condition>);
 jjtc<number> = false;
 
 should instead be generated as:
 
 if (<condition>) {
 jjtc<number> = false;
 jjtree.closeNodeScope(jjtn<number>, true);
 }
 
 It is worth noting that the jjtree documentation explicitly states that node
 creation conditions may be called any number of times and in any order, so a fix
 that may fit existing code better but evaluates the condition multiple times
 should be perfectly acceptable.",,,,,,,,0|i050yf:,,,,,29316,,,63
javacc,JAVACC-62,packaging with JJTree,Bug,Closed,Major,Duplicate,sriram,durrieu,durrieu,30/Nov/04 11:04 PM,,02/Sep/08 5:27 AM,02/Sep/08 5:27 AM,current,4.1,jjtree,,1,0,,,,,,,,"Operating System: Solaris
 Platform: Sun","JJTree gives the ability (option MULTI) to produce a bunch of java
 class files which represent the abstract syntax tree nodes of a given
 XXX language.
 
 JJTree gives the ability (option NODE_PACKAGE) to put these nodes and
 the parser in separate packages, which may be desirable for
 structuring the tool under development.
 
 However:
 
 - node classes don't include any reference to the parser package, so the
 XXXParser symbol cannot be resolved when compiling the nodes created
 by JJTree. 
 
 - neither the JJTXXXParserState class (in the node package) nor the
 methods inside that class are public. When accessed from the parser
 package, they also produce compile time errors.
 
 Well, that works fine after ""manually"" updating the different node
 classes and the JJTXXXParserState class, but I would expect that this
 kind of work be automatically done by JJTree. Otherwise, the
 NODE_PACKAGE option does not seem very usable.",,,,,,,,0|i0e3tr:,,,,,82269,,,62
javacc,JAVACC-61,Cannot compile CalcInput.jj,Bug,Resolved,Major,Fixed,sriram,sreeni,sreeni,30/Nov/04 8:21 PM,,11/Jul/05 6:54 AM,11/Jul/05 6:54 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","The new javacc (with 1.5 support) fails to generate the parser for CalcInput.jj
 in the examples.",,,,,,,,0|i02qa7:,,,,,15923,,,61
javacc,JAVACC-60,Strict syntax in generated java code,Task,Closed,Major,Incomplete,sriram,ephemeris,ephemeris,23/Nov/04 10:14 PM,,14/Jun/09 9:30 AM,14/Jun/09 9:30 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Hello.
 
 When people need something, they use to say first some flaterry, and then ask 
 what they come for... but, sincerely, JavaCC is quite a fantastic stuff !!!
 
 Now, my question...
 
 I generally use Eclipse for my works, and set all its warning options on. Thus, 
 many possible defaults of my poor code immediately appear : unused variables, 
 masking declarations, unthrown exceptions, unnecessary else, empty statements, 
 etc.
 
 Although this is not a severe problem, the classes JavaCC generates for a 
 simple arithmetical expressions parser i'm a about to add to an application 
 produce ... 437 warnings !!! that just make my code control a bit more 
 difficult...
 
 I don't know if all of this 'imperfections' could be fixed, but perhaps some of 
 them...
 
 Thanks anyway.
 Regards.
 
 Ephemeris Lappis",,,,,,,,0|i0coan:,,,,,73921,,,60
javacc,JAVACC-59,hitting ctrl-c at the wrong point can leave corrupted files,Bug,Open,Major,Unresolved,paulcager,doogie,doogie,20/Nov/04 1:16 PM,,25/Nov/10 6:52 PM,,current,not determined,general,,0,0,,,,,,,JAVACC-9,"Operating System: All
 Platform: All","When writting files, if the user hits ctrl-c, then the file may be half written.
 Build systems will then assume the file is uptodate, and an error will occur
 when compiling later on.
 
 It'd be better to write to a tmp file, and rename at the end if no errors occur.
 
 The attached patch does this, by implementing a CommitableFileWriter. This
 class extends FileWriter, and writes to .tmp automatically. If the
 .setCommit(true) is later called *before* calling close, then the file will be
 renamed.",,,,,,,,0|i0bek7:,,,,,66512,,,59
javacc,JAVACC-58,improve output of debug messages,Improvement,Resolved,Major,Duplicate,sriram,doogie,doogie,20/Nov/04 1:14 PM,,16/Jan/08 2:41 PM,16/Jan/08 2:41 PM,current,4.0,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","The trace_* methods use a for loop, and print a single space at a time, for each
 level of indent. The attached patch uses a StringBuffer, and does appends and
 setLength to change indent. Huge speedup.",,,,,,,,0|i0dm8n:,,,,,79420,,,58
javacc,JAVACC-57,return in java block produces,Bug,Closed,Critical,Incomplete,sriram,esarge,esarge,07/Nov/04 11:01 AM,,14/Jun/09 9:29 AM,14/Jun/09 9:29 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","I believe this is a defect but it's possible I am misunderstanding how to use
 JavaCC. I think that the detection code for a return statement in a java block
 is at fault.
 
 I have this snippet of code in a much larger .jj file:
 
 long Condition() :
 { long instructionCount = 0;}
 {
 	(LOOKAHEAD(4) <NOT> Condition() 
 |	ConditionItem() [LOOKAHEAD(2) (<AND>|<OR>) Condition()] )
 	
 		{ 
 			return ++instructionCount; 
 		}
 }
 
 However the matching code in the .java file says this:
 static final public long Condition() throws ParseException {
 trace_call(""Condition"");
 try {
 long instructionCount = 0;
 if (jj_2_17(4)) {
 jj_consume_token(NOT);
 Condition();
 } else if (jj_2_18(1)) {
 ConditionItem();
 if (jj_2_16(2)) {
 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
 case AND:
 jj_consume_token(AND);
 break;
 case OR:
 jj_consume_token(OR);
 break;
 default:
 jj_la1[35] = jj_gen;
 jj_consume_token(-1);
 throw new ParseException();
 }
 Condition();
 } else {
 ;
 }
 } else {
 jj_consume_token(-1);
 throw new ParseException();
 }
 {if (true) return ++instructionCount;}
 throw new Error(""Missing return statement in function"");
 } finally {
 trace_return(""Condition"");
 }
 }
 
 Note that Error being thrown.
 
 Note this snippet from JavaCC.jj
 void ReturnStatement() :
 	{
 	 Token t;
 	}
 {
 t=""return""
 	{
 	 // Add if statement to prevent subsequent code generated
 	 // from being dead code.
 	 if (inAction) {
 	 t.image = ""{if (true) return"";
 	 jumpPatched = true;
 	 }
 	}
 [
 Expression(new java.util.Vector())
 ]
 t="";""
 	{
 	 // Add closing brace for above if statement.
 	 if (inAction) {
 	 t.image = "";}"";
 	 }
 	}
 }
 
 Note that jumpPatched is being set to true.
 
 Now note this snippet of code from ParseEngine.java
 if (p.jumpPatched && !voidReturn) {
 ostr.println("" throw new Error(\""Missing return statement in
 function\"");"");
 }
 
 I don't pretend to understand all the implications of the use of the jumpPatched
 flag but my initial guess is that the if condition should be:
 if (!p.jumpPatches && !voidReturn).
 
 If somebody confirms that my usage and rationale is correct then I'll go ahead
 and test it.",,,,,,,,0|i03lin:,,,,,20983,,,57
javacc,JAVACC-56,wrong code generation,Bug,Closed,Major,Incomplete,sriram,vyzivus,vyzivus,31/Oct/04 12:57 PM,,14/Jun/09 9:29 AM,14/Jun/09 9:29 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","I have the following jj file:
 
 PARSER_BEGIN(T2Xslt)
 package sk.baka.t2xslt.convertor;
 
 public class T2Xslt {}
 PARSER_END(T2Xslt)
 TOKEN:
 {
 <A: ""A""> | <B: ""B""> | <C:""C""> | <D:""D"">
 }
 
 void condition() :
 {
 }
 {
 	( <A> )?
 	( <B> )?
 	(
 		<C>
 	) | (
 		<D>
 	)
 }
 
 
 this generates the following java code (only relevant code pasted):
 static final public void condition() throws ParseException {
 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
 case A:
 case B:
 case C:
 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
 case A:
 jj_consume_token(A);
 break;
 default:
 jj_la1[0] = jj_gen;
 ;
 }
 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
 case B:
 jj_consume_token(B);
 break;
 default:
 jj_la1[1] = jj_gen;
 ;
 }
 jj_consume_token(C);
 break;
 case D:
 jj_consume_token(D);
 break;
 default:
 jj_la1[2] = jj_gen;
 jj_consume_token(-1);
 throw new ParseException();
 }
 }
 
 which does not accept the ABD sequence.",,,,,,,,0|i074bz:,,,,,41527,,,56
javacc,JAVACC-55,"""All except""-lexical state list for token manager",Improvement,Resolved,Major,Won't Fix,sriram,florianlieb,florianlieb,22/Oct/04 5:20 AM,,11/Jul/05 6:54 AM,11/Jul/05 6:54 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Hi,
 
 i am making extensive use of the token managers lexical states in my grammar
 definition, in which I have tokens that are valid in all lexical states except
 one or two.
 
 I can't use the lexical state list construct ""<*> TOKEN :"", since this would
 match the tokens even in the invalid states. Furthermore I don't want to write
 all the states in a lexical state list, since this would surely lead to bugs
 when adding new states.
 
 Therefore it would be cool to have a lexical state list construct like 
 ""<~LEXSTATE1, LEXSTATE2> TOKEN :"",
 which matches the following reg-exps on all lexical states EXCEPT the given ones.
 
 I appended my enhancements below. However, they only work with Java 1.2
 (Collections!) and only on lexical states that were already defined.
 
 It would be cool to consider this enhancement for the next javaCC release ?!?
 
 Bye,
 F l:o)
 
 
 PS: Enhancements on the JavaCC grammar to support ALL-EXCEPT-lexical state lists:
 
 ...
 
 // ENHANCEMENT -->
 // added a set of lexical states already visited.
 
 /** A set of all lexical states of the token manager */
 java.util.Set lexStates = new java.util.HashSet();
 
 // <-- ENHANCEMENT
 
 
 ...
 
 void regular_expr_production() :
 
 ...
 [
 LOOKAHEAD(2) ""<"" ""*"" "">""
 ...
 
 // ENHANCEMENT -->
 // added a new choice matching ""<"" ""~"" ... productions
 
 | LOOKAHEAD(2) 
 ""<"" ""~"" { states = new java.util.Vector(); }
 t=<IDENTIFIER> { states.addElement(t.image); }
 (
 "","" t=<IDENTIFIER> { states.addElement(t.image); }
 )*
 "">""
 {
 	java.util.Set lexSet = new java.util.HashSet(lexStates);
 	lexSet.removeAll(states);
 p.lexStates = new String[lexSet.size()];
 lexSet.toArray(p.lexStates);
 }
 // <-- ENHANCEMENT
 
 |
 ""<"" { states = new java.util.Vector(); }
 t=<IDENTIFIER> { states.addElement(t.image); }
 (
 "","" t=<IDENTIFIER> { states.addElement(t.image); }
 )*
 "">""
 {
 p.lexStates = new String[states.size()];
 
 // ENHANCEMENT -->
 // add lexical states to the set of already visited states
 
 lexStates.addAll(states); // ENHANCEMENT
 
 // <-- ENHANCEMENT
 for (int i = 0; i < states.size(); i++) {
 p.lexStates[i] = (String)states.elementAt(i);
 }
 }
 ]
 ...",,,,,,,,0|i080vj:,,,,,46799,,,55
javacc,JAVACC-54,Bug in generated code?,Bug,Closed,Major,Incomplete,sreeni,martianalien,martianalien,20/Oct/04 5:58 AM,,14/Jun/09 9:28 AM,14/Jun/09 9:28 AM,current,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","I downloaded javacc-3.2 last week.
 
 In my token definitions I have the following
 
 <SQL: ( <SQLCOMMAND> ( <SQLPREFIX> ( ~[ "";"" ] )* )? "";"")>
 
 | <#SQLPREFIX: ( <NOTID> | ""someText"" ) >
 
 | <#NOTID: ~[ ""\"""", ""'"", ""/"", ""a""-""z"", ""A""-""Z"", ""_"", ""0""-""9"", ""$"", ""#"", ""%"",
 ""-"", "";"" ]>
 
 | <#SQLCOMMAND: ""delete"" | ""select"" | ...>
 
 SQLPREFIX seems to be matching the empty string since the pattern is accepting
 alphabetic characters (e.g. ""deleteItem"" matches). If I remove the alternative
 ""someText"", the pattern works as I expect (deleteItem is not matched). This
 seems to imply that adding an alternative to SQLPREFIX allows it to match the
 empty string.
 
 | <#SQLPREFIX: ( <NOTID> )>",,,,,,,,0|i09kbr:,,,,,55782,,,54
javacc,JAVACC-53,Improve support for GCJ,Improvement,Closed,Major,Fixed,paulcager,osafandi,osafandi,14/Oct/04 11:11 AM,,02/Sep/08 12:58 AM,02/Sep/08 12:58 AM,current,4.1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","The Java Lucene project intends to support GNU's java compiler, GCJ. JavaCC
 generates code that contains static fields and methods of the same name, in the
 format 'jj_la1_0'. GCJ's C++ header generator, GCJH, reports this as an error.
 It would be nice if JavaCC were instead to generate two names: jj_la1_0 for the
 field and jj_la1_0_mth() for the method, for example.",,,,,,,,0|i0dy8f:,,,,,81363,,,53
javacc,JAVACC-52,ReInit methods in SimpleCharStream are not static,Bug,Resolved,Major,Won't Fix,sreeni,martianalien,martianalien,08/Oct/04 9:30 AM,,24/Dec/04 10:01 AM,24/Dec/04 10:01 AM,current,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","The corresponding methods in the old ASCII_CharStream were static.
 
 In any case, when the parser is generated as a static parser, it makes more
 sense for these methods to be static.",,,,,,,,0|i03gvr:,,,,,20232,,,52
javacc,JAVACC-51,jjtree complains about token with range regexp,Bug,Resolved,Blocker,Fixed,sriram,chen,chen,07/Sep/04 11:52 AM,,11/Jul/05 6:53 AM,11/Jul/05 6:53 AM,current,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: Linux
 Platform: All","jjtree complains about a token like:
 
 TOKEN :
 {
 < DUMMY: ([""0""-""9""]){1,3} >
 }
 
 which is valid and accepted by javacc. It's caused by the range part ""{min,
 max}"", is this a known bug?",,,,,,,,0|i0bx7b:,,,,,69532,,,51
javacc,JAVACC-50,jjtree modifies non-ascii characters to unicode escape sequence \ufffd,Bug,Closed,Major,Cannot Reproduce,sriram,hfaber,hfaber,04/Sep/04 8:18 AM,,02/Sep/08 1:08 AM,02/Sep/08 1:08 AM,current,4.1,jjtree,,0,0,,,,,,,,"Operating System: Linux
 Platform: PC","When a ISO8859-1 character that is not in the ASCII subset is used in the .jjt
 file, this character is changed in the .jj file into the unicode escape sequence
 \ufffd, making the language description incorrect.
 Example:
 In the .jjt file:
 TOKEN :
 {
 <UPPERCASE_LETTER : [""A""-""Z"",
 ""Ã€"", ""Ã�"", ""Ã‚"", ""Ãƒ"", ""Ã„"", ""Ã…"", ""Ã†"",
 ""Ã‡"", ""Ãˆ"", ""Ã‰"", ""ÃŠ"", ""Ã‹"", ""ÃŒ"", ""Ã�"", ""ÃŽ"", ""Ã�"",
 ""Ã�"", ""Ã‘"", ""Ã’"", ""Ã“"", ""Ã•"", ""Ã”"", ""Ã–"", ""Ã˜"",
 ""Ã™"", ""Ãš"", ""Ã›"", ""Ãœ"", ""Ã�"", ""Ãž""] >
 }
 
 changes to this in the .jj file (which is clearly not the same):
 TOKEN :
 {
 <UPPERCASE_LETTER : [""A""-""Z"",
 ""\ufffd"", ""\ufffd"", ""\ufffd"", ""\ufffd"", ""\ufffd"",
 ""\ufffd"", ""\ufffd"",
 ""\ufffd"", ""\ufffd"", ""\ufffd"", ""\ufffd"", ""\ufffd"",
 ""\ufffd"", ""\ufffd"", ""\ufffd"", ""\ufffd"",
 ""\ufffd"", ""\ufffd"", ""\ufffd"", ""\ufffd"", ""\ufffd"",
 ""\ufffd"", ""\ufffd"", ""\ufffd"",
 ""\ufffd"", ""\ufffd"", ""\ufffd"", ""\ufffd"", ""\ufffd"",
 ""\ufffd""] >
 }",,,,,,,,0|i03nlb:,,,,,21319,,,50
javacc,JAVACC-49,Java gramamr doesn't accept non-ASCII identifiers,Bug,Resolved,Major,Fixed,sreeni,sreeni,sreeni,20/Aug/04 5:42 PM,,20/Aug/04 5:44 PM,20/Aug/04 5:44 PM,current,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","It looks like the definition of the IDENTIFIER token is out of date. So the Java
 grammar cannot some legal Java programs using identifiers consisting of
 non-ASCII characters - like Japanese ones.",,,,,,,,0|i0bfk7:,,,,,66674,,,49
javacc,JAVACC-48,custom superclass for simplenode,New Feature,Closed,Major,Fixed,paulcager,eirikma,eirikma,20/Jul/04 2:13 AM,,02/Sep/08 12:56 AM,02/Sep/08 12:56 AM,current,4.1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","Make jjtree have an option for setting a (custom) superclass for simpleNode. In
 general, JavaCC/JJtree shouldn't be so dependant on users editing the generated
 files or putting too much functionality inside the grammar files. 
 
 
 Rationale:
 If you work with modern tools for complex building and integration of systems,
 such as apache maven or ant, you may expect to have all build-time-generated
 files re-generated every 30 minutes or so. That means: all auto-generated files,
 such as the output of jjtree / javacc are ""no touch"". Any manual changes have to
 be reapplied 15 times a day. For projects with many developers, this is of
 course totally unmanageble as well, since everybody would make the necessary
 modifications in a different way and 90% of the project members doesn't
 understand how javacc works (except for the fact that it messes up the
 sourcefiles so you no longer can build them correctly from the script).",,,,,,,,0|i09ykn:,,,,,58090,,,48
javacc,JAVACC-47,Spurious match failure,Bug,Closed,Major,Incomplete,sreeni,xoltar,xoltar,30/Jun/04 10:10 AM,,14/Jun/09 9:28 AM,14/Jun/09 9:28 AM,current,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","I have a grammar which includes a token definition (in addition to some other
 things, of course):
 
 	 < SIMPLE_STRING:
 		""\""""
 	 ( (~[""\"""",""\\"",""\n"",""\r""])
 	| (""\\""
 	 ( [""n"",""t"",""b"",""r"",""f"",""\\"",""'"",""\""""]
 	 | [""0""-""7""] ( [""0""-""7""] )?
 	 | [""0""-""3""] [""0""-""7""] [""0""-""7""]
 	 )
 	 )
 	 )*
 		""\""""
 	 >
 
 When I use the generated parser, I get the following error. I don't see how
 ""TEST"" doesn't meet the requirements of <SIMPLE_STRING>. If this indicates some
 kind of error in my grammar, please consider this a request for better error
 messages.
 
 Exception in thread ""main"" jenkon.xml.jkdl.ParseException: Encountered ""\""TEST\""
 "" at line 5, column 9.
 Was expecting one of:
 ""}"" ...
 ""remove"" ...
 <COMMENT> ...
 <SIMPLE_STRING> ...",,,,,,,,0|i0b5jr:,,,,,65052,,,47
javacc,JAVACC-46,java.lang.OutOfMemoryError: Java heap space,Bug,Closed,Major,Incomplete,sriram,kvman,kvman,28/Jun/04 2:54 PM,,02/Sep/08 5:52 AM,02/Sep/08 5:52 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","I was trying to run the grammar (inlined at the end of this mail) through
 javacc-3.2 and got the following error :
 
 Java Compiler Compiler Version 3.2 (Parser Generator)
 (type ""javacc"" with no arguments for help)
 Reading from file CExpr.jjt . . .
 Exception in thread ""main"" java.lang.OutOfMemoryError: Java heap space
 
 The grammar is really not that big.
 Any suggestions?
 
 Manjunath
 
 The .jjt file :
 
 PARSER_BEGIN(CExpr)
 
 import java.io.*;
 
 public class CExpr {
 public static void main(String args[]) throws ParseException {
 String expression = new String(""d0 = s0 + s1"");
 CExpr parser = new CExpr(new StringReader( expression ));
 parser.Expr();
 }
 }
 
 PARSER_END(CExpr)
 
 SKIP :
 {
 "" ""
 | ""\t""
 | ""\n""
 | ""\r""
 }
 
 TOKEN : {
 <INTEGER_LITERAL: <DECIMAL_LITERAL> ([""l"",""L""])? | <HEX_LITERAL> ([""l"",""L""])? | 
 <OCTAL_LITERAL> ([""l"",""L""])?>
 | <#DECIMAL_LITERAL: [""1""-""9""] ([""0""-""9""])*>
 | <#HEX_LITERAL: ""0"" [""x"",""X""] ([""0""-""9"",""a""-""f"",""A""-""F""])+>
 | <#OCTAL_LITERAL: ""0"" ([""0""-""7""])*>
 | <FLOATING_POINT_LITERAL: ([""0""-""9""])+ ""."" ([""0""-""9""])* (<EXPONENT>)? ([""f"",
 ""F"",""d"",""D""])? | ""."" ([""0""-""9""])+ (<EXPONENT>)? ([""f"",""F"",""d"",""D""])? | 
 ([""0""-""9""])+ <EXPONENT> ([""f"",""F"",""d"",""D""])? | ([""0""-""9""])+ (<EXPONENT>)? [""f"",
 ""F"",""d"",""D""]>
 | <#EXPONENT: [""e"",""E""] ([""+"",""-""])? ([""0""-""9""])+>
 | <CHARACTER_LITERAL: ""\'"" (~[""\'"",""\\"",""\n"",""\r""] | ""\\"" ([""n"",""t"",""b"",""r"",
 ""f"",""\\"",""\'"",""\""""] | [""0""-""7""] ([""0""-""7""])? | [""0""-""3""] [""0""-""7""] [""0""-""7""])) 
 ""\'"">
 | <STRING_LITERAL: ""\"""" (~[""\"""",""\\"",""\n"",""\r""] | ""\\"" ([""n"",""t"",""b"",""r"",""f"",
 ""\\"",""\'"",""\""""] | [""0""-""7""] ([""0""-""7""])? | [""0""-""3""] [""0""-""7""] [""0""-""7""]))* 
 ""\"""">
 }
 
 TOKEN : {
 <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
 | <#LETTER: [""$"",""A""-""Z"",""_"",""a""-""z""]>
 | <#DIGIT: [""0""-""9""]>
 }
 
 void Expr() :
 {
 }
 {
 AssignmentExpr() |
 AssignmentExpr() ExprDash()
 }
 
 void ExprDash() :
 {
 }
 {
 "";"" AssignmentExpr() |
 "";"" AssignmentExpr() ExprDash()
 }
 
 void AssignmentExpr() :
 {
 }
 {
 ConditionalExpr() |
 UnaryExpr() AssignmentOperator() AssignmentExpr()
 }
 
 void AssignmentOperator() :
 {
 }
 {
 ""="" | ""*="" | ""/="" | ""%="" | ""+="" | ""-="" | ""<<="" | "">>="" | ""&="" | ""|="" | ""^=""
 }
 
 void ConditionalExpr() :
 {
 }
 {
 LogicalOrExpr() |
 LogicalOrExpr() ""?"" Expr() "":"" ConditionalExpr()
 }
 
 void ConstExpr() :
 {
 }
 {
 ConditionalExpr()
 }
 
 void LogicalOrExpr() :
 {
 }
 {
 LogicalAndExpr() |
 LogicalAndExpr() LogicalOrExprDash()
 }
 
 void LogicalOrExprDash() :
 {
 }
 {
 ""||"" LogicalAndExpr() | ""||"" LogicalAndExpr() LogicalOrExprDash()
 }
 
 void LogicalAndExpr() :
 {
 }
 {
 InclusiveOrExpr() |
 InclusiveOrExpr() LogicalAndExprDash()
 }
 
 void LogicalAndExprDash() :
 {
 }
 {
 ""&&"" InclusiveOrExpr() | ""&&"" InclusiveOrExpr() LogicalAndExprDash()
 }
 
 void InclusiveOrExpr() :
 {
 }
 {
 ExclusiveOrExpr() |
 ExclusiveOrExpr() InclusiveOrExprDash()
 }
 
 void InclusiveOrExprDash() :
 {
 }
 {
 ""|"" ExclusiveOrExpr() | ""|"" ExclusiveOrExpr() InclusiveOrExprDash()
 }
 
 void ExclusiveOrExpr() :
 {
 }
 {
 AndExpr() |
 AndExpr() ExclusiveOrExprDash()
 }
 
 void ExclusiveOrExprDash() :
 {
 }
 {
 ""^"" AndExpr() | ""^"" AndExpr() ExclusiveOrExprDash()
 }
 
 void AndExpr() :
 {
 }
 {
 EqualityExpr() |
 EqualityExpr() AndExprDash()
 }
 
 void AndExprDash() :
 {
 }
 {
 ""&"" EqualityExpr() | ""&"" EqualityExpr() AndExprDash()
 }
 
 void EqualityExpr() :
 {
 }
 {
 RelationalExpr() |
 RelationalExpr() EqualityExprDash()
 }
 
 void EqualityExprDash() :
 {
 }
 {
 ""=="" RelationalExpr() | ""=="" RelationalExpr() EqualityExprDash() |
 ""!="" RelationalExpr() | ""!="" RelationalExpr() EqualityExprDash()
 }
 
 void RelationalExpr() :
 {
 }
 {
 ShiftExpr() |
 ShiftExpr() RelationalExprDash()
 }
 
 void RelationalExprDash() :
 {
 }
 {
 ""<"" ShiftExpr() | ""<"" ShiftExpr() RelationalExprDash() |
 "">"" ShiftExpr() | "">"" ShiftExpr() RelationalExprDash() |
 ""<="" ShiftExpr() | ""<="" ShiftExpr() RelationalExprDash() |
 "">="" ShiftExpr() | "">="" ShiftExpr() RelationalExprDash()
 }
 
 void ShiftExpr() :
 {
 }
 {
 AdditiveExpr() |
 AdditiveExpr() ShiftExprDash()
 }
 
 void ShiftExprDash() :
 {
 }
 {
 ""<<"" AdditiveExpr() | ""<<"" AdditiveExpr() ShiftExprDash() |
 "">>"" AdditiveExpr() | "">>"" AdditiveExpr() ShiftExprDash()
 }
 
 void AdditiveExpr() :
 {
 }
 {
 MultExpr() |
 MultExpr() AdditiveExprDash()
 }
 
 void AdditiveExprDash() :
 {
 }
 {
 ""+"" MultExpr() | ""+"" MultExpr() AdditiveExprDash() |
 ""-"" MultExpr() | ""-"" MultExpr() AdditiveExprDash()
 }
 
 void MultExpr() :
 {
 }
 {
 UnaryExpr() |
 UnaryExpr() MultExprDash()
 }
 
 void MultExprDash() :
 {
 }
 {
 ""*"" UnaryExpr() | ""*"" UnaryExpr() MultExprDash() |
 ""/"" UnaryExpr() | ""/"" UnaryExpr() MultExprDash() |
 ""%"" UnaryExpr() | ""%"" UnaryExpr() MultExprDash()
 }
 
 void UnaryExpr() :
 {
 }
 {
 PostfixExpr() |
 ""++"" UnaryExpr() |
 ""--"" UnaryExpr() |
 UnaryOperator() UnaryExpr()
 }
 
 void UnaryOperator() :
 {
 }
 {
 ""&"" | ""*"" | ""+"" | ""-"" | ""~"" | ""!""
 }
 
 void PostfixExpr() :
 {
 }
 {
 PrimaryExpr() |
 PrimaryExpr() PostfixExprDash()
 }
 
 void PostfixExprDash() :
 {
 }
 {
 ""["" Expr() ""]"" | ""["" Expr() ""]"" PostfixExprDash() |
 ""("" ArgumentExprList() "")"" | ""("" ArgumentExprList() "")"" PostfixExprDash() |
 ""("" "")"" | ""("" "")"" PostfixExprDash() |
 ""."" <IDENTIFIER> | ""."" <IDENTIFIER> PostfixExprDash() |
 ""->"" <IDENTIFIER> | ""->"" <IDENTIFIER> PostfixExprDash() |
 ""++"" | ""++"" PostfixExprDash() |
 ""--"" | ""--"" PostfixExprDash()
 }
 
 void PrimaryExpr() :
 {
 }
 {
 <IDENTIFIER> |
 Const() |
 <STRING_LITERAL> |
 ""("" Expr() "")""
 }
 
 void ArgumentExprList() :
 {
 }
 {
 AssignmentExpr() |
 AssignmentExpr() ArgumentExprListDash()
 }
 
 void ArgumentExprListDash() :
 {
 }
 {
 "","" AssignmentExpr() | "","" AssignmentExpr() ArgumentExprListDash()
 }
 
 void Const() :
 {
 }
 {
 <INTEGER_LITERAL> |
 <CHARACTER_LITERAL> |
 <FLOATING_POINT_LITERAL>
 }",,,,,,,,0|i074xr:,,,,,41625,,,46
javacc,JAVACC-45,Parser can contain unnecessary conditionals...,Improvement,Closed,Major,Incomplete,sriram,tcopeland,tcopeland,18/Jun/04 1:32 PM,,14/Jun/09 9:27 AM,14/Jun/09 9:27 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","...i.e., things like:
 
 if (jjte000 instanceof ParseException) {
 {if (true) throw (ParseException)jjte000;}
 }
 
 Seems like we could eliminate some of these... just filing this in case someone
 with a bit more JavaCC-savvyness than me is interested in looking at this...
 
 Yours,
 
 tom",,,,,,,,0|i02x13:,,,,,17016,,,45
javacc,JAVACC-44,Certain regular expression cause erroneous scanner generation,Bug,Closed,Blocker,Incomplete,sreeni,vigna,vigna,21/May/04 8:46 AM,,02/Sep/08 5:50 AM,02/Sep/08 5:50 AM,current,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All
 URL: http://vigna.dsi.unimi.it/qp.jj","Download the grammar at the given address. It should parse strings as ""a"" as a
 word. This happens *unless* you uncomment the definition of WORDCHAR, which
 however is *not used* by the grammar. Apparently, the addition of WORDCHAR's
 regular expression breaks the scanner generation process.
 
 To replicate, after ""javacc qp.jj"" and compilation try ""java qp a"". Then,
 uncomment WORCHAR's definition, recompile and try again. We get
 
 Exception in thread ""main"" ParseException: Encountered ""a"" at line 1, column 1.
 Was expecting:
 <WORD> ...
 
 which of course should not happen.
 
 This bug is particularly nasty because the only workaround was fiddling with the
 regex definition until the parser started working.",,,,,,,,0|i0cc2n:,,,,,71941,,,44
javacc,JAVACC-43,Improved dump method,Task,Open,Minor,Unresolved,sriram,mortentelling,mortentelling,19/May/04 9:10 AM,,11/Jul/05 6:53 AM,,current,4.0,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","I have made an improved dump method in SimpleNode, which prints out the syntax 
 tree when called on the root node.
 
 -Morten. 
 
 ############################ JAVA CODE:
 
 /** Prints the syntax tree to the console using the toString(String prefix) 
 method
 * @param prefix Node prefix
 */ 
 public void dump(String prefix){
 this.prefix = prefix;
 boolArray = new boolean[100];
 space = "" ""; // 4-space
 dump(0);
 }
 /** Prints the syntax tree to the console using the toString(String prefix) 
 method
 * @param numSpace Numbers of space characters between parent and child node
 * @param prefix Node prefix
 */ 
 public void dump(int numSpace,String prefix){
 this.prefix = prefix;
 boolArray = new boolean[100];
 space = """";
 while (numSpace-- > 0)
 space += "" "";
 
 dump(0);
 }
 private static boolean[] boolArray;
 private static String space;
 private static String prefix = """";
 
 private void dump(int itte){
 boolArray[itte] = true;
 for (int tab=0;tab<itte;tab++){
 if (boolArray[tab] || tab==itte-1)
 System.out.print(space + ""|"");
 else
 System.out.print(space + "" "");
 }
 
 System.out.println(""_"" + toString(prefix));
 if (children != null){
 for (int i=0;i<children.length;i++){
 if (i == children.length-1)
 boolArray[itte] = false;
 
 SimpleNode n = (SimpleNode)children[i];
 if (n != null)
 n.dump(itte+1);
 }
 }
 }",,,,,,,,0|i03ttb:,,,,,22327,,,43
javacc,JAVACC-42,NullPointerException after Choice conflict,Bug,Closed,Major,Fixed,sriram,trobinson,trobinson,21/Apr/04 6:09 PM,,02/Sep/08 12:56 AM,02/Sep/08 12:56 AM,current,4.1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","I ran into an NPE that might be caused by a choice conflict. When I fixed the 
 conflict, the NPE did not occur.
 
 Java Compiler Compiler Version 3.2 (Parser Generator)
 (type ""javacc"" with no arguments for help)
 Reading from file foo.jj . . .
 Warning: Choice conflict involving two expansions at
 line 1290, column 9 and line 1292, column 9 respectively.
 Exception in thread ""main"" java.lang.NullPointerException
 at org.javacc.parser.LookaheadCalc.image(LookaheadCalc.java:74)
 at org.javacc.parser.LookaheadCalc.choiceCalc(LookaheadCalc.java:162)
 at org.javacc.parser.Semanticize$LookaheadChecker.action
 (Semanticize.java:778)
 at org.javacc.parser.ExpansionTreeWalker.preOrderWalk
 (ExpansionTreeWalker.java:37)
 at org.javacc.parser.ExpansionTreeWalker.preOrderWalk
 (ExpansionTreeWalker.java:45)
 at org.javacc.parser.Semanticize.start(Semanticize.java:429)
 at org.javacc.parser.Main.mainProgram(Main.java:161)
 at org.javacc.parser.Main.main(Main.java:87)",,,,,,,,0|i05js7:,,,,,32366,,,42
javacc,JAVACC-41,It takes too long (> 1hour) to generate parser for some grammars,Bug,Resolved,Major,Fixed,sriram,sreeni,sreeni,28/Mar/04 9:34 AM,,22/Dec/05 11:03 AM,22/Dec/05 11:03 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All",I have a grammar that takes > 1 hour on a 2.4 GHz machine.,,,,,,,,0|i0ex0v:,,,,,86999,,,41
javacc,JAVACC-40,TokenManager contains extraneous imports,Bug,Closed,Major,Incomplete,sriram,duetjohn,duetjohn,23/Mar/04 11:44 PM,,02/Sep/08 5:49 AM,02/Sep/08 5:49 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: Mac OS X
 Platform: Macintosh","When the TokenManger file is created, it contains all the imports from the
 source .jj file even though they are not needed in the lexical analyzer. This
 causes numerous warnings in IDEs which check for unnecessary imports.
 
 I removed the check for ""IMPORT"" in line 104 of org.javacc.parser.LexGen which
 seemed to clean up the problem:
 
 if(kind == PACKAGE) {
 
 instead of
 
 if(kind == PACKAGE || kind == IMPORT) {",,,,,,,,0|i08k3j:,,,,,49913,,,40
javacc,JAVACC-39,Upgrade javacc to support the new syntax features in java 1.5,Improvement,Resolved,Critical,Fixed,sriram,ericwest,ericwest,24/Feb/04 3:11 PM,,14/Nov/04 2:09 PM,14/Nov/04 2:09 PM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Please upgrade the javacc java syntax checker to support 
 the new language enhancements in java 1.5; such as generics, 
 enums, enhabnced for, etc.",,,,,,,,0|i08oif:,,,,,50628,,,39
javacc,JAVACC-38,Unnecessary String creation in TokenManager,Improvement,Resolved,Major,Fixed,sreeni,cemerick,cemerick,06/Feb/04 7:27 AM,,22/Dec/05 10:31 AM,22/Dec/05 10:31 AM,current,4.0,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","A simple modification to how the TokenManager is generated can bring significant
 performance gains; in our benchmarking, around 15% on average. Sreeni (via
 private email) has indicated that this fix is needed only for cases where
 JAVA_UNICODE_ESCAPE is false.
 
 
 Throughout the SkipLexicalActions(Token) method in the TokenManager (and in a
 couple other isolate locations), a new String and StringBuffer are created for
 each possible case. Example:
 
 --------
 case 11:
 	if (image==null)
 		image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen +
 (lengthOfMatch = jjmatchedPos + 1))));
 	else
 		[...etc...]
 	break;
 case 12: [...etc...]
 --------
 
 What immediately drew my attention was the String being created simply to get a
 StringBuffer that contained the char array coming out of
 input_stream.GetSuffix(). So, just for kicks, I did the following:
 
 - created an instance variable: private char[] _t;
 - changed all instances of 'image = new StringBuffer(new
 String(input_stream.GetSuffix[...etc...]' to this block:
 
 ---------
 _t = input_stream.getSuffix([...etc...]);
 //create new StringBuffer of correct size to hold new char[], with some extra
 room for token action use
 image = new StringBuffer(_t.length+8);
 image.append(_t);
 ---------
 
 By doing this, our test cases ran about 15% faster on average. It's a
 relatively simple change that doesn't seem to have any downside at all (and I'd
 imagine that memory consumption is improved as well, since all those String
 instances aren't being created just to populate the StringBuffer).",,,,,,,,0|i08d7r:,,,,,48798,,,38
javacc,JAVACC-37,Need a good Java JJTree grammar,Task,Open,Major,Unresolved,paulcager,sreeni,sreeni,27/Dec/03 4:24 PM,,02/Sep/08 6:06 AM,,current,not determined,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","The distro contains only Java grammar. Not the jjtree stuff. It would be of
 great help if a good jjtree grammar is written for Java (including for 1.5).",,,,,,,,0|i099uv:,,,,,54086,,,37
javacc,JAVACC-36,Need a Java 1.5 gramamr,Task,Resolved,Major,Fixed,sreeni,sreeni,sreeni,27/Dec/03 3:51 PM,,24/Dec/04 9:59 AM,24/Dec/04 9:59 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","We need a Java grammar for JDK 1.5 with all the new features as a part of the
 distribution in the examples.",,,,,,,,0|i01jhr:,,,,,8991,,,36
javacc,JAVACC-35,No source tarball in the download section,Improvement,Resolved,Major,Fixed,sreeni,kandid,kandid,20/Dec/03 5:55 AM,,24/Dec/04 9:58 AM,24/Dec/04 9:58 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: Linux
 Platform: All","The problem is that the source based linux distro Gentoo refuses to integrate install scripts into 
 their distribution that are using binary packages. They want to have only scripts that build each 
 package from source. Hence it would be nice to have a tarball containing the sources for 
 download in the file sharing section. 
 If I overlooked something or can be of any help in this, please let me know.",,,,,,,,0|i0baa7:,,,,,65819,,,35
javacc,JAVACC-34,jjtree for ant,Task,Closed,Major,Incomplete,sreeni,manujava,manujava,18/Dec/03 5:11 AM,,02/Sep/08 5:48 AM,02/Sep/08 5:48 AM,current,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","How could I propose some changes in the jjtree code for ant task, as it was done
 by young kim on javacc ?",,,,,,,,0|i0aupj:,,,,,63296,,,34
javacc,JAVACC-33,Scripts for Unix fail under Cygwin,Bug,Resolved,Major,Fixed,sreeni,sarvela,sarvela,12/Dec/03 1:42 PM,,22/Dec/05 11:05 AM,22/Dec/05 11:05 AM,current,4.0,general,,0,0,,,,,,,,"Operating System: other
 Platform: PC","The key line in the ""javacc"" script for Unix-like systems is:
 
 java -classpath `dirname $0`/lib/javacc.jar javacc ""$@""
 
 However, under Cygwin on a Windows box, this fails. Here's why. The ""java""
 launcher is part of a
 Windows distribution of Java and it expects classpath elements to be Windows
 filenames with ""\""
 and a drive prefix. However, this script is generating a Unix-style filename
 with ""/"" and with
 the Cygwin convention for roots (typically, ""/"" represents the root of the
 Cygwin installation and
 other drives are reached with a path like ""/cygdrive/d"" where ""d"" is the drive
 name). So, the script
 fails because the javacc.jar file can't be found.
 
 Here's a fix that seems to work on both Cygwin and on other Unix-like systems
 that I've tried
 (Linux and Sun). Replace the single key line above with the following statements:
 
 JAR=""`dirname $0`/lib/javacc.jar""
 
 case ""`uname`"" in
 CYGWIN*) JAR=""`cygpath --windows -- ""$JAR""`"" ;;
 esac
 
 java -classpath ""$JAR"" javacc ""$@""
 
 Similarly for scripts ""jjtree"" and ""jjdoc"".",,,,,,,,0|i051y7:,,,,,29477,,,33
javacc,JAVACC-32,LookAheadSuccess error by end of parsing,Bug,Resolved,Major,Fixed,sriram,francisandre,francisandre,21/Nov/03 1:49 PM,,11/Jul/05 6:54 AM,11/Jul/05 6:54 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Hi
 
 The parser geenrates a LookAheadSuccess error by the end of parsing an input 
 text with the following trace:
 
 Grammar$LookaheadSuccess
 Grammar.<init>(Grammar.java:17679)
 	at Parser.parse(Parser.java:156)
 	at Parser.main(Parser.java:128)
 
 Traces and additional information send to Sreeni.
 
 the error disappears when the grammar is generated with 
 	ERROR_REPORTING 		= false;
 Regards",,,,,,,,0|i04bmn:,,,,,25213,,,32
javacc,JAVACC-31,"Allow user's specialisation of SKIP, TOKEN and SPECIAL TOKEN computation",Improvement,Open,Major,Unresolved,sreeni,francisandre,francisandre,16/Nov/03 9:05 AM,,02/Sep/08 3:07 AM,,current,not determined,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Hi Sreeni
 
 Purpose of this enhancement is to provide the user the capability to specialize the 
 kind of token returned by the scanner. Currently, the getNextToken() method is 
 using the following tests for the determination of the type of the token.
 
 jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077)) to match a Token
 jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))to match a Special
 continue EOFLoop to match a Skipped
 
 
 1/ Proposal.
 The enhancement consists in adding protected methods to select the type of the 
 token as:
 
 protected boolean isToken() {
 return jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077));
 }
 protected boolean isSpecial() {
 return jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077));
 }
 protected boolean isSkipped() {
 return jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077));
 }
 
 and replacing the code in the getNextToken method by these calls.
 
 
 2/ Usage
 With this proposal, one could decide by specialisation of these methods, if a 
 regular or special token should be considered as such or skipped depending on 
 external consideration.
 
 
 Regards.
 
 Francis",,,,,,,,0|i0ac67:,,,,,60293,,,31
javacc,JAVACC-30,"With MULTI option set, node doesn't need to have the id field",Improvement,Open,Major,Unresolved,sreeni,sreeni,sreeni,09/Nov/03 10:07 AM,,02/Sep/08 3:07 AM,,current,not determined,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","When MULTI option is set, a node should know its own type (constant). So the id
 field is unnecessary memory overhead. So there should just be get/set methods
 for id in simplenode and the constructors for various nodes need to be adjusted
 accordingly for MULTI.",,,,,,,,0|i020x3:,,,,,11814,,,30
javacc,JAVACC-29,Need ability to generate HTML docuemnt for jjtree spec like jjdoc,New Feature,Open,Major,Unresolved,sreeni,sreeni,sreeni,09/Nov/03 9:54 AM,,22/Dec/05 11:58 AM,,current,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","It would be nice if there is something like jjtreedoc that takes a jjt file and
 generates
 something like jjdoc output that explains the tree structure being built by the
 jjt file",,,,,,,,0|i02v53:,,,,,16710,,,29
javacc,JAVACC-28,testing issue email,Bug,Closed,Major,Incomplete,sreeni,sreeni2,sreeni2,15/Oct/03 4:39 PM,,02/Sep/08 5:47 AM,02/Sep/08 5:47 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All",testing issue email sreeni2,,,,,,,,0|i0dpy7:,,,,,80021,,,28
javacc,JAVACC-27,testing issue email,Bug,Closed,Major,Incomplete,sreeni,sreeni,sreeni,15/Oct/03 8:46 AM,,02/Sep/08 5:47 AM,02/Sep/08 5:47 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All",testing issue email,,,,,,,,0|i0d3nr:,,,,,76410,,,27
javacc,JAVACC-26,Need a constructor that can take an encoding,Improvement,Resolved,Major,Fixed,sriram,sreeni,sreeni,14/Oct/03 8:48 AM,,11/Jul/05 6:54 AM,11/Jul/05 6:54 AM,current,4.0,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","It would be nice for javacc generated parsers to have constructors that take an
 input stream and character encoding so it is easy to parse different character sets.",,,,,,,,0|i0dcgn:,,,,,77836,,,26
javacc,JAVACC-25,Code generation error for close scope in JJTree,Bug,Closed,Major,Incomplete,sreeni@javacc.dev.java.net,kbj,kbj,06/Oct/03 1:55 PM,,02/Sep/08 5:47 AM,02/Sep/08 5:47 AM,current,milestone 1,jjtree,,0,0,,,,,,,,"Operating System: All
 Platform: All","The following kind of production in JJTree exhibits (what I think) is strange 
 behavior:
 
 nt() #nt :
 { Token t; }
 {
 ( t=<token> { SimpleNode n = new TokenNode(); jjtree.push(n); }
 Note: ^
 The code to close the scope for nt() gets inserted at the position of the caret 
 above.
 }
 
 The node (TokenNode) token becomes a sibling of #nt and not one of its 
 children. Is this behavior intentional or a defect?",,,,,,,,0|i0bis7:,,,,,67196,,,25
javacc,JAVACC-24,StackOverflowError on if then else construc,Bug,Open,Blocker,Unresolved,sriram,francisandre,francisandre,01/Oct/03 6:48 AM,,15/Mar/06 10:42 AM,,current,4.0,parser generator,,1,0,,,,,,,,"Operating System: Windows XP
 Platform: PC","Hi Sreeni
 
 I got the following StackOverflow on a ""classical"" IF/THEN/ELSE non terminal as
 
 void COMMAND:() {} {
 ( ALLOCATE()
 | DELETE()
 | IF()
 | CLOSE()
 )
 }
 void IF:() {} {
 <IF> Condition()
 <THEN> COMMAND()
 [ LOOKAHEAD(1) <ELSE> COMMAND() ]
 }
 
 
 Do you need more detail or the stack traces with the rules will be enough!! Note 
 that when the line [ LOOKAHEAD(1)....] is commented out, there is no 
 stackoverflow.
 
 Francis
 
 Java Compiler Compiler Version 3.0 (Parser Generator)
 (type ""javacc"" with no arguments for help)
 Reading from file AMS.jj . . .
 java.lang.StackOverflowError
 	at org.netbeans.javacc.parser.LookaheadWalk.vectorAppend
 (LookaheadWalk.java:26)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:106)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:67)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:59)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:67)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:53)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:67)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:59)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:67)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:53)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:67)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:76)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:67)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:53)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:67)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:59)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:67)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:53)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFirstSet
 (LookaheadWalk.java:67)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:164)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:137)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:152)
 	at org.netbeans.javacc.parser.LookaheadWalk.genFollowSet
 (LookaheadWalk.java:180)
 Exception in thread ""main""",,,,,,,,0|i08mtr:,,,,,50355,,,24
javacc,JAVACC-23,complete c grammar,Bug,Closed,Major,Incomplete,sriram,zam,zam,29/Sep/03 6:08 PM,,02/Sep/08 5:46 AM,02/Sep/08 5:46 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: Windows XP
 Platform: PC","Does anyone here have a complete c grammar because i really need it for my c
 parser project. I hope u all could help me. Thanks",,,,,,,,0|i0f8jj:,,,,,88865,,,23
javacc,JAVACC-22,Dynamic tabs valuation for exact column computation,Task,Resolved,Major,Fixed,sreeni,francisandre,francisandre,24/Sep/03 10:09 AM,,22/Dec/05 11:07 AM,22/Dec/05 11:07 AM,current,4.0,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Hi Sreeni
 
 Here is a simple path to provide a dynamic value of the 
 tabs control character in order to compute the right 
 column. This change is upward compatible with previous
 version of caller of JavaCharStream/SimpleCharStream.
 
 Changes are:
 1/ adding of a protected int tabs field initialized to 8.
 2/ adding of the setTabs(int newtabs) method that 
 returns the previous tabs value;
 3/ change the computation of the column in the 
 UpdateLineColumn method
 
 Regards
 
 Francis ANDRE
 
 Index: JavaFiles.java
 ==============================================================
 =====
 RCS file: /cvs/javacc/src/org/javacc/parser/JavaFiles.java,v
 retrieving revision 1.2
 diff -u -r1.2 JavaFiles.java
 --- JavaFiles.java	11 Aug 2003 17:06:43 -0000	1.2
 +++ JavaFiles.java	23 Sep 2003 08:44:25 -0000
 @@ -237,7 +237,15 @@
 ostr.println(prefix + ""protected int maxNextCharInd = 0;"");
 ostr.println(prefix + ""protected int nextCharInd = -1;"");
 ostr.println(prefix + ""protected int inBuf = 0;"");
 +	ostr.println(prefix + ""protected int tabs = 8;"");
 ostr.println("""");
 +	ostr.println(prefix + ""public final int setTabs(int newtabs)"");
 +	ostr.println("" {"");
 +	ostr.println("" int prevtabs = tabs;"");
 +	ostr.println("" tabs = newtabs;"");
 +	ostr.println("" return prevtabs;"");
 +	ostr.println("" }"");
 +	ostr.println("""");
 ostr.println(prefix + ""protected void ExpandBuff(boolean wrapAround)"");
 ostr.println("" {"");
 ostr.println("" char[] newbuffer = new char[bufsize + 2048];"");
 @@ -420,7 +428,7 @@
 ostr.println("" break;"");
 ostr.println("" case '\\t' :"");
 ostr.println("" column--;"");
 - ostr.println("" column += (8 - (column & 07));"");
 + ostr.println("" column += (tabs - (column & (tabs -1)));"");
 ostr.println("" break;"");
 ostr.println("" default :"");
 ostr.println("" break;"");
 @@ -948,6 +956,14 @@
 ostr.println(prefix + ""protected char[] buffer;"");
 ostr.println(prefix + ""protected int maxNextCharInd = 0;"");
 ostr.println(prefix + ""protected int inBuf = 0;"");
 +	ostr.println(prefix + ""protected int tabs = 8;"");
 +	ostr.println("""");
 +	ostr.println(prefix + ""public final int setTabs(int newtabs)"");
 +	ostr.println("" {"");
 +	ostr.println("" int prevtabs = tabs;"");
 +	ostr.println("" tabs = newtabs;"");
 +	ostr.println("" return prevtabs;"");
 +	ostr.println("" }"");
 ostr.println("""");
 ostr.println(prefix + ""protected void ExpandBuff(boolean wrapAround)"");
 ostr.println("" {"");
 @@ -1101,7 +1117,7 @@
 ostr.println("" break;"");
 ostr.println("" case '\\t' :"");
 ostr.println("" column--;"");
 - ostr.println("" column += (8 - (column & 07));"");
 + ostr.println("" column += (tabs - (column & (tabs -1)));"");
 ostr.println("" break;"");
 ostr.println("" default :"");
 ostr.println("" break;"");",,,,,,,,0|i0boav:,,,,,68090,,,22
javacc,JAVACC-21,Make Javacc a deterministic compiler,Improvement,Closed,Major,Incomplete,sreeni,moreau,moreau,15/Sep/03 7:44 AM,,02/Sep/08 5:46 AM,02/Sep/08 5:46 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Given a file.
 Running Javacc two twos on this file should produce two identical files.
 This enhancement would be very useful for people working with CVS.",,,,,,,,0|i0dgcv:,,,,,78467,,,21
javacc,JAVACC-20,Enhancement to character specifications in tokenizer patterns,Improvement,Open,Major,Unresolved,sreeni,beesley,beesley,12/Sep/03 3:09 AM,,02/Sep/08 3:07 AM,,current,not determined,scanner generator,,0,2,,,,,,,,"Operating System: All
 Platform: Sun","When defining tokens you can currently specify sets of characters between
 square brackets, e.g.
 
 TOKEN:
 {
 < ID: ([""a""-""z"", ""A""-""Z"", ""@"", ""_"" ])+ >
 }
 
 I have the following requests/suggestions for enhancements
 to character-set notation. 
 
 1. Add syntax to subtract one character set from another, e.g.
 
 < ID: ( [[""a""-""z"", ""A""-""Z""] - [""m"", ""n"", ""M"", ""N""]] )+ >
 
 would match IDs consisting of one or more basic ASCII characters 
 except n, m, M and N. This would facilitate specification of
 wide ranges of characters, with just a few exceptions.
 
 2. Add ability to refer to sets of characters using Java-method notation, e.g.
 
 < ID: ( [isLetter()] )+ >
 
 < FOO: ( [isLetter()] )+ ( [isWhitespace()] )* ""("" >
 
 < INT: ( [isDigit()] )+ >
 
 < ID: [isLetter()] ( [isLetter(), isDigit()] )* >
 
 (Sreeni was already thinking of exposing all the java.lang.Character.is* methods,
 which sounds like the right approach.)
 
 This will facilitate defining programming languages that really take advantage of 
 Unicode, e.g. allowing identifiers to contain any Unicode ""letter"". 
 
 Complication: locales. It might be necessary to specify to JavaCC the
 relevant locale for interpreting ""isDigit"", ""isLetter"", etc. (I'm not an
 expert on java.lang.Character.is* methods or locales.)
 
 
 3. (I'm not so sure about this one, but list it as a possibility). Refer to
 sets of 
 Unicode characters using official Unicode Block Names
 
 < CYRILLICID: [CYRILLIC] ( [CYRILLIC, LATIN] )* >
 
 4. (I'm not so sure about this one either.) Allow specification of character
 sets using intersection (e.g. the & operator):
 
 < ARABICINT : ( [ARABIC] & [isDigit] )+ >",,,,,,,,0|i00pzj:,,,,,4211,,,20
javacc,JAVACC-19,inline comment on last line with no line feed,Bug,Resolved,Major,Incomplete,sreeni,kenhall,kenhall,11/Sep/03 6:24 AM,,24/Dec/04 10:23 AM,24/Dec/04 10:23 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: Windows 2000
 Platform: PC","Parsing a file with an inline comment on the last line of the file which is not 
 followed by a line feed generates a lexical error -
 
 Lexical error at line XXX, column YY. Encountered: <EOF> after : """"
 
 This error is very easy to generate - just take any java file and make the last line 
 look something like this -
 
 
 }//end of my java file
 
 The important thing is that there is no line feed after the end of the comment. 
 
 This was found using javacc-3.2 and java1_4c.jj. 
 I presume that it really relates to the .jj file rather than the tool but I couldn't find 
 anywhere to submit problems with the .jj files. I have also let Andrea Gini (who 
 wrote the .jj file) know.",,,,,,,,0|i0ajvr:,,,,,61542,,,19
javacc,JAVACC-18,Handling of latin1 characters,Bug,Closed,Major,Incomplete,sreeni,bonniot,bonniot,06/Sep/03 9:40 AM,,02/Sep/08 5:45 AM,02/Sep/08 5:45 AM,current,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: Linux
 Platform: PC","Hi,
 
 I used to generate a parser with JavaCC 1.1. I recently upgraded to 3.1. It
 mostly works well, except that 3.1 seems to handle incorrectly latin1
 characters, while it used to work with 1.1. I set the option JAVA_UNICODE_ESCAPE
 in the options { ... } section of the .jj file. I don't set UNICODE_INPUT, so it
 has its default value of false. The generated stream handler is JavaCharStream.
 
 When using the generated parser, I get Encountered ""\ufffd"", at the location
 where a \u00e9 character is (and \u00e9 is indeed valid at that place). I tried
 both running with the C and fr locales, with no change.
 
 Is this a known issue? By lack of time, I don't provide a testcase now, but just
 tell me if you need one.",,,,,,,,0|i0bmj3:,,,,,67803,,,18
javacc,JAVACC-17,Modular grammer files,New Feature,Open,Major,Unresolved,sriram,neonbunny,neonbunny,29/Aug/03 4:04 AM,,28/Oct/06 9:40 PM,,current,milestone 1,parser generator,,1,0,,,,,,,,"Operating System: All
 Platform: All","It would be nice, and it has been proposed before, to allow grammer files to be
 split up into modules to allow related parts of large grammers to be kept in
 seperate files.",,,,,,,,0|i032af:,,,,,17868,,,17
javacc,JAVACC-16,More accessable TokenMgrError,Improvement,Resolved,Major,Won't Fix,neonbunny,neonbunny,neonbunny,18/Aug/03 3:47 PM,,11/Jul/05 6:54 AM,11/Jul/05 6:54 AM,current,4.0,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","I'd like to be able to get the row/column of the error, and perhaps the token it
 was expecting and a list of other tokens which could be here, very much in the
 style of a ParseException.
 This would make writing a single error handling mechanism for both types of
 error a lot easier.",,,,,,,,0|i0elxj:,,,,,85202,,,16
javacc,JAVACC-15,"Need support for re's of the form {m,}",Improvement,Resolved,Major,Fixed,sreeni,sreeni,sreeni,17/Aug/03 9:30 AM,,30/Jul/04 4:42 PM,30/Jul/04 4:42 PM,current,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Would like to have JavaCC regular expressions support regex-like {m,} operator
 that only specifies the minimum, but no maximum",,,,,,,,0|i05hvz:,,,,,32059,,,15
javacc,JAVACC-14,usage.html has license that is inconsistent with BSD,Bug,Closed,Major,Incomplete,sreeni,sreeni,sreeni,11/Aug/03 11:08 AM,,02/Sep/08 5:44 AM,02/Sep/08 5:44 AM,current,4.0,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","In the JavaCC installation, the license agreement file that is installed
 (doc/usage.html0 has Java Binary Code license agreement. But it is supposed to
 have the BSD license there.",,,,,,,,0|i04nuv:,,,,,27194,,,14
javacc,JAVACC-13,KEEP_LINE_COLUMN=false and ERROR_REPORTING=false generates bad code,Bug,Resolved,Major,Fixed,javacc-issues,sreeni,sreeni,08/Aug/03 1:16 PM,,11/Aug/03 10:32 AM,11/Aug/03 10:32 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","When KEEP_LINE_COLUMN option value is set to false and ERROR_REPORTING is turned
 on, the generated code refers to line and col related methods that don't exist.",,,,,,,,0|i05vy7:,,,,,34337,,,13
javacc,JAVACC-12,TokenMgrError should be an Exception,Bug,Open,Major,Unresolved,tcopeland,danimx,danimx,07/Aug/03 9:40 AM,,11/Nov/07 2:18 PM,,current,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: Windows XP
 Platform: PC","According to jdk documentation, any error a reasonable app might want to catch 
 should be an exception. That is specially important for coldfusion users, because 
 coldfusion pages cannot catch errors in its new version.
 These are the changes needed in the generated code:
 
 TokenMgrError.java
 ==============
 - TokenMgrError extends Exception
 + TokenMgrError extends Error
 
 CalculatorTokenManager.java
 ======================
 - public void SwitchTo(int lexState)
 + public void SwitchTo(int lexState) throws TokenMgrError
 - public Token getNextToken() 
 + public Token getNextToken() throws TokenMgrError
 - public CalculatorTokenManager(SimpleCharStream stream, int lexState) 
 + public CalculatorTokenManager(SimpleCharStream stream, int lexState) throws 
 TokenMgrError
 - public void ReInit(SimpleCharStream stream, int lexState) 
 + public void ReInit(SimpleCharStream stream, int lexState) throws TokenMgrError
 
 
 Additionally, TokenMgrError can be renamed to TokenMgrException, or made a 
 subclass of it for backwards compatibility.
 
 You can contact me for any additional information.",,,,,,,,0|i0am47:,,,,,61904,,,12
javacc,JAVACC-11,JavaCC generated code contains 'enum' as a variable name,Bug,Resolved,Major,Fixed,sreeni,sreeni,sreeni,06/Aug/03 12:01 PM,,11/Jul/05 6:54 AM,11/Jul/05 6:54 AM,current,milestone 1,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","JavaCC generated code has 'enum' as avariable name. Since it is going to be a
 keyword from 1.5 (Tiger) onwards, we need to change it.",,,,,,,,0|i07unj:,,,,,45791,,,11
javacc,JAVACC-10,JavaDoc error in SimpleCharStream,Bug,Resolved,Major,Fixed,neonbunny,neonbunny,neonbunny,06/Aug/03 10:52 AM,,19/Aug/03 1:09 AM,19/Aug/03 1:09 AM,current,milestone 1,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","The <BR> in the JavaDoc comment of SimpleCharStream causes a warning to be
 produced using the javadoc that comes with J2SDK 1.4.2.
 It's not needed and I recommend removing it from JavaFiles.java",,,,,,,,0|i0bnb3:,,,,,67929,,,10
javacc,JAVACC-9,Need warnings for options that require complete cleanup,Improvement,Closed,Major,Fixed,paulcager,sreeni,sreeni,08/Jul/03 11:17 AM,,25/Nov/10 6:52 PM,02/Sep/08 12:55 AM,current,4.1,general,,0,0,,,,,,,JAVACC-59,"Operating System: All
 Platform: All","When a user toggles the STATIC or KEEP_LINE_COLUMN options, all the generated
 files need to be removed. Otherwise, there will be compiler errors.
 
 So JavaCC should give a warning when one of these options is toggled from a
 previous run, probably by tagging the generated files.",,,,,,,,0|i01cv3:,,,,,7917,,,9
javacc,JAVACC-8,Token manager should not use IOException to mark EOF,Improvement,Resolved,Major,Duplicate,javacc-issues,sreeni,sreeni,07/Jul/03 1:58 PM,,02/Sep/08 2:48 AM,02/Sep/08 2:48 AM,current,5,scanner generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","Right now, the *CharStream classes throw IOException to indicate EOF reached.
 This exception is caught by the token manager to eventually return the EOF token.
 
 I would like to change this to throw a javacc-specific exception so that there
 is no confusion between the exception thrown by the *CharStream classes and the
 one thrown by the InputStream/Reader classes of java.io.",,,,,,,,0|i0ce0f:,,,,,72255,,,8
javacc,JAVACC-7,Unused code in NfaState,Task,Resolved,Major,Fixed,javacc-issues,tcopeland,tcopeland,25/Jun/03 11:19 AM,,11/Aug/03 10:43 AM,11/Aug/03 10:43 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Here ya go... another little cleanup patch...
 
 Yours,
 
 tom
 
 Index: src/org/javacc/parser/NfaState.java
 ===================================================================
 RCS file: /cvs/javacc/src/org/javacc/parser/NfaState.java,v
 retrieving revision 1.1
 diff -r1.1 NfaState.java
 461,462d460
 < int i;
 <
 548c546
 < int j, k;
 ---
 > int j;
 738d735
 < char tmp;
 806d802
 < int tmp;
 1194,1196d1189
 < String arrayString, name;
 < int i, cnt = 0;
 <
 1330d1322
 < int[] newNameSet;
 1336d1327
 < NfaState tmp;
 1352d1342
 < boolean current[];
 1410d1399
 < boolean First = true;
 1472d1460
 < int[] newNameSet;
 2124d2111
 < Enumeration e = compositeStateTable.keys();
 2625c2612
 < int state, oldCnt = cnt;
 ---
 > int state = cnt;
 2898,2900d2884
 < boolean moreThanOne = false;
 < int cnt = 0;
 <",,,,,,,,0|i020vr:,,,,,11808,,,7
javacc,JAVACC-6,Optimize away some jj_3 methods in the parser,Improvement,Resolved,Major,Fixed,sreeni,sreeni,sreeni,23/Jun/03 9:19 AM,,11/Jul/05 6:54 AM,11/Jul/05 6:54 AM,current,4.0,parser generator,,0,0,,,,,,,,"Operating System: All
 Platform: All","There are several jj_3 methods that simply look for a token of a certain kind.
 It will be nice to eliminate those so that the parser class file size gets smaller.",,,,,,,,0|i0a847:,,,,,59636,,,6
javacc,JAVACC-5,Unused code in RStringLiteral,Task,Resolved,Major,Fixed,javacc-issues,tcopeland,tcopeland,23/Jun/03 8:40 AM,,11/Aug/03 10:43 AM,11/Aug/03 10:43 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Index: src/org/javacc/parser/RStringLiteral.java
 ===================================================================
 RCS file: /cvs/javacc/src/org/javacc/parser/RStringLiteral.java,v
 retrieving revision 1.1
 diff -r1.1 RStringLiteral.java
 279d278
 < RegularExpression RE; // Single char or a sequence of chars
 504d502
 < Enumeration infos;
 508d505
 < int tmpCtr = 0;
 512,513d508
 < String[] activeNames = { ""jjnewActive"" + LexGen.lexStateSuffix,
 ""jjoldActive"" + LexGen.lexStateSuffix };
 <
 758d752
 < int matchedKindForZero = Integer.MAX_VALUE;
 1017,1018c1011,1012
 < String key, stateSetString = """";
 < int i, j, k, kind, jjmatchedPos = 0;
 ---
 > String stateSetString = """";
 > int i, j, kind, jjmatchedPos = 0;
 1144,1145c1138
 < int i, k, maxKindsReqd = maxStrKind / 64 + 1;
 < boolean ifGenerated;
 ---
 > int i, maxKindsReqd = maxStrKind / 64 + 1;
 1172,1173d1164
 < Object o;
 <
 1177d1167
 < String s;",,,,,,,,0|i02193:,,,,,11868,,,5
javacc,JAVACC-4,Unused code in RCharacterList,Task,Resolved,Major,Fixed,javacc-issues,tcopeland,tcopeland,23/Jun/03 8:36 AM,,11/Aug/03 10:43 AM,11/Aug/03 10:43 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Here ya go... just some more minor cleanups...
 
 Yours,
 
 Tom
 
 
 Index: src/org/javacc/parser/RCharacterList.java
 ===================================================================
 RCS file: /cvs/javacc/src/org/javacc/parser/RCharacterList.java,v
 retrieving revision 1.1
 diff -r1.1 RCharacterList.java
 171d170
 < char c;
 307d305
 < int i;
 308a307
 > int i;
 321c320
 <
 ---
 >
 408d406
 < Enumeration e = descriptors.elements();
 433d430
 < char r = ((CharacterRange)newDesc.elementAt(j)).right;
 463,465d459
 < char l = ((CharacterRange)newDesc.elementAt(j)).left;
 < char r = ((CharacterRange)newDesc.elementAt(j)).right;
 <",,,,,,,,0|i0f3fz:,,,,,88039,,,4
javacc,JAVACC-3,Need automatic testing for changes in JavaCC,Task,Open,Major,Unresolved,sreeni,sreeni,sreeni,20/Jun/03 10:57 AM,,16/Nov/07 9:05 AM,,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","We need to enhance the build.xml with a new target to run tests automatically.
 As a start, we can use the grammars that are in the examples directory. Each
 test should include running JavaCC and testing the generated parsers on some
 inputs (with and without syntax errors).",,,,,,,,0|i0fh9r:,,,,,90279,,,3
javacc,JAVACC-2,Unused code in ParseEngine.java,Task,Resolved,Major,Fixed,javacc-issues,tcopeland,tcopeland,20/Jun/03 7:52 AM,,11/Aug/03 10:43 AM,11/Aug/03 10:43 AM,current,milestone 1,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","Is a cvs diff a good way to submit patches?
 
 Thanks,
 
 Tom
 
 [tom@hal javacc]$ cvs diff src/org/javacc/parser/ParseEngine.java
 Index: src/org/javacc/parser/ParseEngine.java
 ===================================================================
 RCS file: /cvs/javacc/src/org/javacc/parser/ParseEngine.java,v
 retrieving revision 1.1
 diff -r1.1 ParseEngine.java
 572d571
 < String action;
 574d572
 < Lookahead la;
 [tom@hal javacc]$",,,,,,,,0|i01z6v:,,,,,11534,,,2
javacc,JAVACC-1,OUTPUT_DIRECTORY option inconsistencies between javacc and jjtree,Bug,Resolved,Major,Fixed,kjkoster,sreeni,sreeni,13/Jun/03 11:50 AM,,09/Jan/05 6:43 AM,09/Jan/05 6:43 AM,current,4.0,general,,0,0,,,,,,,,"Operating System: All
 Platform: All","JJTree omits the OUTPUT_DIRECTORY option when it generates the .jj file. This
 could cause a problem if someone wants to generate the tree and the parser in
 different directories. We need to rexamine this option in detail to see if it is
 still relevant to have.",,,,,,,,0|i0ezfj:,,,,,87389,,,1
Generated at Wed Aug 03 18:08:33 UTC 2016 using JIRA 6.2.3#6260-sha1:63ef1d6dac3f4f4d7db4c1effd405ba38ccdc558.
